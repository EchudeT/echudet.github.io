<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Comp on echudet</title>
        <link>https://echudet.github.io/categories/comp/</link>
        <description>Recent content in Comp on echudet</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>echudet</copyright>
        <lastBuildDate>Wed, 31 Dec 2025 15:14:12 +0800</lastBuildDate><atom:link href="https://echudet.github.io/categories/comp/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>oscomp2025 experience</title>
        <link>https://echudet.github.io/p/oscomp2025-experience/</link>
        <pubDate>Wed, 03 Sep 2025 00:00:00 +0000</pubDate>
        
        <guid>https://echudet.github.io/p/oscomp2025-experience/</guid>
        <description>&lt;img src="https://echudet.github.io/p/oscomp2025-experience/bg.jpg" alt="Featured image of post oscomp2025 experience" /&gt;&lt;blockquote&gt;
&lt;p&gt;OS火热招新 &lt;a class=&#34;link&#34; href=&#34;http://oslabs.hitsz.edu.cn/oscomp/oscomp.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://oslabs.hitsz.edu.cn/oscomp/oscomp.html&lt;/a&gt;

&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大二寒假前看到校内有操作系统比赛的招新通知，恰好有大段空闲时间，所以抱着前来积累经验的想法来参赛，同友人A和学长B组队参加。最终运气不错，取得了国一奖项。&lt;/p&gt;
&lt;h2 id=&#34;赛前积累&#34;&gt;赛前积累
&lt;/h2&gt;&lt;p&gt;在比赛报名之前，我们关于操作系统方面的经验如下：我做过mit6s081的xv6整个lab+南大的pa lab，学长B学完了大三的整个操作系统课程，并且有一定的科研经历，友人A则在这方面比较薄弱，但有学过算法课的知识。&lt;/p&gt;
&lt;p&gt;在比赛前的寒假期间，确定好比赛初期的时间安排以及内核编写语言之后，我们组团开始rust语言的学习，计划时长为3周。关于rust方面的学习，主要是通过以下几个渠道。&lt;/p&gt;
&lt;p&gt;首先是阅读Rust Course(&lt;a class=&#34;link&#34; href=&#34;https://course.rs/about-book.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://course.rs/about-book.html&lt;/a&gt;

)，学习其中的&lt;strong&gt;Rust 语言基础学习&lt;/strong&gt;和&lt;strong&gt;Rust 语言进阶学习&lt;/strong&gt;两个大章，掌握rust语言的基本和进阶内容。不过实际上在比赛中用到的进阶内容不是很多，可以粗略学习，之后有需要再回顾。&lt;/p&gt;
&lt;p&gt;其次是在Rust Practice(&lt;a class=&#34;link&#34; href=&#34;https://practice-zh.course.rs/why-exercise.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://practice-zh.course.rs/why-exercise.html&lt;/a&gt;

)里面进行简单的练习，做其中的习题，加深印象。&lt;/p&gt;
&lt;p&gt;最后是在CodeCrafters(&lt;a class=&#34;link&#34; href=&#34;https://app.codecrafters.io/catalog&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://app.codecrafters.io/catalog&lt;/a&gt;

)里面写一些简单的项目熟悉rust。我选了shell和interpreter两个当时免费的项目来练习，写了shell和部分的interpreter。这里面的项目分成多个块组成，并且内有自动判错，和xv6的lab类似，可以及时发现我们代码中隐含的错误。&lt;/p&gt;
&lt;p&gt;完成对rust的学习之后，在寒假的剩余时间里面，我们开始对rcore内核(&lt;a class=&#34;link&#34; href=&#34;https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter0/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter0/index.html&lt;/a&gt;

)的学习。&lt;/p&gt;
&lt;p&gt;这一阶段比较简单，主要是跟着rCore-Tutorial-Book手册学习。有os方面的基础不是很难，主要是掌握rust语言的os的构建模式。并且很多参赛的内核都是以rcore为基础来搭建的，掌握这个框架方便我们参考更多的rust内核。同时，也为友人A提供了内核学习的机会，能够打牢基础。&lt;/p&gt;
&lt;p&gt;新年之前学习手册的0~4章，包括环境配置、批处理系统、分时任务、地址空间四章，新年之后学习手册的5~8章，包括进程、文件系统、进程通信、并发四章，最后剩余的第九章则是留于之后写驱动的同学来看。&lt;/p&gt;
&lt;p&gt;完成每章的学习指看完各章的内容，并选择性完成章末的实验要求。在阅读各章内容的时候，要主动结合内核里面相应的代码来看，而不仅干看文档内容，这样难以深入了解内核的结构。&lt;/p&gt;
&lt;p&gt;完成上述的内容后，寒假应该仅剩余一两周的时间了，最后的这段时间就是阅读往届的优秀内核，总结经验。&lt;/p&gt;
&lt;p&gt;我们阅读了MankorOS, TitanixOS, MinotaurOS, PhoenixOS的代码及文档，并在返校之后开会讨论，对内核的整体架构有了一定的设想，这为我们之后构建内核的工作打下了坚实的基础。同时，我们也简单阅读了一些linux的资料，对于内核设计有了更深的见解。&lt;/p&gt;
&lt;h2 id=&#34;比赛过程&#34;&gt;比赛过程
&lt;/h2&gt;&lt;p&gt;我们在开学几周后才开始正式构建内核，而同实验室的第一组早已起步，这导致我们的进度在初期就已落后。加上初赛结束时恰逢期末考试月，这为我们初赛的失利埋下了伏笔&amp;hellip;&lt;/p&gt;
&lt;p&gt;这里有一个教训：构建内核越早越好，千万不要完全依赖比赛的官方时间安排。&lt;/p&gt;
&lt;p&gt;我们的内核是从零开始构建的，架构上主要参考了 PhoenixOS，同时借鉴其他内核作为优化点。在花费几天时间搭建好内核雏形后，我们召开了一个简短的会议，对内核开发进行了分工。我将工作划分为进程管理、内存、Trap 转换、文件系统、信号、驱动、网络及双架构适配等模块，并在此基础上制定了前、中、后三个开发阶段。在初期，我们需要实现进程管理、内存和 Trap 转换，这三个基本模块保障了内核能完成程序的内存映射及内核态与用户态的切换，同时也支持了多进程实现。完成这一阶段，内核便能以嵌入形式运行基本的用户程序。&lt;/p&gt;
&lt;p&gt;进入中期后，目标是实现文件系统和信号。文件系统是内核的重要组成部分，也是基础测例的重点，近半数测例与之相关；而信号部分则保证了父进程能正常控制子进程。实现了这两部分，内核就能进一步运行如 busybox 等复杂程序，并支持将测例程序打包到文件系统中进行测试。开发的后期主要是对内容进行扩充，包括实现优雅的驱动树管理、支持网络及相关系统调用，并实现 RISC-V 和 LoongArch 双架构支持。这一阶段完成后，工作重点便是对内核功能的进一步完善。&lt;/p&gt;
&lt;p&gt;在实际执行的最初两周，我们集中精力实现第一阶段的三个基本功能。我负责进程管理调度，友人 A 负责 Trap 上下文切换，学长 B 负责最复杂的内存部分。这一阶段相对简单，我们在计划时间内完成，并将部分 Basic 测例以嵌入内核的方式成功运行。&lt;/p&gt;
&lt;p&gt;下一阶段是文件系统与进程间通信。文件系统方面较为繁杂，主要涉及构建内核的虚拟文件系统以及对接外部库的具体文件系统，由我和学长 B 共同完成。我负责搭建大体架构，学长 B 在此基础上进行优化创新；友人 A 则负责编写信号等进程间通信机制。此外，还要将测试用例装入内核的磁盘文件中进行加载执行。这一阶段原计划两周，但工作比想象中更繁琐，最终花费三周才完成。不过在完成这一阶段后，busybox 测例集得以成功通过。&lt;/p&gt;
&lt;p&gt;第三阶段涉及驱动、网络、双架构以及跑通更多测例。这一部分超出计划时间最多，不仅因为功能繁杂，更因为需要支持的系统调用更多。双架构方面文档量大，由学长 B 和友人 A 共同查阅编写，我仅作简单了解；我主要负责驱动和网络部分，网络参考了 ArceOS 和 PhoenixOS，驱动则参考 MankorOS。在跑测例方面，我负责运行测试，遇到错误能解决则直接解决，不能解决则通知特定模块负责人或合作 Debug。这一阶段一直持续到六月初，即期末月。&lt;/p&gt;
&lt;p&gt;在期末月期间，我们忙于复习，没有再推进开发。此时除了 LTP 和 iperf，其他测例集基本完成，仅存少量 Bug 在修。考完试后，我们忽然发现其他队伍通过跑 LTP 拉开了巨大的分差（至少是其他测例总分的一倍），但鉴于我们需要准备初赛的文档、PPT 和视频，便没有再修补 LTP，这导致我们初赛落后于其他队伍，不过我们仍是“没跑 LTP 的队伍”中的第一名，最终初赛综合排名第九。&lt;/p&gt;
&lt;p&gt;进入决赛阶段，我们痛定思痛，先用 Linux 系统跑了一遍 LTP 测例集，统计其中的高分测例并制成表格，决定集中突破。&lt;/p&gt;
&lt;p&gt;决赛分工相对简单：我负责内核的驱动、网络及上板调试，框架在初赛已基本完成，主要是完善；同时我和学长 B 并行跑 LTP，他集中攻克 fanotify 等方面的高分测例及内核优化，我负责一些高分的杂项测例，友人 A 负责交叉编译 Vim、GCC 等程序到内核上（幸运地押中了题目），并在完成后整理更多信号机制的 LTP 测例。最终，我们成功将内核移植到 RISC-V 星光板和 LoongArch 星云板（虽仍有少量 Bug），通过了大量 LTP 测例，取得了决赛线上与线下的高分。&lt;/p&gt;
&lt;p&gt;通过现场赛后，在答辩前夜的模拟答辩中，老师对我们进行了点评。我和学长 B 讨论后，决定完全推翻原 PPT 重构大部分内容。接下来由学长 B 主导 PPT 制作，一直忙到凌晨 4 点，我则在 3 点休息以养精蓄锐。第二天早晨八点半，作为第三组出场的我们，在答辩开始前仅来得及过一遍 PPT，时间非常紧迫。好在运气不错，我们掐点完成了答辩。虽然过程未臻完美，但也取得了不错的成绩，给比赛画上了一个圆满的句号。&lt;/p&gt;
&lt;p&gt;整个比赛过程相当漫长，从寒假持续到暑假，历时半年，工作量也不小。就我个人而言，几乎把大部分课外时间都花在了写内核和 Debug 上，很少参加其他活动。因此如果想参加，就要做好忙碌的准备。最终，我们的内核 Rust 代码行数超过 40k（不含外部库和注释），累计约 1000 次 Commit 记录，并留下了充实的内核文档。&lt;/p&gt;
&lt;h2 id=&#34;内核组成&#34;&gt;内核组成
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/RustFlyer/OS/blob/main/NighthawkOS%E5%86%B3%E8%B5%9B%E6%96%87%E6%A1%A3.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;具体的内核文档见此&lt;/a&gt;

&lt;/p&gt;
&lt;h2 id=&#34;调试经验&#34;&gt;调试经验
&lt;/h2&gt;&lt;p&gt;一般使用二分法进行调试，通过log输出大量的内容来确定上下文，一方面能够知晓发生bug的位置，另一方面能够获取其上下文的参数信息，方便调bug。如果log输出过多时，可以设置动态开关log，和过滤部分log的内容，从而筛选出关键信息。&lt;/p&gt;
&lt;p&gt;如果bug发生在库的深处，或是用户态，或是地址读写卡死崩溃问题，则考虑使用gdb进行跟踪调试，先通过log确定bug大致位置，在附近打断点，然后步进跟踪各个寄存器，或特权寄存器，或相关地址的值等，来确定bug发生的原因。不过对板子就不行了，因为板子上面没有gdb，就只能用二分法调bug了。（关于gdb，听说gdb-dashboard挺好用的，可以尝试使用）&lt;/p&gt;
&lt;p&gt;除此外，调试用户态的程序还可以使用qemu-riscv64或qemu-loongarch64(这个需要额外配置)，通过输出它们系统调用的日志，来对比自己的内核和标准的内核之间的差异，从而找出bug。&lt;/p&gt;
&lt;p&gt;另外，我觉得操作系统里面比较难调的bug是内存bug和多线程bug，内存方面需要提前做好内存权限的管理，明确各个地址段的功能，这样更好追踪bug的产生。多线程则是需要为各个task建立健全的debug机制，可以在任意时间log出task的相关内容，调度时间信息等，看清楚了执行流，调bug就简单了（但也不是那么简单）。&lt;/p&gt;
&lt;h2 id=&#34;遗憾&#34;&gt;遗憾
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;多核仍有死锁情况，并发支持不完善。&lt;/li&gt;
&lt;li&gt;git本地支持正常，说明文件系统比较完善。但是git clone缺乏https，这可能是交叉编译缺失，或是文件系统还有缺陷，或是网络方面有bug，现场赛时间过短未能调出来。&lt;/li&gt;
&lt;li&gt;文件系统的挂载功能不完善，需要实现挂载队列，但这会导致预估3k+的代码重构，这个功能应该在构建内核的时候一起实现，在内核比较完善之后去改容易造成大规模的影响，积重难返。&lt;/li&gt;
&lt;li&gt;龙芯qemu的中断驱动仍存在问题，不能正常响应。并且龙芯板子上面存在奇怪的内存问题，当内核以release编译的时候会产生巨量的bug，而以debug模式编译则是少量bug，debug模式产生的未对齐处理多于release方面，怀疑是此方面问题，但是具体原因未知，未能debug出来。&lt;/li&gt;
&lt;li&gt;内核中枢多时间系统todo，但是没时间写。&lt;/li&gt;
&lt;li&gt;more ltp&amp;hellip;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;反思&#34;&gt;反思
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;内核构建需要尽早开始，最后要留出一个月的时间给ltp，因为ltp拉分最甚。&lt;/li&gt;
&lt;li&gt;内存、arch、lock、log等模块尽量解耦合，放在外部，其他模块都需要依赖它们。&lt;/li&gt;
&lt;li&gt;尽早完善调试架构，完善log机制，多进程记录机制，方便之后的调试。&lt;/li&gt;
&lt;li&gt;文件系统的各个接口都需要留出扩展接口，用于未来更多的功能扩展。&lt;/li&gt;
&lt;li&gt;注重实现更多的功能，在保证实现充足的功能的基础上考虑创新点（实际上很多创新点都是说出来的，内核本身实现就包含着很多特点，选取一些包装一下就是创新点了）。&lt;/li&gt;
&lt;li&gt;在明确一个函数的内部逻辑，输入输出的时候可以用AI代写，省时省力，但不要让AI写你不理解的内容，这会导致石山代码。&lt;/li&gt;
&lt;li&gt;明确队伍的git commit规范和注释规范，合适的开发规范能够让维护成本降低。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;答疑&#34;&gt;答疑
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Q：怎么样开始搭建内核，可以使用别人的内核吗？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	A: 有三种搭建内核的方法。这里默认你们使用rust语言，第一种是在rCore内核的基础上搭建，第二种是自己从零开始搭建，第三种是在往届优秀内核的基础上搭建。我推荐你们使用第二种方法。&lt;/p&gt;
&lt;p&gt;​	对于在往届优秀内核的基础上搭建，因为内核比赛有查重机制，使用别人的内核，优点是能节省时间，加速开发进程，但缺点是查重率高，往往会受到评委的质疑，而且如果没有什么独特的创新点和不同点，那就与高分无缘了。&lt;/p&gt;
&lt;p&gt;​	而使用rcore内核，查重率可能没有直接用往届内核的高，属于中等水平的范畴，也确实有部分往年的优秀内核是在rcore的基础上搭建的，不是不能使用，但是近几届的内核，都迭代出了很多新的特点和架构，直接在rcore的基础上借鉴更改，其操作工作量也无异于自己从零开始开发一个内核，而且对于一个不熟悉的内核，修改了容易引发一些隐蔽的错误，debug起来花费不少的时间，有点得不偿失，不如自己从零开始开发。&lt;/p&gt;
&lt;p&gt;​	所以，我推荐你们从零开始搭建自己的内核。当然，从零开始搭建并不意味着完全自行探索，你们可以借鉴往届优秀内核的思路，集百家于一身。看到好的方法就直接拿来。这里的“拿来”是指理解对方代码的思路，再按照自己的想法实现。并且，自己开发的内核，自己对内核有百分百的掌握度（AI除外），能够顺利地实现更多的功能和完成创新。这里有一个tip，你们可以通过git追溯那些优秀内核的雏形期是怎么开发的，这能够为构建内核的工作提供有力的参考。&lt;/p&gt;
&lt;p&gt;最后一点是，我们学校往届的多数优秀内核也是从零开始构建的，所以大家不用担心这是一条独行路，我们有很多可以借鉴的材料。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Q：搭建内核一定不能用AI吗？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	A：搭建内核可以使用AI，但是要注意使用AI的方法。这里有一条准则是，人要把握内核的整体架构，必须时时介入内核的搭建，不能过量使用AI。否则，可能在内核搭建的初期，AI能够正常担任工作，但是慢慢内核体积膨胀起来了，AI上下文过长，精准度下降。而内核本身就是一个极度精密的工程产品，一旦准确度下降，AI修了一个地方，忘了另一个地方，就会导致一系列的bug。这个时候，如果你本身对内核细节不熟悉，不会debug，那就只能单瞪眼了。&lt;/p&gt;
&lt;p&gt;​	那么，可以用AI的哪些功能呢？在内核比赛的初赛阶段，我的建议是使用AI的问答功能、补全功能，自己在用AI的时候时时介入内核的搭建，不全权交给AI，避免把整个搭建流程置于“黑盒”中。&lt;/p&gt;
&lt;p&gt;​	而差不多到了决赛阶段，当你们对内核有了深刻的把握，那就可以使用AI代码生成了，但这也需要你们对代码有着深刻的理解，明确需要实现的逻辑，明确输入输出，让AI一段一段地生成代码，充分审查后放入内核中。而不是交由AI-Agent自由发挥。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Q: 整个比赛中，对内核的性能有要求吗？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	A: 在我们这届，比赛中确实有对性能进行评测的测例，主要是测一些syscall、IO、schedule之类的性能。但是在所有测例集中，这部分测例集所占的分数是非常少的，从功利的角度来谈，性能完全不重要。（也不能慢的太逆天，直接在评测测例时timeout）&lt;/p&gt;
&lt;p&gt;​	这里有一个从往年流传下来的经验是：功能第一，创新第二，性能第三。&lt;/p&gt;
&lt;p&gt;​	在所有的标准中，功能是最重要的。实现的功能越多，你可以在榜单上刷到的分越多，就越可能冲击国一，这个标准在初赛和决赛占有很重要的地位。其次就是创新，创新部分影响的分数主要是在决赛最后一个答辩环节，你的创新点越突出，答辩环节的分数可能就越高。当然答辩分数也不全受创新影响，还和你的ppt展示技术息息相关。但总的来说，创新点亮眼，答辩分数也不会太低。&lt;/p&gt;
&lt;p&gt;​	最后就是性能了，这一点其实不重要，放在第三也只是为了表现它的位置最不重要，你甚至可以不实现多核。当然，有理想的同学可以冲击一下，性能比较高的话也是可以在答辩ppt上展示一下的。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Q：可以介绍一下你们当时的时间安排吗？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	A: 我们的时间安排在博客上有提到，赛前积累部分比较清晰，可能比赛途中比较模糊，那么这里再具体介绍一下。&lt;/p&gt;
&lt;p&gt;​	首先需要说明的一点，我们的时间安排仅供参考，因为我们初赛是比较落后的，所以你们要参考的话最好能比我们提前一两周完成任务。&lt;/p&gt;
&lt;p&gt;​	寒假结束后(2月24日)，我们小队在开学的两周里继续研究往年的内核，并且处理一些开学琐事。然后在第二周的周末(3月9日)进行第一个会议，这个会议明确了初期的分工和两周的工作时间，然后各自开始执行任务。第四周周末(3月23日)，我们集会明确完成初期安排，并进入中期的工作阶段，这个阶段原本规划为两周，后面改为三周，实际上，我们在完成划分的底层功能同时，也需要完成很多syscal和测例适配，因此比较耗时。第七周周末(4月13日)，我们进入最后一个阶段，完成双架构、驱动和网络。这一阶段比较繁杂，实际上除了上述的三个功能，还需要适配大量的比赛测例来刷榜，实际上，最后一个阶段一直持续到初赛截止，没有进一步的划分。&lt;/p&gt;
&lt;p&gt;​	决赛阶段比较朴素，一共三个重点，完善网络模块、驱动模块，实现更多测例，适配更多应用。大家分好工作，自己就去负责自己的任务，仅要保证每周有一定的工作量即可。&lt;/p&gt;
&lt;p&gt;​	那么，有一点需要提醒，在上述的安排中，每个阶段除了要完成自己的模块外，还需要完善之前阶段的模块和通过更多的测例，因此，越往后的阶段，所需要的时间也越长。&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;Q: 听说网络模块很难，我的队友都不会网络怎么办？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	A: 实际上，网络模块并不需要我们从零开始实现一个网络协议栈，正如文件系统模块也不需要我们从零开始搭一个ext4。对于网络模块而言，rust这边我们有一个smoltcp的网络栈库，已经实现了底层最基本的功能，我们只需要在内核里将它包装起来，向上层提供接口即可。因此，就算你不会实现底层网络的协议栈，你也可以通过外部库实现基本的网络功能。要是最基础的网络都不了解的话，也可以去“借鉴”一下往届的内核。&lt;/p&gt;
&lt;p&gt;​	不过话虽如此，在内核里面实现网络接口的细节还是比较繁琐的，我们这一届的优秀内核中也只有清华的一个内核真正实现了网络功能，大家到时候可以去参考他们的实现。&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;Q：可以参考哪些内核？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	A： 我们学校往届的Chronix、Del0n1x都是比较优秀的内核，如果是使用rust语言的同学都可以参考一下，这些内核迭代了我们学校历年的优秀内核的思路，也许可以给你们搭建内核的方法一点启发。&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;Q：可以用C语言吗，我不会Rust？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	A：虽然目前比赛官方还支持C语言（例如相应的驱动代码会提供rust和c的版本），但我不是很建议使用C语言。&lt;/p&gt;
&lt;p&gt;​	首先，C语言本身过于原始，各方面语法都不如Rust便利，没有Rust写起来舒服。其次，C语言对内存、指针的管理完全依赖人工，极其容易出错。在C语言中，你需要全程手动管理内存的分配与释放，这导致了段错误、悬垂指针、缓冲区溢出等Bug在内核开发中层出不穷。在内核态下调试这些内存问题通常是极度痛苦的，你可能会发现大部分时间不是在写核心逻辑，而是在对着黑屏或奇怪的寄存器报错，去排查到底是哪里内存写挂了。&lt;/p&gt;
&lt;p&gt;​	相比之下，Rust 最核心的优势在于编译期排雷。它能使用所有权和借用检查机制强制你处理潜在的内存泄露或并发竞争问题。虽然这可能导致前期编码速度变慢，但只要你的代码能编译通过，程序大概率就是正确且稳定的。这彻底告别了C语言那“编译一时爽，运行火葬场”的窘境。&lt;/p&gt;
&lt;p&gt;​	此外，从开发体验来看，Rust 也是降维打击。C语言通常要你手写复杂的 Makefile 或 CMake 配置，还要处理繁琐的依赖库链接；而 Rust 的 Cargo 包管理器能一键解决依赖、构建和测试，极大地降低了负担。&lt;/p&gt;
&lt;p&gt;​	最后，最重要的一点是Rust有很多往届的优秀内核参考，而C基本没得参考。例如我们这届的四个内核都是Rust编写的。因此，使用Rust，你将更容易参考往届的优秀内核。&lt;/p&gt;
&lt;p&gt;​	顺带一提，就算不会Rust也不必担心，可以寒假开始学。我们队伍三人最开始完全不会Rust，也是在寒假开始学慢慢掌握的。现在还有时间，所以不必因为自己不会Rust就不使用Rust。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
