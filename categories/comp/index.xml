<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Comp on echudet</title>
        <link>https://echudet.github.io/categories/comp/</link>
        <description>Recent content in Comp on echudet</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>echudet</copyright>
        <lastBuildDate>Tue, 30 Dec 2025 18:11:49 +0800</lastBuildDate><atom:link href="https://echudet.github.io/categories/comp/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>oscomp2025 experience</title>
        <link>https://echudet.github.io/p/oscomp2025-experience/</link>
        <pubDate>Wed, 03 Sep 2025 00:00:00 +0000</pubDate>
        
        <guid>https://echudet.github.io/p/oscomp2025-experience/</guid>
        <description>&lt;img src="https://echudet.github.io/p/oscomp2025-experience/bg.jpg" alt="Featured image of post oscomp2025 experience" /&gt;&lt;blockquote&gt;
&lt;p&gt;OS火热招新 &lt;a class=&#34;link&#34; href=&#34;http://oslabs.hitsz.edu.cn/oscomp/oscomp.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://oslabs.hitsz.edu.cn/oscomp/oscomp.html&lt;/a&gt;

&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大二寒假前看到校内有操作系统比赛的招新通知，恰好有大段空闲时间，所以抱着前来积累经验的想法来参赛，同友人A和学长B组队参加。最终运气不错，取得了国一奖项。&lt;/p&gt;
&lt;h2 id=&#34;赛前积累&#34;&gt;赛前积累
&lt;/h2&gt;&lt;p&gt;在比赛报名之前，我们关于操作系统方面的经验如下：我做过mit6s081的xv6整个lab+南大的pa lab，学长B学完了大三的整个操作系统课程，并且有一定的科研经历，友人A则在这方面比较薄弱，但有学过算法课的知识。&lt;/p&gt;
&lt;p&gt;在比赛前的寒假期间，确定好比赛初期的时间安排以及内核编写语言之后，我们组团开始rust语言的学习，计划时长为3周。关于rust方面的学习，主要是通过以下几个渠道。&lt;/p&gt;
&lt;p&gt;首先是阅读Rust Course(&lt;a class=&#34;link&#34; href=&#34;https://course.rs/about-book.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://course.rs/about-book.html&lt;/a&gt;

)，学习其中的&lt;strong&gt;Rust 语言基础学习&lt;/strong&gt;和&lt;strong&gt;Rust 语言进阶学习&lt;/strong&gt;两个大章，掌握rust语言的基本和进阶内容。不过实际上在比赛中用到的进阶内容不是很多，可以粗略学习，之后有需要再回顾。&lt;/p&gt;
&lt;p&gt;其次是在Rust Practice(&lt;a class=&#34;link&#34; href=&#34;https://practice-zh.course.rs/why-exercise.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://practice-zh.course.rs/why-exercise.html&lt;/a&gt;

)里面进行简单的练习，做其中的习题，加深印象。&lt;/p&gt;
&lt;p&gt;最后是在CodeCrafters(&lt;a class=&#34;link&#34; href=&#34;https://app.codecrafters.io/catalog&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://app.codecrafters.io/catalog&lt;/a&gt;

)里面写一些简单的项目熟悉rust。我选了shell和interpreter两个当时免费的项目来练习，写了shell和部分的interpreter。这里面的项目分成多个块组成，并且内有自动判错，和xv6的lab类似，可以及时发现我们代码中隐含的错误。&lt;/p&gt;
&lt;p&gt;完成对rust的学习之后，在寒假的剩余时间里面，我们开始对rcore内核(&lt;a class=&#34;link&#34; href=&#34;https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter0/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter0/index.html&lt;/a&gt;

)的学习。&lt;/p&gt;
&lt;p&gt;这一阶段比较简单，主要是跟着rCore-Tutorial-Book手册学习。有os方面的基础不是很难，主要是掌握rust语言的os的构建模式。并且很多参赛的内核都是以rcore为基础来搭建的，掌握这个框架方便我们参考更多的rust内核。同时，也为友人A提供了内核学习的机会，能够打牢基础。&lt;/p&gt;
&lt;p&gt;新年之前学习手册的0~4章，包括环境配置、批处理系统、分时任务、地址空间四章，新年之后学习手册的5~8章，包括进程、文件系统、进程通信、并发四章，最后剩余的第九章则是留于之后写驱动的同学来看。&lt;/p&gt;
&lt;p&gt;完成每章的学习指看完各章的内容，并选择性完成章末的实验要求。在阅读各章内容的时候，要主动结合内核里面相应的代码来看，而不仅干看文档内容，这样难以深入了解内核的结构。&lt;/p&gt;
&lt;p&gt;完成上述的内容后，寒假应该仅剩余一两周的时间了，最后的这段时间就是阅读往届的优秀内核，总结经验。&lt;/p&gt;
&lt;p&gt;我们阅读了MankorOS, TitanixOS, MinotaurOS, PhoenixOS的代码及文档，并在返校之后开会讨论，对内核的整体架构有了一定的设想，这为我们之后构建内核的工作打下了坚实的基础。同时，我们也简单阅读了一些linux的资料，对于内核设计有了更深的见解。&lt;/p&gt;
&lt;h2 id=&#34;比赛过程&#34;&gt;比赛过程
&lt;/h2&gt;&lt;p&gt;我们在开学几周后才开始正式构建内核，而同实验室的第一组早已起步，这导致我们的进度在初期就已落后。加上初赛结束时恰逢期末考试月，这为我们初赛的失利埋下了伏笔&amp;hellip;&lt;/p&gt;
&lt;p&gt;这里有一个教训：构建内核越早越好，千万不要完全依赖比赛的官方时间安排。&lt;/p&gt;
&lt;p&gt;我们的内核是从零开始构建的，架构上主要参考了 PhoenixOS，同时借鉴其他内核作为优化点。在花费几天时间搭建好内核雏形后，我们召开了一个简短的会议，对内核开发进行了分工。我将工作划分为进程管理、内存、Trap 转换、文件系统、信号、驱动、网络及双架构适配等模块，并在此基础上制定了前、中、后三个开发阶段。在初期，我们需要实现进程管理、内存和 Trap 转换，这三个基本模块保障了内核能完成程序的内存映射及内核态与用户态的切换，同时也支持了多进程实现。完成这一阶段，内核便能以嵌入形式运行基本的用户程序。&lt;/p&gt;
&lt;p&gt;进入中期后，目标是实现文件系统和信号。文件系统是内核的重要组成部分，也是基础测例的重点，近半数测例与之相关；而信号部分则保证了父进程能正常控制子进程。实现了这两部分，内核就能进一步运行如 busybox 等复杂程序，并支持将测例程序打包到文件系统中进行测试。开发的后期主要是对内容进行扩充，包括实现优雅的驱动树管理、支持网络及相关系统调用，并实现 RISC-V 和 LoongArch 双架构支持。这一阶段完成后，工作重点便是对内核功能的进一步完善。&lt;/p&gt;
&lt;p&gt;在实际执行的最初两周，我们集中精力实现第一阶段的三个基本功能。我负责进程管理调度，友人 A 负责 Trap 上下文切换，学长 B 负责最复杂的内存部分。这一阶段相对简单，我们在计划时间内完成，并将部分 Basic 测例以嵌入内核的方式成功运行。&lt;/p&gt;
&lt;p&gt;下一阶段是文件系统与进程间通信。文件系统方面较为繁杂，主要涉及构建内核的虚拟文件系统以及对接外部库的具体文件系统，由我和学长 B 共同完成。我负责搭建大体架构，学长 B 在此基础上进行优化创新；友人 A 则负责编写信号等进程间通信机制。此外，还要将测试用例装入内核的磁盘文件中进行加载执行。这一阶段原计划两周，但工作比想象中更繁琐，最终花费三周才完成。不过在完成这一阶段后，busybox 测例集得以成功通过。&lt;/p&gt;
&lt;p&gt;第三阶段涉及驱动、网络、双架构以及跑通更多测例。这一部分超出计划时间最多，不仅因为功能繁杂，更因为需要支持的系统调用更多。双架构方面文档量大，由学长 B 和友人 A 共同查阅编写，我仅作简单了解；我主要负责驱动和网络部分，网络参考了 ArceOS 和 PhoenixOS，驱动则参考 MankorOS。在跑测例方面，我负责运行测试，遇到错误能解决则直接解决，不能解决则通知特定模块负责人或合作 Debug。这一阶段一直持续到六月初，即期末月。&lt;/p&gt;
&lt;p&gt;在期末月期间，我们忙于复习，没有再推进开发。此时除了 LTP 和 iperf，其他测例集基本完成，仅存少量 Bug 在修。考完试后，我们忽然发现其他队伍通过跑 LTP 拉开了巨大的分差（至少是其他测例总分的一倍），但鉴于我们需要准备初赛的文档、PPT 和视频，便没有再修补 LTP，这导致我们初赛落后于其他队伍，不过我们仍是“没跑 LTP 的队伍”中的第一名，最终初赛综合排名第九。&lt;/p&gt;
&lt;p&gt;进入决赛阶段，我们痛定思痛，先用 Linux 系统跑了一遍 LTP 测例集，统计其中的高分测例并制成表格，决定集中突破。&lt;/p&gt;
&lt;p&gt;决赛分工相对简单：我负责内核的驱动、网络及上板调试，框架在初赛已基本完成，主要是完善；同时我和学长 B 并行跑 LTP，他集中攻克 fanotify 等方面的高分测例及内核优化，我负责一些高分的杂项测例，友人 A 负责交叉编译 Vim、GCC 等程序到内核上（幸运地押中了题目），并在完成后整理更多信号机制的 LTP 测例。最终，我们成功将内核移植到 RISC-V 星光板和 LoongArch 星云板（虽仍有少量 Bug），通过了大量 LTP 测例，取得了决赛线上与线下的高分。&lt;/p&gt;
&lt;p&gt;通过现场赛后，在答辩前夜的模拟答辩中，老师对我们进行了点评。我和学长 B 讨论后，决定完全推翻原 PPT 重构大部分内容。接下来由学长 B 主导 PPT 制作，一直忙到凌晨 4 点，我则在 3 点休息以养精蓄锐。第二天早晨八点半，作为第三组出场的我们，在答辩开始前仅来得及过一遍 PPT，时间非常紧迫。好在运气不错，我们掐点完成了答辩。虽然过程未臻完美，但也取得了不错的成绩，给比赛画上了一个圆满的句号。&lt;/p&gt;
&lt;p&gt;整个比赛过程相当漫长，从寒假持续到暑假，历时半年，工作量也不小。就我个人而言，几乎把大部分课外时间都花在了写内核和 Debug 上，很少参加其他活动。因此如果想参加，就要做好忙碌的准备。最终，我们的内核 Rust 代码行数超过 40k（不含外部库和注释），累计约 1000 次 Commit 记录，并留下了充实的内核文档。&lt;/p&gt;
&lt;h2 id=&#34;内核组成&#34;&gt;内核组成
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/RustFlyer/OS/blob/main/NighthawkOS%E5%86%B3%E8%B5%9B%E6%96%87%E6%A1%A3.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;具体的内核文档见此&lt;/a&gt;

&lt;/p&gt;
&lt;h2 id=&#34;调试经验&#34;&gt;调试经验
&lt;/h2&gt;&lt;p&gt;一般使用二分法进行调试，通过log输出大量的内容来确定上下文，一方面能够知晓发生bug的位置，另一方面能够获取其上下文的参数信息，方便调bug。如果log输出过多时，可以设置动态开关log，和过滤部分log的内容，从而筛选出关键信息。&lt;/p&gt;
&lt;p&gt;如果bug发生在库的深处，或是用户态，或是地址读写卡死崩溃问题，则考虑使用gdb进行跟踪调试，先通过log确定bug大致位置，在附近打断点，然后步进跟踪各个寄存器，或特权寄存器，或相关地址的值等，来确定bug发生的原因。不过对板子就不行了，因为板子上面没有gdb，就只能用二分法调bug了。（关于gdb，听说gdb-dashboard挺好用的，可以尝试使用）&lt;/p&gt;
&lt;p&gt;除此外，调试用户态的程序还可以使用qemu-riscv64或qemu-loongarch64(这个需要额外配置)，通过输出它们系统调用的日志，来对比自己的内核和标准的内核之间的差异，从而找出bug。&lt;/p&gt;
&lt;p&gt;另外，我觉得操作系统里面比较难调的bug是内存bug和多线程bug，内存方面需要提前做好内存权限的管理，明确各个地址段的功能，这样更好追踪bug的产生。多线程则是需要为各个task建立健全的debug机制，可以在任意时间log出task的相关内容，调度时间信息等，看清楚了执行流，调bug就简单了（但也不是那么简单）。&lt;/p&gt;
&lt;h2 id=&#34;遗憾&#34;&gt;遗憾
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;多核仍有死锁情况，并发支持不完善。&lt;/li&gt;
&lt;li&gt;git本地支持正常，说明文件系统比较完善。但是git clone缺乏https，这可能是交叉编译缺失，或是文件系统还有缺陷，或是网络方面有bug，现场赛时间过短未能调出来。&lt;/li&gt;
&lt;li&gt;文件系统的挂载功能不完善，需要实现挂载队列，但这会导致预估3k+的代码重构，这个功能应该在构建内核的时候一起实现，在内核比较完善之后去改容易造成大规模的影响，积重难返。&lt;/li&gt;
&lt;li&gt;龙芯qemu的中断驱动仍存在问题，不能正常响应。并且龙芯板子上面存在奇怪的内存问题，当内核以release编译的时候会产生巨量的bug，而以debug模式编译则是少量bug，debug模式产生的未对齐处理多于release方面，怀疑是此方面问题，但是具体原因未知，未能debug出来。&lt;/li&gt;
&lt;li&gt;内核中枢多时间系统todo，但是没时间写。&lt;/li&gt;
&lt;li&gt;more ltp&amp;hellip;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;反思&#34;&gt;反思
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;内核构建需要尽早开始，最后要留出一个月的时间给ltp，因为ltp拉分最甚。&lt;/li&gt;
&lt;li&gt;内存、arch、lock、log等模块尽量解耦合，放在外部，其他模块都需要依赖它们。&lt;/li&gt;
&lt;li&gt;尽早完善调试架构，完善log机制，多进程记录机制，方便之后的调试。&lt;/li&gt;
&lt;li&gt;文件系统的各个接口都需要留出扩展接口，用于未来更多的功能扩展。&lt;/li&gt;
&lt;li&gt;注重实现更多的功能，在保证实现充足的功能的基础上考虑创新点（实际上很多创新点都是说出来的，内核本身实现就包含着很多特点，选取一些包装一下就是创新点了）。&lt;/li&gt;
&lt;li&gt;在明确一个函数的内部逻辑，输入输出的时候可以用AI代写，省时省力，但不要让AI写你不理解的内容，这会导致石山代码。&lt;/li&gt;
&lt;li&gt;明确队伍的git commit规范和注释规范，合适的开发规范能够让维护成本降低。&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
    </channel>
</rss>
