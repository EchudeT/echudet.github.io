<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Comp on echudet</title>
        <link>https://echudet.github.io/categories/comp/</link>
        <description>Recent content in Comp on echudet</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>echudet</copyright>
        <lastBuildDate>Mon, 08 Sep 2025 18:16:29 +0800</lastBuildDate><atom:link href="https://echudet.github.io/categories/comp/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>oscomp2025 experience</title>
        <link>https://echudet.github.io/p/oscomp2025-experience/</link>
        <pubDate>Wed, 03 Sep 2025 00:00:00 +0000</pubDate>
        
        <guid>https://echudet.github.io/p/oscomp2025-experience/</guid>
        <description>&lt;img src="https://echudet.github.io/p/oscomp2025-experience/bg.jpg" alt="Featured image of post oscomp2025 experience" /&gt;&lt;blockquote&gt;
&lt;p&gt;OS火热招新 &lt;a class=&#34;link&#34; href=&#34;http://oslabs.hitsz.edu.cn/oscomp/oscomp.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://oslabs.hitsz.edu.cn/oscomp/oscomp.html&lt;/a&gt;

&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;大二寒假前看到校内有操作系统比赛的招新通知，又恰逢大段空闲时间，于是便抱着前来积累经验的想法，拉着友人A，与主动加入我们的学长B组起了一个队伍，由我带队来参加操作系统比赛。最终凭借着运气+努力，取得了国一，可喜可贺。&lt;/p&gt;
&lt;h2 id=&#34;赛前积累&#34;&gt;赛前积累
&lt;/h2&gt;&lt;p&gt;在比赛报名之前，我个人在操作系统方面的知识积累是mit6s081的xv6整个lab+南大的pa lab，学长B是学完了大三的整个操作系统课程，友人A则是还没有这方面的知识。&lt;/p&gt;
&lt;p&gt;在比赛之前，寒假期间，确定好比赛初期的时间安排，以及内核编写语言之后，我们开始组团进行rust语言的学习，时长为3周。关于rust方面的学习，主要是依赖以下几个内容。&lt;/p&gt;
&lt;p&gt;首先是阅读Rust Course(&lt;a class=&#34;link&#34; href=&#34;https://course.rs/about-book.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://course.rs/about-book.html&lt;/a&gt;

)，学习其中的&lt;strong&gt;Rust 语言基础学习&lt;/strong&gt;和&lt;strong&gt;Rust 语言进阶学习&lt;/strong&gt;两个大章，掌握rust语言的基本和进阶内容。&lt;/p&gt;
&lt;p&gt;其次是在Rust Practice(&lt;a class=&#34;link&#34; href=&#34;https://practice-zh.course.rs/why-exercise.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://practice-zh.course.rs/why-exercise.html&lt;/a&gt;

)里面进行简单的练习，做其中的习题，加深印象。&lt;/p&gt;
&lt;p&gt;最后是在CodeCrafters(&lt;a class=&#34;link&#34; href=&#34;https://app.codecrafters.io/catalog&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://app.codecrafters.io/catalog&lt;/a&gt;

)里面写一些简单的项目熟悉rust。我是选了shell和interpreter两个当时免费的项目来练习，写了shell和部分interpreter。这里面的项目分成多个块组成，并且内有自动判错，可以及时发现我们代码中隐含的错误，能让我们更熟练地用rust写项目。&lt;/p&gt;
&lt;p&gt;完成对rust的学习之后，在寒假的剩余时间里面，我们开始对rcore内核(&lt;a class=&#34;link&#34; href=&#34;https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter0/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter0/index.html&lt;/a&gt;

)的学习。&lt;/p&gt;
&lt;p&gt;这一阶段比较简单，主要是跟着rCore-Tutorial-Book手册学习。&lt;/p&gt;
&lt;p&gt;新年之前学习手册的0~4章，包括环境配置、批处理系统、分时任务、地址空间四章，新年之后学习手册的5~8章，包括进程、文件系统、进程通信、并发四章，最后剩余的第九章则是留于之后写驱动的同学来看。&lt;/p&gt;
&lt;p&gt;完成每章的学习指看完各章的内容+完成章末的实验要求（貌似5~8某章实验有一个bug），在阅读各章内容的时候，要主动结合内核里面相应的代码来看，不能干看文档内容，这样难以深入理解。&lt;/p&gt;
&lt;p&gt;完成上述的内容后，寒假应该仅剩余一两周的时间了，最后的这段时间就是阅读我校往届的优秀内核，总结经验。&lt;/p&gt;
&lt;p&gt;我们阅读了MankorOS, TitanixOS, MinotaurOS, PhoenixOS的内容，然后在返校之后聚团讨论了一番，对内核的整体架构有了一定的设想，这为我们之后构建内核的工作打下了坚实的基础。同时，我们也简单阅读了一些linux的资料，对于内核设计有了更深的见解。&lt;/p&gt;
&lt;h2 id=&#34;比赛过程&#34;&gt;比赛过程
&lt;/h2&gt;&lt;p&gt;我们在开学的几周后才开始正式构建内核，而同实验室的第一组则是早早开始了构建内核，这导致了我们的进度落后，再加上初赛结束在期末月，为我们初赛的落后埋下了伏笔&amp;hellip;.&lt;/p&gt;
&lt;p&gt;我们的内核是从零开始构建的，主要参考的是PhoenixOS的架构，以其他内核作为优化点和来部分借鉴。花了几天时间构造内核的雏形之后，我们开了一个简单的会议划分了内核的分工。&lt;/p&gt;
&lt;p&gt;我将内核的工作划分为进程管理，内存，trap转换，文件系统，信号，驱动，网络，双架构。&lt;/p&gt;
&lt;p&gt;在最初的两周，我们需要实现进程管理，内存，trap转换这三个基本的功能，我负责进程，学长B负责内存，友人A负责trap。这一阶段比较简单，我们在计划时间内完美完成了这一阶段的内容，并尝试将basic测例的内容以嵌入内核的方式来运行。&lt;/p&gt;
&lt;p&gt;下一个阶段是文件系统，信号。文件系统方面比较繁杂，由我和学长B一起写，我主要写了文件系统的大体架构，学长B在这基础上进行优化和创新，之后我则侧重于扩展文件系统于OS侧的更多详细的功能。友人A则是在写信号方面的机制。这一阶段原本的计划时间也是两周，但是工作比想象中更繁杂，最后是花了三周的时间才完成，完成这一阶段之后，busybox测例集成功通过。&lt;/p&gt;
&lt;p&gt;第三阶段是驱动，网络，双架构+过更多的测例集。双架构方面文档比较多，需要阅读大量的文档，于是由学长B和友人A来一起写，我则是简单地了解loongArch方面的内容，对内核架构有大体的掌握。另一边，驱动和网络则是由我来写，网络方面参考ArceOS+PhoenixOS的实现，驱动方面则参考了MankorOS来写。而比赛测例集方面，则是由我来跑测例，如果遇到错误，我能解决就由我来解决，不能解决则是通知特定模块的负责人员来解决，或是合作debug。这一阶段一直持续到6月初，即期末月，也是初赛结束月。&lt;/p&gt;
&lt;p&gt;在期末月的时候，我们在复习期末的内容，没有再推进工作，在这之前我们基本完成了除了ltp和iperf以外的其他测例集，还存在少量的bug在修。完成期末考之后，忽然发现其他队伍跑ltp大大拉分，至少拉开了其他测例的总和分一倍，但鉴于我们要准备文档，ppt，视频，我们就没再修ltp，这导致了我们初赛落后于其他队伍。&lt;del&gt;（我们是没跑ltp队伍的第一名）&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;最后初赛综合排名第九。&lt;/p&gt;
&lt;p&gt;然后是决赛阶段，我们痛定思痛，将ltp测例集用linux系统跑了一遍，统计其中的高分测例并制定成一个表格，决定集中突破里面的高分测例。&lt;/p&gt;
&lt;p&gt;决赛分工比较简单，我来搞内核的驱动、网络、上板，完善内核以通过更多的测例。学长B是集中突破ltp的fanotify等方面的高分测例，以及完善内核和文件系统的各个方面，友人A则是掌握交叉编译的知识，交叉编译了vim、gcc这两程序在内核上面跑（运气撞题）。最后我们成功上了riscv的星光板和loongArch的星云板(仍有点bug)，并且通过了大量的ltp测例，取得了决赛线上测例的高分和线下决赛的高分。&lt;/p&gt;
&lt;p&gt;最后的最后，在答辩之前的一个夜晚，我们内核赛四组在线上分别模拟答辩，由老师进行评价。在老师评价完我们的ppt之后，学长B和我一番讨论，决定完全推翻原来的ppt，重构大部分内容。接下来由学长B操刀ppt，一直忙到了凌晨4点，我则是3点上床养精蓄锐，准备同一天的八点半开始的答辩。我们的答辩是第3组，在答辩之前我简单过了一遍ppt就到时间上场，准备十分紧迫。但最终运气不错，算是流畅地完成了答辩，不过想来也是非常惊险的一个过程，日后应该早早做好准备，切忌临时发挥，临阵磨枪还是欠缺很多内容。&lt;/p&gt;
&lt;p&gt;比赛过程还是挺长的，从寒假到暑假，基本是半年的比赛流程，并且工作量也不少，除去校内课程的学习，就我个人，基本把剩余的课外时间都花在这上面，少有时间搞其他的活动。若要参加要做好忙起来的准备。&lt;/p&gt;
&lt;h2 id=&#34;内核组成&#34;&gt;内核组成
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/RustFlyer/OS/blob/main/NighthawkOS%E5%86%B3%E8%B5%9B%E6%96%87%E6%A1%A3.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;具体的内核文档见此&lt;/a&gt;

&lt;/p&gt;
&lt;h2 id=&#34;调试经验&#34;&gt;调试经验
&lt;/h2&gt;&lt;p&gt;一般使用二分法进行调试，通过log输出大量的内容来确定上下文，一方面能够知晓发生bug的位置，另一方面能够获取其上下文的参数信息，方便调bug。如果log输出过多时，可以设置动态开关log，和过滤部分log的内容，从而筛选出关键信息。&lt;/p&gt;
&lt;p&gt;如果bug发生在库的深处，或是用户态，或是地址读写卡死崩溃问题，则考虑使用gdb进行跟踪调试，先通过log确定bug大致位置，在附近打断点，然后步进跟踪各个寄存器，或特权寄存器，或相关地址的值等，来确定bug发生的原因。不过对板子就不行了，因为板子上面没有gdb，就只能用二分法调bug了。（关于gdb，听说gdb-dashboard挺好用的，可以尝试使用）&lt;/p&gt;
&lt;p&gt;除此外，调试用户态的程序还可以使用qemu-riscv64或qemu-loongarch64(这个需要额外配置)，通过输出它们系统调用的日志，来对比自己的内核和标准的内核之间的差异，从而找出bug。&lt;/p&gt;
&lt;p&gt;另外，我个人觉得操作系统里面比较难调的bug是内存bug和多线程bug，内存方面需要提前做好内存权限的管理，明确各个地址段的功能，这样更好追踪bug的产生。多线程则是需要为各个task建立健全的debug机制，可以在任意时间log出task的相关内容，调度时间信息等，看清楚了执行流，调bug就简单了（但也不是那么简单）。&lt;/p&gt;
&lt;h2 id=&#34;遗憾&#34;&gt;遗憾
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;多核仍有死锁情况，并发支持不完善。&lt;/li&gt;
&lt;li&gt;git本地支持正常，说明文件系统比较完善。但是git clone缺乏https，这可能是交叉编译缺失，或是文件系统还有缺陷，或是网络方面有bug，现场赛时间过短未能调出来。&lt;/li&gt;
&lt;li&gt;文件系统的挂载功能不完善，需要实现挂载队列，但这会导致预估3k+的代码重构，这个功能应该在构建内核的时候一起实现，在内核比较完善之后去改容易造成大规模的影响，积重难返。&lt;/li&gt;
&lt;li&gt;龙芯qemu的中断驱动仍存在问题，不能正常响应。并且龙芯板子上面存在奇怪的内存问题，当内核以release编译的时候会产生巨量的bug，而以debug模式编译则是少量bug，debug模式产生的未对齐处理多于release方面，怀疑是此方面问题，但是具体原因未知，未能debug出来。&lt;/li&gt;
&lt;li&gt;内核中枢多时间系统todo，但是没时间写。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;反思&#34;&gt;反思
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;内核构建需要尽早开始，最后要留出一个月的时间给ltp，因为ltp拉分最甚。&lt;/li&gt;
&lt;li&gt;内存、arch、lock、log等模块尽量解耦合，放在外部，其他模块都需要依赖它们。&lt;/li&gt;
&lt;li&gt;尽早完善调试架构，完善log机制，多进程记录机制，方便之后的调试。&lt;/li&gt;
&lt;li&gt;文件系统的各个接口都需要留出扩展接口，用于未来更多的功能扩展。&lt;/li&gt;
&lt;li&gt;注重实现更多的功能，在保证实现充足的功能的基础上考虑创新点（实际上很多创新点都是说出来的，内核本身实现就包含着很多特点，选取一些包装一下就是创新点了）。&lt;/li&gt;
&lt;li&gt;在明确一个函数的内部逻辑，输入输出的时候可以用AI代写，省时省力，但不要让AI写你不理解的内容，这会导致石山代码。&lt;/li&gt;
&lt;li&gt;明确队伍的git commit规范和注释规范，合适的开发规范能够让维护成本降低。&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
    </channel>
</rss>
