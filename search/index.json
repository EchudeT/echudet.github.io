[{"content":"","date":"2024-11-10T22:02:57+08:00","permalink":"https://echudet.github.io/p/mit6s081lec22/","title":"Mit6s081Lec22"},{"content":"","date":"2024-11-10T22:02:57+08:00","permalink":"https://echudet.github.io/p/mit6s081lec23/","title":"Mit6s081Lec23"},{"content":"","date":"2024-11-10T22:02:56+08:00","permalink":"https://echudet.github.io/p/mit6s081lec20/","title":"Mit6s081Lec20"},{"content":"","date":"2024-11-10T22:02:56+08:00","permalink":"https://echudet.github.io/p/mit6s081lec21/","title":"Mit6s081Lec21"},{"content":"","date":"2024-11-10T22:02:55+08:00","permalink":"https://echudet.github.io/p/mit6s081lec17/","title":"Mit6s081Lec17"},{"content":"","date":"2024-11-10T22:02:55+08:00","permalink":"https://echudet.github.io/p/mit6s081lec18/","title":"Mit6s081Lec18"},{"content":"","date":"2024-11-10T22:02:55+08:00","permalink":"https://echudet.github.io/p/mit6s081lec19/","title":"Mit6s081Lec19"},{"content":"","date":"2024-11-10T22:02:54+08:00","permalink":"https://echudet.github.io/p/mit6s081lec15/","title":"Mit6s081Lec15"},{"content":"","date":"2024-11-10T22:02:54+08:00","permalink":"https://echudet.github.io/p/mit6s081lec16/","title":"Mit6s081Lec16"},{"content":"","date":"2024-11-10T22:02:53+08:00","permalink":"https://echudet.github.io/p/mit6s081lec13/","title":"Mit6s081Lec13"},{"content":"","date":"2024-11-10T22:02:53+08:00","permalink":"https://echudet.github.io/p/mit6s081lec14/","title":"Mit6s081Lec14"},{"content":"","date":"2024-11-10T22:02:52+08:00","permalink":"https://echudet.github.io/p/mit6s081lec10/","title":"Mit6s081Lec10"},{"content":"","date":"2024-11-10T22:02:52+08:00","permalink":"https://echudet.github.io/p/mit6s081lec11/","title":"Mit6s081Lec11"},{"content":"","date":"2024-11-10T22:02:52+08:00","permalink":"https://echudet.github.io/p/mit6s081lec9/","title":"Mit6s081Lec9"},{"content":"","date":"2024-11-10T22:02:51+08:00","permalink":"https://echudet.github.io/p/mit6s081lec6/","title":"Mit6s081Lec6"},{"content":"","date":"2024-11-10T22:02:51+08:00","permalink":"https://echudet.github.io/p/mit6s081lec8/","title":"Mit6s081Lec8"},{"content":"Lecture 3 OS Organization \u0026amp; System Calls OS 隔离性、防御性\n为了不变成一个恶意程序，Shell在发现自己运行了一段时间之后，需要让别的程序也有机会能运行。这种机制有时候称为协同调度（Cooperative Scheduling）。 这个特性是非常有用的，不论应用程序在执行什么操作，multiplexing都会迫使应用程序时不时的释放CPU，这样其他的应用程序才能运行。 使用操作系统的一个原因，甚至可以说是主要原因就是为了实现multiplexing和内存隔离。如果你不使用操作系统，并且应用程序直接与硬件交互，就很难实现这两点。所以，将操作系统设计成一个库，并不是一种常见的设计。你或许可以在一些实时操作系统中看到这样的设计，因为在这些实时操作系统中，应用程序之间彼此相互信任。但是在大部分的其他操作系统中，都会强制实现硬件资源的隔离。 需要通过硬件来实现这的强隔离性。这里的硬件支持包括了两部分，第一部分是user/kernel mode，kernel mode在RISC-V中被称为Supervisor mode但是其实是同一个东西；第二部分是page table或者虚拟内存（Virtual Memory）。 处理器会有两种操作模式，第一种是user mode，第二种是kernel mode。当运行在kernel mode时，CPU可以运行特定权限的指令（privileged instructions）；当运行在user mode时，CPU只能运行普通权限的指令（unprivileged instructions）。 实际上RISC-V还有第三种模式称为machine mode。在大多数场景下，我们会忽略这种模式，所以我也不太会介绍这种模式。 在处理器的一个bit，当它为1的时候是user mode，当它为0时是kernel mode。当处理器在解析指令时，如果指令是特殊权限指令，并且该bit被设置为1，处理器会拒绝执行这条指令，就像在运算时不能除以0一样。 让整个操作系统代码都运行在kernel mode。大多数的Unix操作系统实现都运行在kernel mode。比如，XV6中，所有的操作系统服务都在kernel mode中，这种形式被称为Monolithic Kernel Design（宏内核）。 另一种设计主要关注点是减少内核中的代码，它被称为Micro Kernel Design（微内核）。在这种模式下，希望在kernel mode中运行尽可能少的代码。所以这种设计下还是有内核，但是内核只有非常少的几个模块，例如，内核通常会有一些IPC的实现或者是Message passing；非常少的虚拟内存的支持，可能只支持了page table；以及分时复用CPU的一些支持。微内核的目的在于将大部分的操作系统运行在内核之外。因为在内核中的代码的数量较小，更少的代码意味着更少的Bug。 在实际中，两种内核设计都会出现，出于历史原因大部分的桌面操作系统是宏内核，如果你运行需要大量内核计算的应用程序，例如在数据中心服务器上的操作系统，通常也是使用的宏内核，主要的原因是Linux提供了很好的性能。但是很多嵌入式系统，例如Minix，Cell，这些都是微内核设计。这两种设计都很流行，如果你从头开始写一个操作系统，你可能会从一个微内核设计开始。 System Calls\n有一种方式能够让应用程序可以将控制权转移给内核（Entering Kernel）。在RISC-V中，有一个专门的指令用来实现这个功能，叫做ECALL。ECALL接收一个数字参数，当一个用户程序想要将程序执行的控制权转移到内核，它只需要执行ECALL指令，并传入一个数字。这里的数字参数代表了应用程序想要调用的System Call。\n不论是Shell还是其他的应用程序，当它在用户空间执行fork时，它并不是直接调用操作系统中对应的函数，而是调用ECALL指令，并将fork对应的数字作为参数传给ECALL。之后再通过ECALL跳转到内核。\n左边是用户空间，右边是内核空间。在内核侧，有一个位于syscall.c的函数syscall，每一个从应用程序发起的系统调用都会调用到这个syscall函数，syscall函数会检查ECALL的参数，通过这个参数内核可以知道需要调用的是fork\n内核有时候也被称为可被信任的计算空间（Trusted Computing Base），在一些安全的术语中也被称为TCB。\n在这段代码中，p-\u0026gt;trapframe 和 p-\u0026gt;trapframe-\u0026gt;a0 是与系统调用处理相关的两个重要部分。为了理解它们的意义，我们需要明确 trapframe 是什么，以及 a0 在其中的作用。\np-\u0026gt;trapframe 的意义 trapframe 结构：trapframe 是一个结构体，它保存了当进程从用户态切换到内核态时，CPU 寄存器的状态。这通常发生在进程进行系统调用、发生中断或异常时。操作系统会在内核栈中创建一个 trapframe，用于保存当前的 CPU 状态（包括通用寄存器、指令指针、栈指针等）。 p-\u0026gt;trapframe：这里的 p 是指向进程控制块（struct proc）的指针，而 p-\u0026gt;trapframe 则是该进程的 trapframe。当进程进入内核态时，操作系统会使用 p-\u0026gt;trapframe 来保存进程的 CPU 寄存器状态。 p-\u0026gt;trapframe-\u0026gt;a0 的意义 a0：在 trapframe 结构体中，a0 是保存系统调用返回值的寄存器。通常在 xv6 操作系统中，a0 是一个寄存器，用于保存从系统调用返回时的结果。每个系统调用执行完后，返回的结果会存放在 trapframe-\u0026gt;a0 中，然后在从内核返回用户态时，这个值会被传递给用户进程。 p-\u0026gt;trapframe-\u0026gt;a0 = syscall[num]()：这行代码表示执行一个系统调用，并将系统调用的返回值保存到 p-\u0026gt;trapframe-\u0026gt;a0 中。syscall[num]() 是一个函数指针数组，num 是系统调用号，根据这个号找到对应的系统调用函数并执行。执行后的返回值被存入 a0 中，稍后当进程返回用户态时，这个值将被返回给进程的用户代码。 总结 p-\u0026gt;trapframe：保存了当前进程的 CPU 寄存器状态，当进程从用户态进入内核态时使用。 p-\u0026gt;trapframe-\u0026gt;a0：用于保存系统调用的返回值，这个值会在系统调用执行完毕后传递回用户态的进程。 这种机制保证了用户进程在进行系统调用时能够正确地与内核交互，并获取系统调用的结果。\np-\u0026gt;context 和 p-\u0026gt;trapframe 是两种不同的数据结构，它们分别用于保存不同阶段的进程状态，具有不同的用途和作用。不过，它们也有相似之处，都是为了实现进程的正确执行和状态保存。\np-\u0026gt;context 与 p-\u0026gt;trapframe 的不同之处 用途和作用不同: p-\u0026gt;context： 作用：p-\u0026gt;context 主要用于保存进程在 内核态 的上下文（即寄存器状态），特别是当进程在内核态运行且发生上下文切换时（例如调度器将进程挂起以运行另一个进程）。它保存的是内核态寄存器的状态，包括程序计数器（eip）、栈指针（esp）等。这个上下文会在进程被重新调度运行时恢复，以确保进程从上次被挂起的地方继续执行。 使用场景：p-\u0026gt;context 的保存与恢复主要发生在进程的上下文切换过程中，即当操作系统在多个进程之间切换时。p-\u0026gt;context 保存的是内核态的运行状态，而不是用户态的状态。 p-\u0026gt;trapframe： 作用：p-\u0026gt;trapframe 则主要用于保存进程从 用户态 切换到 内核态 时的 CPU 寄存器状态。它保存的寄存器状态包括通用寄存器、程序计数器、栈指针、段寄存器等，基本上就是用户态的所有寄存器状态。这是为了当系统调用、中断或异常发生时，能够保存用户态的状态，然后在处理完毕后可以恢复并返回用户态继续执行。 使用场景：p-\u0026gt;trapframe 的保存与恢复发生在用户态和内核态之间的切换过程中。例如，当进程执行系统调用时，CPU 的寄存器状态会被保存到 trapframe，以便在系统调用完成后正确返回用户态。 保存内容不同： p-\u0026gt;context：保存的是内核态的寄存器状态，特别是与内核栈相关的状态信息，例如 eip（指向内核代码中的某个位置）、esp（指向内核栈中的某个位置）等。 p-\u0026gt;trapframe：保存的是用户态的寄存器状态以及一些与系统调用和中断相关的状态信息，例如用户态的 eip、esp 以及系统调用号、参数等。 使用的时机不同： p-\u0026gt;context：在进程调度时使用，当系统切换到其他进程时，当前进程的内核态上下文会被保存到 p-\u0026gt;context，并在下次调度回该进程时恢复。 p-\u0026gt;trapframe：在系统调用或中断发生时使用，当进程从用户态进入内核态时，trapframe 用于保存当前的用户态寄存器状态，以便在系统调用或中断处理完毕后能够正确地返回用户态。 p-\u0026gt;context 与 p-\u0026gt;trapframe 的相同之处 都是用来保存状态的： 无论是 p-\u0026gt;context 还是 p-\u0026gt;trapframe，它们的主要作用都是为了保存进程在某个时刻的 CPU 状态，以便在之后能够正确恢复进程的执行。 都与进程切换有关： 虽然 p-\u0026gt;context 和 p-\u0026gt;trapframe 用于不同的切换场景（进程上下文切换 vs 用户态和内核态切换），但它们都涉及到进程在不同执行阶段的切换。 总结 p-\u0026gt;context 保存的是进程在 内核态 下的上下文信息，主要用于进程的上下文切换（即调度器在不同进程之间切换时）。 p-\u0026gt;trapframe 保存的是进程在 用户态 和 内核态 切换时的状态信息，主要用于处理系统调用、中断或异常时的状态保存和恢复。 二者的作用和使用场景不同，但它们的共同目标都是为了确保进程的执行能够在不同的切换过程中被正确保存和恢复。\nxv6的组织结构\nxv6 使用了传统的内核概念 - 一个向其他运行中程序提供服务的特殊程序。每一个运行中程序（称之为进程）都拥有包含指令、数据、栈的内存空间。指令实现了程序的运算，数据是用于运算过程的变量，栈管理了程序的过程调用。 内核使用了 CPU 的硬件保护机制来保证用户进程只能访问自己的内存空间。内核拥有实现保护机制所需的硬件权限(hardware privileges)，而用户程序没有这些权限。当一个用户程序进行一次系统调用时，硬件会提升特权级并且开始执行一些内核中预定义的功能。 ","date":"2024-11-10T22:02:50+08:00","permalink":"https://echudet.github.io/p/mit6s081lec3/","title":"MIT6S081Lec3"},{"content":"Lecture 4 Page Tables(vm) vm -\u0026gt; virtual memory ，map virtual to physical 隔离性\n正确设置的VM可以实现隔离性\ndefault下，不存在memory isolation\naddress spaces，地址空间\n给包括内核所有程序专属空间，这些空间相互独立\n如何在物理内存上划分虚拟空间\n通过page table实现，kalloc储存余有空间的地址\n而page table 页表由处理器硬件或内存管理单元MMU实现，映射内存的VA-\u0026gt;PG表存储在MMU中，也有表存储在内存中用来找到MMU中的表（e.g. SATP寄存器）\nMMU是不定存储的，必要时读取表\n改写SATP寄存器是内核的权利，用户无法改写\npaging hw(risc-v)\nSATP-64bits,可存储2^64个地址，过大\n实际上，它仅为page创建地址，一个page为4kb,\nindex和offset，index指page序号（指向内存中的4kb），offset指page中具体的偏移\n实际上，高25bit并未使用（在RISC-V中)，中27位用于index，低12位用于offset(2^12 bits = 4 kb)，而物理内存可以比虚拟内存大，XV86为44位address + 12 offset，此处56为设计师设计的，并无具体含义\n虽然page table可存储2^27个条目，但它并非一次性存储在各个程序中，而是多级结构，先将27位划分为三个9bit，再指向不同的page directory（4096bytes），其中一个条目为8bytes，故其中含有512个PTE，VM的PT中最高级的9bit指向PD，得到一个物理page号，其指向中级PD，再得到一个PPN指向低级PD，再得到真正的物理地址\nPTE低十位一般用于标志位，\nRSW , Dirty, Accessed , Global, User, Execute, Write, Read, Valid\n9 \u0026mdash;-\u0026gt; 0\n当无法翻译的时候，会出现page fault\nsatp在此多级过程中，会提供最高级PD的地址，然后高位9bit会在PD中寻找相应的PPN\n这三个PD都存放于物理地址\n从PD得到的PPN（非目标物理地址）是44bit的，会在后面补上12个0，再指向下一个PD\n读一次地址要访问三次地址，代价较高，故有页表缓存（TLB），又称PTE缓存。TLB会存储VA-\u0026gt;PQ的映射\n当os切换page table时，会清空TLB缓存\n在RISC-V中，清空TLB指令为sfence_vma\n在RISC-V中，walk函数实现了与硬件MMU相同的功能\n三级页表一般是由硬件实现，而非操作系统\npage table 提供了一层抽象，这里的映射完全由操作系统控制，可实现多种功能，如page fault，os可以更新page table，并重新加载指令\nCPU每个核都有MMU和TLB\nxv6 vm code + layout\nkernelbase地址于0x800000时（kernel虚拟地址下的），产生的信息若地址低于它，则流向不同io设备，否则流向dram （当然可能也是unused，因为没那么多设备）\n总体物理地址的layout，是由主板决定的，并非仅是CPU决定\nGuardPage 不会映射，起保护Kernel Stack的作用，\nkernel stack 与 kernel data 映射于一处\n每一个用户进程都有一个kernel stack\n用户进程会占用kernel的虚拟内存的free memory，\n用户的虚拟内存和kernel的一样大，但用户的空间利用率低\nkernel中大部分虚拟内存和真实内存是一一对应的，因此在启动虚拟内存映射时不会对kernel 的运行造成影响\n每个进程都有用户栈和内核栈（p-\u0026gt;kstack）。当进程运行用户指令时，只有其用户栈被使用，其内核栈则是空的。然而当进程（通过系统调用或中断）进入内核时，内核代码就在进程的内核栈中执行；进程处于内核中时，其用户栈仍然保存着数据，只是暂时处于不活跃状态。进程的线程交替地使用着用户栈和内核栈。要注意内核栈是用户代码无法使用的，这样即使一个进程破坏了自己的用户栈，内核也能保持运行。\nxv6 使用结构体 struct proc 来维护一个进程的状态，其中最为重要的状态是进程的页表，内核栈，当前运行状态。我们接下来会用 p-\u0026gt;xxx 来指代 proc 结构中的元素。 当进程使用系统调用时，处理器转入内核栈中，提升硬件的特权级，然后运行系统调用对应的内核代码。当系统调用完成时，又从内核空间回到用户空间：降低硬件特权级，转入用户栈，恢复执行系统调用指令后面的那条用户指令。线程可以在内核中“阻塞”，等待 I/O, 在 I/O 结束后再恢复运行。 p-\u0026gt;state 指示了进程的状态：新建、准备运行、运行、等待 I/O 或退出状态中。 p-\u0026gt;pgdir 以 x86 硬件要求的格式保存了进程的页表。xv6 让分页硬件在进程运行时使用 p-\u0026gt;pgdir。进程的页表还记录了保存进程内存的物理页的地址。 当 PC 开机时，它会初始化自己然后从磁盘中载入 boot loader 到内存并运行。然后，boot loader 把 xv6 内核从磁盘中载入并从 entry（1040）开始运行。x86 的分页硬件在此时还没有开始工作；所以这时的虚拟地址是直接映射到物理地址上的。\nboot loader 把 xv6 内核装载到物理地址 0x100000 处。之所以没有装载到内核指令和内核数据应该出现的 0x80100000，是因为小型机器上很可能没有这么大的物理内存。而之所以在 0x100000 而不是 0x0 则是因为地址 0xa0000 到 0x100000 是属于 I/O 设备的。\n为了让内核的剩余部分能够运行，entry 的代码设置了页表，将 0x80000000（称为 KERNBASE（0207））开始的虚拟地址映射到物理地址 0x0 处。注意，页表经常会这样把两段不同的虚拟内存映射到相同的一段物理内存，我们将会看到更多类似的例子。\n“页表经常会这样把两段不同的虚拟内存映射到相同的一段物理内存”指的是以下两段虚拟内存：\n虚拟地址 0x0 到 0x400000：这段虚拟地址范围直接映射到物理地址 0x0 到 0x400000。在 entry 代码开始运行时，为了能够正常执行，这个映射是必要的，因为在系统启动时，虚拟地址和物理地址是直接对应的。 虚拟地址 KERNBASE 到 KERNBASE + 0x400000：这段虚拟地址范围对应的是高地址的内核空间，KERNBASE 通常为 0x80000000。为了让内核在其预期的高虚拟地址空间运行，entry 代码将这一段虚拟地址也映射到了物理地址 0x0 到 0x400000。 这两段虚拟地址虽然不同，但它们都映射到了同一段物理内存，即物理地址 0x0 到 0x400000。这样做的目的是为了在内核加载的早期阶段能够在物理内存较小的情况下让内核正常工作。随着系统的进一步初始化和内存管理机制的完善，低地址的映射会被移除，内核最终会运行在高地址的虚拟内存空间中。\n在xv6的启动过程中，分页硬件起到了至关重要的作用。简单来说，分页硬件负责将程序使用的虚拟地址翻译成实际的物理地址，这是实现虚拟内存管理的核心机制。\n分页硬件的作用 地址翻译：分页硬件的主要任务是将CPU在执行指令时产生的虚拟地址，按照页表的规定，转换为实际的物理地址。这使得每个进程可以拥有一个独立的虚拟地址空间，而不需要关心实际的物理内存布局。 内存保护：分页硬件可以通过页表中的权限位，控制对内存的访问权限。例如，它可以设置某些内存区域只读、不可执行，或者仅允许内核访问，从而提供内存保护机制，防止进程之间互相干扰。 支持进程隔离：分页硬件使得不同进程可以拥有各自的虚拟地址空间，这些空间彼此独立。即使多个进程使用相同的虚拟地址，它们在物理内存中映射到的实际地址也不同，从而实现了进程间的隔离。 分页硬件的启动 分页硬件的启动步骤如下：\n设置页表：在启动分页硬件之前，内核首先要设置好页表。页表是一种数据结构，它记录了虚拟地址到物理地址的映射关系。xv6在启动过程中会建立一个初始的页表，这个页表会映射内核代码和数据到合适的物理地址。 加载页表地址到控制寄存器 %cr3：内核通过将页表的物理地址加载到控制寄存器 %cr3 中，告诉CPU当前要使用哪一个页表来进行地址翻译。这个步骤是让分页硬件知道应该使用哪一张表来进行虚拟地址到物理地址的转换。 启用分页：在设置好页表并将其地址加载到 %cr3 后，内核会设置控制寄存器 %cr0 中的分页启用位（CR0_PG），这一步骤正式启动了分页硬件。此时，CPU开始使用页表进行地址翻译，系统的内存管理机制进入正常工作状态。 切换到高地址执行：启用分页后，内核可以安全地从低地址跳转到高地址继续执行。由于页表已经将高地址映射到正确的物理内存位置，内核可以在它的预期虚拟地址空间中正常工作。 在整个启动过程中，除了分页硬件外，还有几个关键的硬件组件也在发挥重要作用。这些硬件协同工作，确保操作系统能够成功启动并运行：\n1. CPU（中央处理器） 指令执行：CPU是整个启动过程的核心，它负责执行从boot loader到内核的所有指令。启动过程开始时，CPU从固化在硬件中的地址（通常是BIOS或EFI）开始执行，然后逐步加载和运行boot loader，再到加载和执行内核。 模式切换：CPU在启动过程中会从实模式切换到保护模式，最后进入分页模式。在实模式下，CPU只处理简单的地址计算，但在保护模式和分页模式下，CPU可以利用复杂的内存管理和保护机制。 2. BIOS/UEFI 硬件初始化：BIOS（基本输入输出系统）或UEFI（统一可扩展固件接口）是计算机开机时首先运行的固件，它负责初始化计算机的硬件组件，如CPU、内存、硬盘和I/O设备。 引导加载器加载：BIOS/UEFI在完成硬件初始化后，会将控制权交给boot loader，这通常是通过读取特定存储设备上的引导扇区来实现的。 3. 内存（RAM） 代码和数据存储：内存用于存储启动过程中加载的所有代码和数据，包括boot loader、内核代码、页表以及其他重要的数据结构。在内核启动并运行时，内存还会被用来存储进程的代码、数据和栈等。 栈操作：CPU在执行指令时使用内存中的栈来保存函数调用的信息、局部变量和返回地址。栈的正确初始化和管理对于顺利执行程序至关重要。 4. 硬盘控制器 加载内核：硬盘控制器负责从硬盘中读取boot loader和内核。boot loader在启动时会通过硬盘控制器将内核从存储设备加载到内存的指定位置，以便CPU能够执行内核代码。 5. I/O设备 基本输入输出：在启动过程中，I/O设备（如键盘、显示器、串口等）通常会被初始化，以便在启动过程的早期阶段，系统可以输出调试信息或接受输入。 6. 中断控制器 中断管理：中断控制器负责管理和处理硬件中断。在启动过程中，操作系统会设置中断向量表，以确保系统能够正确处理来自外部设备的中断请求。虽然在启动过程的早期阶段，系统可能不会处理复杂的中断，但中断控制器的初始化和配置是操作系统启动的一个重要步骤。 创建第一个进程的过程可以分为几个重要步骤，以下是通俗但详细的讲解：\n初始化阶段：首先，在系统启动时，main 函数会初始化一些必要的设备和子系统。然后，它调用了 userinit 函数来创建系统中的第一个进程。 分配进程槽位：userinit 函数调用了 allocproc，这是一个用于在内核中分配新进程的函数。allocproc 的任务是找到一个未被使用的进程槽位（结构体 struct proc），然后将其状态从未使用（UNUSED）标记为胚胎状态（EMBRYO），表示它正在被使用并分配给一个新进程。 设置内核栈：接下来，allocproc 为新进程分配一个内核栈，并设置好内核栈和一系列内核寄存器，使得当进程第一次运行时，它会“返回”到用户空间。这个过程通过 forkret 函数实现，该函数的作用是让内核线程从某个点开始执行，最后跳转到 trapret，准备好用户态的寄存器并跳转到用户代码执行。 初始化页表：为了让进程能够执行自己的代码，userinit 还需要为进程创建一个页表，这个页表最初只映射内核的内存区域。然后，userinit 调用了 inituvm，为进程分配了一页物理内存，并将初始化代码（initcode.S）拷贝到这段内存中。这个代码是用来启动进程的。 设置用户模式寄存器：在这个阶段，userinit 设置了进程的陷阱帧（trapframe），这是一个用于保存用户模式寄存器的结构。这里的关键是确保进程以用户模式（而不是内核模式）启动，并且能够处理硬件中断。 进程变为可运行状态：一旦所有这些设置完成，userinit 将进程的状态设置为 RUNNABLE，这意味着该进程现在可以被调度器选中运行了。 调度和运行：在 main 函数调用了 userinit 之后，系统调用 scheduler 函数来开始运行进程。调度器会找到一个处于 RUNNABLE 状态的进程，将其状态设为 RUNNING，然后通过 swtch 函数切换上下文，开始运行这个进程的内核线程。 用户代码的执行：最终，这个第一个进程的执行从 initcode.S 的第一个指令开始，该指令位于虚拟地址0。因为之前已经为该进程建立了页表，这些虚拟地址会被翻译为实际的物理内存地址，从而顺利执行进程的用户代码。 通过这些步骤，系统成功创建并运行了第一个用户进程，这也是系统启动后的第一个进程。\n新进程分配的内核栈最初包含一些关键内容，这些内容是为了使新进程能够正确地启动和运行。具体来说，内核栈的初始内容包括：\n上下文信息（context）：这是用于保存进程的寄存器状态的结构，包括指令指针（eip）和栈指针（esp）等。这些信息是为了保证进程能够从正确的位置继续执行。 返回地址：allocproc 会将返回地址设置为 forkret，这意味着当进程第一次运行时，它将从 forkret 开始执行。forkret 函数会进行一些初始化工作，然后返回到 trapret 函数。 trapret 地址：这是栈上的另一个重要内容，它在 forkret 之后被调用，用来从用户态进入内核态时恢复用户寄存器，并最终返回到用户代码的执行。 这些内容的作用是确保当新进程第一次被调度器选中运行时，它能够正确地进行从内核态到用户态的过渡，并开始执行用户代码。这种设置使得创建新进程和通过 fork 复制进程的过程可以共用同样的机制，从而简化了进程管理的逻辑。\n在一个进程中，除了内核栈以外，还包括以下重要内容：\n用户栈（User Stack）： 作用：用户栈用于存储用户态下的函数调用、局部变量和函数参数。每当进程进入用户态并执行用户代码时，它会使用用户栈。用户栈在每次系统调用或中断发生时会被保存，以便在返回到用户态时恢复。 进程控制块（Process Control Block, PCB）： 作用：这是内核用于管理和调度进程的一个重要数据结构。PCB 包含了进程的各种状态信息，如进程ID（PID）、进程状态（如 RUNNING, SLEEPING, ZOMBIE 等）、程序计数器（指示下一条指令的位置）、寄存器内容、打开的文件描述符列表、优先级、调度信息、以及内存管理信息（如页表指针）。 关键作用：PCB 是内核追踪进程的核心结构，它保存了进程执行所需的所有上下文信息。当进程被切换时，PCB 是用来保存和恢复上下文的关键。 虚拟地址空间（Virtual Address Space）： 作用：每个进程都有自己独立的虚拟地址空间。这个空间通常包括代码段（Text Segment）、数据段（Data Segment）、堆（Heap）和栈（Stack）。代码段包含可执行代码；数据段存放已初始化和未初始化的全局变量；堆用于动态内存分配；栈用于函数调用和局部变量。 关键作用：虚拟地址空间为每个进程提供了一个独立的运行环境，确保进程之间的内存隔离和安全。 页表（Page Table）： 作用：页表是内存管理单元（MMU）使用的数据结构，用于将进程的虚拟地址映射到物理地址。每个进程有自己的页表，内核利用它来管理内存和地址转换。 关键作用：页表实现了虚拟内存，使得进程可以假装拥有连续的内存地址，同时内核可以灵活地分配实际的物理内存。 文件描述符表（File Descriptor Table）： 作用：这是进程打开的所有文件的列表。每个打开的文件（或其他 I/O 资源，如管道、网络连接等）都有一个与之关联的文件描述符。 关键作用：文件描述符表使得进程可以进行文件 I/O 操作，如读写文件、网络通信等。每个文件描述符对应一个内核对象，内核通过这个对象管理文件操作。 信号处理表（Signal Handling Table）： 作用：用于定义进程如何处理各种信号。信号是操作系统向进程传递事件通知的一种方式（如中断、非法操作等）。 关键作用：信号处理表指定了进程遇到特定信号时要采取的操作（例如，忽略信号、执行默认操作或调用用户定义的处理函数）。 进程工作目录和根目录： 作用：进程有其当前工作目录（Current Working Directory, CWD）和根目录（Root Directory）。这些目录用于文件系统操作，指定文件路径是相对还是绝对。 关键作用：管理文件系统路径的上下文，使得进程能够访问和操作文件系统中的文件和目录。 共享内存和映射区域： 作用：这是进程可能使用的共享内存区域或通过内存映射文件的区域（如动态库映射）。 关键作用：提供进程间通信（IPC）机制，并允许进程高效访问大文件或共享数据段。 这些组件共同组成了一个进程的完整运行环境。它们协作使得操作系统可以多任务运行，安全地管理多个进程，以及在不同进程之间进行上下文切换。\n在创建第一个进程的过程中，初始化页表是至关重要的，因为页表用于将虚拟地址映射到物理地址。每个进程都有自己的虚拟地址空间，操作系统使用页表来管理这些地址与实际物理内存的对应关系。\n为什么要初始化页表？ 初始化页表的主要目的是为新进程提供一个独立的虚拟地址空间，这样进程可以运行在它自己的地址空间中，而不会干扰其他进程。同时，页表的设置允许操作系统通过分页机制有效管理内存，确保安全性和内存隔离。\n页表的重要性：在系统中，所有进程都运行在各自的虚拟地址空间中，而操作系统通过页表将这些虚拟地址转换为实际的物理地址。初始化页表为进程的运行提供了正确的地址映射，从而确保了进程能够访问内核和用户空间的必要资源。 “这个页表最初只映射内核的内存区域”是什么意思？ 当我们说“这个页表最初只映射内核的内存区域”时，指的是在初始阶段，页表只设置了内核空间的映射，而没有映射用户空间的地址。内核的地址空间包括内核代码、数据、堆、栈（包括内核栈）等内核所需的内存区域。\n内核栈：内核栈是内核在执行时使用的栈，是每个进程在内核态运行时的重要部分。在进程执行系统调用或发生中断时，CPU 会从用户模式切换到内核模式，使用内核栈来处理内核态代码。这部分内存是内核地址空间的一部分，因此会被映射。 所以，初始页表仅映射了内核的内存区域，意味着进程在最初的设置中只能访问内核空间的内存。这是为了保证进程一开始可以正常地在内核中执行。\n“这个代码是用来启动进程的”这段代码是从哪里来的？ 这里提到的“代码是用来启动进程的”指的是 initcode.S 这段汇编代码，它是用于初始化并启动第一个用户进程的。\ninitcode.S 的来源：initcode.S 是一个小型的汇编程序，它作为内核的一部分编译并链接到内核映像中。在构建内核时，链接器会将这段代码作为二进制数据嵌入到内核映像中。内核通过两个符号 _binary_initcode_start 和 _binary_initcode_size 标识这段代码的起始位置和大小。 作用：这段代码的主要作用是为第一个进程（initproc）提供一段简单的用户态代码。当第一个进程开始执行时，它会运行这段代码来初始化用户态的环境。其目的是确保进程能够顺利启动并进入用户态执行。这是内核为启动第一个进程提供的基础代码。 如何加载：在创建第一个进程时，内核会通过 inituvm 函数为该进程分配一页物理内存，并将 initcode.S 的二进制代码拷贝到这段内存中。这段内存被映射到进程的虚拟地址空间的地址0。当进程第一次运行时，处理器会从地址0开始执行 initcode.S 的指令。 总结一下，初始化页表是为了设置进程的虚拟地址空间，而最初的页表只映射内核区域（包括内核栈），以便在内核态能够正常工作。initcode.S 是一段汇编代码，它从内核编译时嵌入内核中，被加载到第一个进程的内存中，用于启动并运行该进程。\n每个进程的内核栈不是相通的，而是独立的。但是，内核空间在所有进程之间是共享的，但各进程对其访问是受控的。\n内核栈 独立性：每个进程都有自己独立的内核栈。当一个进程从用户态切换到内核态（例如执行系统调用或处理中断）时，它使用自己的内核栈来保存调用信息、局部变量以及处理中断或系统调用所需的其他数据。由于每个进程的内核栈是独立的，进程之间不会互相影响。这种独立性确保了进程的内核态执行环境的安全性和稳定性。 切换上下文时的保存与恢复：当操作系统在多个进程之间切换时（即进行上下文切换），它会保存当前进程的内核栈状态，并恢复下一个要运行的进程的内核栈。这种机制保证了每个进程可以独立执行，而不会干扰其他进程的内核栈。 内核空间 共享性：内核空间是所有进程共享的地址空间的一部分。它包含了内核代码、全局数据结构、设备驱动程序、内核栈等。这意味着所有进程都可以访问相同的内核代码和全局内核数据。内核空间通常位于每个进程的虚拟地址空间的高地址部分。 安全性：虽然内核空间在所有进程之间是共享的，但普通用户进程无法直接访问内核空间。这是通过硬件机制和内核态/用户态的权限控制来实现的。只有在进程运行于内核态时（例如在系统调用或中断处理期间），进程才能访问内核空间的内容。 统一的映射：所有进程的页表都会映射到相同的内核空间区域。这意味着当系统切换进程时，尽管进程的用户空间地址不同，但内核空间地址是一致的。这使得内核能够高效地管理和调度多个进程，而不必为每个进程维护独立的内核空间。 总结 内核栈：每个进程有自己的内核栈，互不相通，保证了内核态的独立性和安全性。 内核空间：内核空间在所有进程之间是共享的，但受权限控制，只有在内核态下进程才能访问内核空间。 这种设计确保了系统的安全性和稳定性，同时也保证了操作系统的效率。\np-\u0026gt;context-\u0026gt;eip 是进程控制块（struct proc）中的一个字段，用于保存进程在内核态的执行状态，特别是保存进程执行时的程序计数器（即指令指针）。具体来说：\np-\u0026gt;context-\u0026gt;eip 指的是什么？ eip：eip 是 x86 架构中的指令指针寄存器（也称为程序计数器）。它保存了 CPU 下一条将要执行的指令的地址。在上下文切换时，操作系统会保存当前进程的 eip 值，以便在恢复这个进程时，它可以从之前中断的地方继续执行。 p-\u0026gt;context-\u0026gt;eip：p-\u0026gt;context 是一个指向进程上下文结构的指针，这个结构保存了内核态下的 CPU 寄存器状态，其中包括 eip。当进程被切换出去时，eip 会被保存到 p-\u0026gt;context-\u0026gt;eip，当进程被切换回来的时候，eip 会从 p-\u0026gt;context-\u0026gt;eip 中恢复，这样进程就能继续从上次停止的地方执行。 p-\u0026gt;context 中有什么内容？ p-\u0026gt;context 是一个用于保存进程在内核态执行时 CPU 寄存器状态的结构。它通常包含以下内容：\neip（指令指针）：保存下一条将要执行的指令的地址。 esp（栈指针）：保存当前的栈指针，用于指示当前的栈顶位置。 ebx、ecx、edx、esi、edi、ebp：这些都是通用寄存器，用于保存进程执行时的寄存器状态。 eflags：保存 CPU 的状态标志寄存器，用于记录当前进程执行时的状态（如中断是否启用、运算结果的标志等）。 作用与重要性 上下文切换：当操作系统进行上下文切换时，会将当前进程的所有 CPU 寄存器状态保存到 p-\u0026gt;context 中。然后操作系统会加载下一个进程的 p-\u0026gt;context，恢复所有寄存器状态，使 CPU 继续执行该进程。这种机制确保了多任务操作系统可以高效地在多个进程之间切换，而不丢失每个进程的执行状态。 指令指针 eip 的作用尤其重要，因为它决定了进程接下来会执行哪条指令。没有正确保存和恢复 eip，进程可能会从错误的地址继续执行，导致系统不稳定甚至崩溃。 总的来说，p-\u0026gt;context 结构中的内容是进程上下文切换的核心，它记录了进程在内核态下所有关键的寄存器状态，以确保进程可以在被中断后正确恢复并继续执行。\nLab时遇到的问题\n“通过一个没有映射的页保护用户栈”是什么意思，怎么做到的\n这句话的意思是：xv6 通过在用户栈的末尾放置一个没有映射的页（即一个虚拟地址空间内的页表条目不指向任何物理内存），来保护用户栈免受溢出错误的影响。\n具体来说，当程序运行时，用户栈是从高地址向低地址方向增长的。如果程序意外地超出了栈的范围（比如递归太深或者分配了过多的局部变量），它可能会尝试访问栈的下方区域。如果这块区域没有得到适当保护，程序就可能覆盖掉其他内存区域的数据，导致不可预测的行为。\n为了防止这种情况发生，xv6 在用户栈的下方添加了一个“没有映射”的页。这意味着该页的页表条目（PTE）没有指向任何实际的物理内存。如果程序尝试访问这个没有映射的页（例如由于栈溢出），CPU 的分页硬件就会检测到这个访问，并产生一个页面错误（page fault），从而终止程序或让操作系统采取相应的处理措施。这就能有效地防止栈溢出带来的潜在危害。\n建立一个地址空间的过程可以分为以下几个步骤：\n1. 调用 kvmalloc() 位置：main() 调用 kvmalloc，位于代码的第1757行。 作用：kvmalloc() 是用于创建并切换到一个拥有内核所需映射的页表。它确保在操作系统启动时，内核可以正常运行。 关键操作：该函数调用 setupkvm() 来完成大部分工作。 2. 调用 setupkvm() 位置：第1737行。\n作用：setupkvm() 是负责实际创建内核所需的页表映射的函数。\n具体步骤\n：\n分配页目录页：setupkvm() 首先会分配一页内存来存储页目录，这是分页的最高层结构，用于指向页表。 调用 mappages()：使用 mappages() 函数，创建映射表，这些映射表可以在 kmap 数组中找到。kmap 数组中包含了各种需要被映射的内存区域。 3. 调用 mappages() 位置：第1679行。\n作用：mappages() 用来在页表中建立虚拟内存到物理内存的映射。\n具体步骤\n：\n逐页映射：mappages() 是逐页处理的，即一页一页地创建映射。对于每个虚拟地址，都需要建立相应的物理内存映射。 调用 walkpgdir()：mappages() 通过调用 walkpgdir() 来找到该虚拟地址对应的页表项（PTE）。 设置 PTE：在页表项中记录物理页号、访问权限（如 PTE_W、PTE_U）和 PTE_P 标志位来表示该页表项是否有效。 4. 调用 walkpgdir() 位置：第1654行。\n作用：walkpgdir() 模拟 x86 硬件分页机制，找到虚拟地址对应的页表项（PTE）。\n具体步骤\n：\n定位页目录项：walkpgdir() 使用虚拟地址的前10位来查找页目录中对应的条目（位于第1659行）。 检查是否需要分配页表页：如果页目录条目不存在且 alloc 参数为真，则分配一个新的页表页，并将其物理地址存入页目录中。 定位页表项：然后使用虚拟地址的中间10位，找到该地址在页表中的对应条目（PTE）。 返回PTE地址：最后，walkpgdir() 返回该PTE的地址，供 mappages() 初始化。 5. 初始化页表项 (PTE) 位置：在 mappages() 的第1691行。\n作用：mappages() 在 walkpgdir() 返回的 PTE 地址处，初始化 PTE 条目。\n具体内容\n：\n保存物理页号：PTE 中记录相应的物理内存页号。 设置权限标志：根据需要设置 PTE 的权限标志（如 PTE_W 表示可写，PTE_U 表示用户访问权限）。 标记页表项有效：通过设置 PTE_P 标志位，表明该页表项有效。 6. 完成内核的基础映射 1 setupkvm() 完成了\n1 kmap 数组中内核地址空间的映射，包括：\n内核指令和数据段的映射。 PHYSTOP 以下的物理内存的映射。 I/O 设备地址空间的映射。 7. 未建立用户空间映射 注意：在这个阶段，setupkvm() 仅仅完成了内核所需的映射，并未为用户空间内存建立映射。用户空间的映射将在稍后的执行过程中进行。 8. 切换到新页表 当 kvmalloc() 完成时，它会切换到新创建的页表，这确保了内核可以使用新建立的映射来执行代码。 如何管理空闲物理内存页的分配与释放。\n1. 物理内存分配器中的数据结构 空闲链表：分配器使用一个由空闲的物理内存页构成的链表来管理内存。链表中的每个元素是一个struct run结构体，用于表示一个空闲页。 自包含的结构：为了节省空间，分配器将struct run结构体存放在每个空闲页的开头部分，因为这些页本身是空闲的，没有其他数据。 2. 内存的安全保护 Spin Lock：分配器使用自旋锁（spin lock）来保护空闲链表的操作，防止并发操作引起的数据不一致问题。这个锁和链表一起封装在一个结构体中，以确保锁可以保护到相关的所有数据。 3. 分配器的初始化 kinit1和kinit2函数：分配器初始化分两步完成，kinit1用于在系统启动初期分配前4MB的内存，因为此时不支持锁和高于4MB的内存操作。kinit2允许使用锁，并解锁了更多的内存供系统使用。 PHYSTOP假设：在x86架构上，操作系统假设系统有240MB的物理内存（PHYSTOP），从内核结束地址到PHYSTOP之间的内存作为空闲内存池。freerange函数通过调用kfree将这部分内存页逐一加入空闲链表。 4. 地址对齐和释放 对齐处理：freerange函数使用PGROUNDUP确保内存页是以4096字节对齐的地址进行释放的，因为PTE（页表项）只能指向对齐的物理地址。 kfree函数：kfree负责将物理页重新加入空闲链表。它首先将释放的内存页内容设置为全1，以确保访问已释放内存时立刻崩溃，而不是继续使用无效数据。 5. 地址映射 虚拟地址和物理地址：分配器通过虚拟地址找到对应的物理页。这是因为在系统的内存管理中，物理内存通常被映射到高地址的虚拟内存空间中。 6. 类型转换 双重用途的地址：分配器在操作地址时，既将地址当作整数进行运算，也将其当作指针来操作内存中的数据。这种用法导致了大量的类型转换，同时也说明了分配器在释放或分配内存时可能会隐式地改变内存的类型。 7. 用户地址空间中的栈与堆 堆与栈的布局：堆位于栈的上方，栈本身占用一页内存，包含进程启动时的初始数据。栈的顶部包含命令行参数及其指针数组，并模仿函数main(argc, argv)的调用环境。 保护页：为了防止栈的溢出，栈的下方有一个未映射的保护页。如果栈增长超过这一页，会触发异常，从而保护系统不受非法访问的影响。 操作系统中 exec 系统调用的工作原理，exec 用于创建和初始化用户进程的地址空间。\n1. ELF 格式与 exec 的基本流程 ELF 文件：exec 通过读取并解析 ELF (Executable and Linkable Format) 文件来初始化用户地址空间。ELF 是一种通用的二进制文件格式，exec 首先检查文件的 ELF 头部以验证文件格式是否正确。 魔法数字检查：ELF 文件以 4 个“魔法数字”（0x7F, 'E', 'L', 'F'）开头。exec 首先通过检查这四个字节来确定文件是否是有效的 ELF 文件。如果魔法数字匹配，exec 继续处理文件，否则放弃执行。 2. 内存分配与段加载 页表设置：exec 通过 setupkvm 函数创建一个新的页表，其中不包含用户部分的映射。这为用户地址空间的初始化做好了准备。 内存分配与加载：exec 使用 allocuvm 为 ELF 文件的每个段分配内存。接着，loaduvm 将段的内容从文件中加载到内存中。loaduvm 通过 walkpgdir 找到内存中相应的物理地址，并通过 readi 从文件读取数据。 3. 处理 Program Header 段头解释：ELF 文件包含多个段头（Program Header），每个段头描述了一个需要载入内存的程序段。exec 依次处理每个段头，分配相应的内存并加载数据。 filesz 与 memsz：段头中的 filesz 是从文件中读取的字节数，memsz 是分配的内存大小。如果 filesz 小于 memsz，表示从文件读取的数据不足以填满分配的内存，未填充的部分通常用于存储未初始化的全局变量，并被填充为 0。 4. 用户栈的分配与初始化 栈内存分配：exec 为用户栈分配一页内存，并在栈顶放置传入的参数字符串。参数字符串的指针被保存在 ustack 中，最后在参数列表 (argv) 的末尾放置一个空指针，以便程序知道参数列表的结束。 伪造的返回地址：在栈上，ustack 的前三个位置依次存放伪造的返回地址、参数个数 (argc)、以及参数列表的指针 (argv)。这使得当程序从 main 函数开始执行时，能够正确访问这些参数。 5. 栈保护页 防止栈溢出：在分配栈页下方，exec 会设置一个无法访问的保护页。这个保护页用于防止栈意外增长超出分配的页数，从而引发内存访问错误。 处理大参数：如果传入的参数过大以至于超出栈的页，exec 通过 copyout 函数检测并返回错误，以避免栈溢出。 6. 错误处理与内存释放 错误处理：如果 exec 在创建新的内存映像过程中发现错误（例如无效的程序段），它会跳转到 bad 标签处，释放已经分配的内存，并返回 -1，表示调用失败。 内存映像切换：只有在确认新内存映像已经正确构建后，exec 才会释放旧的内存映像。这是为了确保如果 exec 失败时，能够安全地返回错误代码 -1。成功完成后，exec 返回 0，表示执行成功。 7. 总结 exec 是一个关键的系统调用，用于将用户进程的地址空间初始化为一个新的执行映像。它通过加载 ELF 文件、分配内存、设置栈空间等操作，确保用户进程可以正确启动并运行。 栈只分配一页内存，这在某些情况下可能会显得太小，特别是当程序需要处理大量的参数或者深度递归时。这种设计是为了简化内存管理和避免过度浪费，但也带来了某些局限性。如果需要处理超过一页内存的大参数，系统有以下几种方法来应对：\n1. 增加栈的大小 在某些系统中，可以动态增加栈的大小。具体方法包括：\n手动扩展：程序可以通过系统调用（例如 mmap）手动分配更多的栈空间。 自动扩展：某些操作系统会在检测到栈溢出时自动扩展栈空间。这个过程通常是由内核负责的，通过捕获页面错误并分配新页面来实现栈的自动扩展。 2. 使用堆内存 堆内存分配：程序可以使用堆（heap）来处理大数据，而不是依赖栈。通过调用 malloc 或者 calloc 这样的标准库函数，程序可以在堆上分配足够大的内存块来存储参数或其他数据。 传递指针：对于大参数，可以将参数放在堆中，然后在栈上只传递一个指向堆中数据的指针。这样可以有效减轻栈的压力，同时仍然能够处理大数据。 3. 参数从文件读取 文件输入：如果参数数据特别大，可以将其放在文件中，程序启动后从文件中读取。这种方式避免了将大量数据直接传递给程序，而是通过文件 I/O 进行处理，灵活性较高。 4. 分块处理 分块加载：对于过大的参数，可以考虑将其分块加载到内存中。每次只处理其中的一部分数据，处理完后再读取下一部分。这样可以降低对栈的要求，同时保持程序对大数据的处理能力。 5. 环境变量 环境变量传递：有时可以通过环境变量传递一些参数，环境变量不受栈大小的限制，且可以在程序运行时随时读取。 6. 系统配置 修改系统配置：某些操作系统允许通过修改配置文件或编译参数来增加默认的栈大小。这种方法可以在需要处理大量参数的应用中增大栈空间，避免因栈空间不足导致的错误。 “超级页”的特点\n“超级页”（Superpages）指的是在内存管理中使用较大的页面大小，而不是标准的4KB页。超级页通常为4MB或更大，具体特点包括：\n减少页表开销：使用超级页可以显著减少页表的大小和复杂度，因为每个超级页覆盖的地址空间比标准页大得多。这意味着需要维护的页表项（PTE）更少，从而减轻了页表的管理负担。 提高TLB（Translation Lookaside Buffer）效率：TLB 是一个缓存，用于加速虚拟地址到物理地址的转换。由于超级页减少了页表项的数量，TLB 更有可能缓存所有需要的页表项，从而减少TLB缺失的几率，提高内存访问效率。 适合大内存应用：在拥有大量内存的机器上，使用超级页非常有效，因为它们可以减少页表的复杂性，提高内存管理的整体性能。 浪费内存的风险：当应用程序的内存需求较小时，超级页可能会导致内存浪费。例如，一个只需要8KB内存的程序，如果被分配了4MB的超级页，将会浪费大量未使用的内存。 ","date":"2024-11-10T22:02:50+08:00","permalink":"https://echudet.github.io/p/mit6s081lec4/","title":"MIT6S081Lec4"},{"content":"","date":"2024-11-10T22:02:50+08:00","permalink":"https://echudet.github.io/p/mit6s081lec5/","title":"Mit6s081Lec5"},{"content":"Lecture 1 OS Interface Inode 是什么\nInode 是 UNIX 类文件系统中一个非常核心的概念，负责管理文件和目录的元数据。\n什么是 Inode？ Inode 是文件系统中的一个数据结构，用来存储文件的元信息（metadata），而不包含文件的内容和文件名。每一个文件或者目录都会分配一个唯一的 Inode，Inode 中存储了与文件或目录相关的以下信息：\n文件类型：是普通文件、目录还是设备文件（在 stat 结构体中的 type 字段表示）。 文件的大小：以字节为单位存储（在 stat 结构体中的 size 字段表示）。 硬链接数：有多少个不同的文件名指向这个 Inode（在 stat 结构体中的 nlink 字段表示）。 文件的访问权限：谁可以读取、写入或执行这个文件。 文件的时间戳：包括文件的创建时间、最后访问时间、最后修改时间等。 数据块指针：指向文件内容在硬盘上存储位置的指针。 Inode 的作用 Inode 在文件系统中起着关键的作用，因为它连接了文件名和文件内容之间的关系。理解这一点可以从以下几个方面来说明：\n文件与文件名的分离：文件名只是一个指向 Inode 的引用，这意味着在文件系统中，多个不同的文件名可以指向同一个 Inode（也就是硬链接）。这就是为什么可以使用 link 系统调用创建多个文件名指向同一个文件。 文件的元数据管理：所有与文件相关的元数据都存储在 Inode 中。这包括文件类型、大小、权限、所有者等。当你需要获取文件的这些信息时，系统会查找文件的 Inode，而不需要访问文件的内容。 文件内容的定位：Inode 包含指向文件内容在磁盘上位置的指针。当你打开一个文件时，系统通过文件名查找到对应的 Inode，然后通过 Inode 中的数据块指针找到文件的实际内容。 删除文件：当你使用 unlink 系统调用删除文件时，系统只删除了文件名与 Inode 的关联。如果这个 Inode 没有其他链接（即 nlink 为 0），并且没有进程在使用这个文件，系统才会真正释放与该 Inode 相关联的磁盘空间。 示例解释 比如你运行了下面这段代码：\n1 2 ccodepreviewrunopen(\u0026#34;a\u0026#34;, O_CREATE|O_WRONLY); link(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;); 这个例子创建了一个文件 a，并且为这个文件创建了一个硬链接 b。在这两行代码执行之后，文件 a 和 b 都指向同一个 Inode，它们的内容完全相同，任何一个文件的修改都会反映在另一个文件中。\n通过 Inode，你可以理解文件系统如何管理文件的元数据以及如何实现硬链接、文件删除等功能。简而言之，Inode 是文件系统中的核心结构，负责文件元数据的管理和文件内容的定位。\n指向设备的特殊文件和普通文件在文件系统中的处理方式和用途上有很大的不同。它们的主要区别如下：\n1. 文件类型和作用 普通文件：这是最常见的文件类型，用于存储用户的数据，例如文本文件、图像文件、程序文件等。普通文件包含实际的数据内容，文件系统通过 Inode 和数据块将文件名映射到硬盘上的实际数据。 特殊文件（设备文件）：特殊文件不包含用户数据，而是用于与硬件设备交互。设备文件通过文件系统接口将文件操作（如读写）映射到设备驱动程序。例如，/dev/sda 可能是一个硬盘设备文件，通过对这个文件进行操作，实际上是对对应的硬盘设备进行操作。 2. Inode 中的差异 普通文件的 Inode：普通文件的 Inode 包含文件的元数据（如文件类型、大小、权限等）和指向数据块的指针。这些指针指向存储在硬盘上文件内容的具体位置。 特殊文件的 Inode：设备文件的 Inode 也包含元数据，但它的指针部分不指向存储在硬盘上的数据块，而是包含与设备相关的标识信息，即主设备号（major number）和次设备号（minor number）。这些编号告诉内核应该使用哪个设备驱动程序以及如何与具体的设备进行通信。 3. 操作方式 普通文件操作：当你对普通文件进行读写操作时，文件系统会通过 Inode 查找文件内容在磁盘上的位置，并执行实际的数据读写。 特殊文件操作：当你对设备文件进行读写操作时，文件系统并不直接处理磁盘数据，而是将这些操作请求转发给对应的设备驱动程序。设备驱动程序根据操作类型（读或写）与实际的硬件设备进行交互。比如，对 /dev/null 文件的写操作，实际上什么也不做，而对 /dev/sda 的写操作，可能会导致硬盘上的数据被写入。 4. 使用场景 普通文件：用于存储和读取用户的应用数据，如文档、图像、程序代码等。 特殊文件：用于操作和控制硬件设备，比如： 字符设备文件（如 /dev/tty，对应终端设备）：处理字符流设备的读写，通常一次一个字符进行操作。 块设备文件（如 /dev/sda，对应硬盘设备）：处理块设备的读写操作，通常一次一个块（通常为512字节或更多）进行操作。 5. 系统调用的区别 普通文件：可以通过常规的系统调用如 open、read、write、close 等操作普通文件。 特殊文件：虽然设备文件也可以通过 open、read、write 等系统调用操作，但这些调用最终会被内核处理，并转交给设备的驱动程序，由驱动程序与硬件直接交互。 总结 普通文件用于存储数据，文件系统会直接对其内容进行操作。而设备文件是与硬件交互的接口，操作这些文件时，实际上是在与对应的设备驱动程序交互，进而与实际的硬件设备交互。这种设计允许设备在 UNIX 文件系统中的统一表示，使得设备的操作与文件操作类似，保持了 UNIX 的一贯简洁和一致性。\n设备文件是否可以修改？\n设备文件本身不能被修改，因为它不包含实际的数据内容。设备文件只是一个接口，通过它可以对硬件设备进行操作。例如，当你写数据到一个设备文件时，这些数据实际上是发送到对应的硬件设备（如硬盘）上，而不是存储在设备文件本身中。\n设备文件是否占用硬盘存储空间？ 设备文件在硬盘上几乎不占用存储空间。因为设备文件只是一个特殊的文件系统条目，主要存储了设备的标识信息（如主设备号和次设备号），以及一些基础的元数据（例如文件权限、创建时间等）。这些信息占用的空间非常小，通常只需要几个字节到几十个字节。\n与普通文件不同，设备文件没有指向实际数据块的指针，也没有存储用户数据的空间。所以，尽管设备文件存在于文件系统中，但它们在硬盘上占用的存储空间是微乎其微的。\n总结 设备文件不能被修改：你无法直接修改设备文件本身，只能通过它来与对应的硬件设备交互。 设备文件几乎不占用存储空间：它只是一个文件系统中的条目，用于标识和控制硬件设备，几乎不占用实际的硬盘存储空间。 ","date":"2024-11-10T00:00:00Z","permalink":"https://echudet.github.io/p/mit6s081lec1/","title":"MIT6S081Lec1"}]