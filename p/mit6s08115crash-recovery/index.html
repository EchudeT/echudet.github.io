<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="崩溃恢复是保障系统可靠性和数据完整性的关键机制，其重要性在于能够在系统遭遇故障或意外关机时，迅速恢复到一致性状态，防止数据丢失和损坏。崩溃恢复通常依赖于日志系统或检查点机制，通过记录操作日志或定期保存系统状态，实现恢复过程。在系统重新启动后，操作系统会借助这些日志或检查点信息重做或撤销未完成的操作，以此来重建数据的一致性状态。这一过程极大地减少了停机时间和服务中断，确保关键应用能够不间断运行，从而增强系统的稳健性。">
<title>MIT6S081：15Crash recovery</title>

<link rel='canonical' href='https://echudet.github.io/p/mit6s08115crash-recovery/'>

<link rel="stylesheet" href="/scss/style.min.86fc5e5efb829fb1bdd7a2d2275017fb3ae01ba7fcf491e347d76495ae5e3ae2.css"><meta property='og:title' content="MIT6S081：15Crash recovery">
<meta property='og:description' content="崩溃恢复是保障系统可靠性和数据完整性的关键机制，其重要性在于能够在系统遭遇故障或意外关机时，迅速恢复到一致性状态，防止数据丢失和损坏。崩溃恢复通常依赖于日志系统或检查点机制，通过记录操作日志或定期保存系统状态，实现恢复过程。在系统重新启动后，操作系统会借助这些日志或检查点信息重做或撤销未完成的操作，以此来重建数据的一致性状态。这一过程极大地减少了停机时间和服务中断，确保关键应用能够不间断运行，从而增强系统的稳健性。">
<meta property='og:url' content='https://echudet.github.io/p/mit6s08115crash-recovery/'>
<meta property='og:site_name' content='echudet'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2024-09-29T22:02:50&#43;08:00'/><meta property='article:modified_time' content='2024-11-12T23:44:05&#43;08:00'/><meta property='og:image' content='https://echudet.github.io/p/mit6s08115crash-recovery/bg.jpg' />
<meta name="twitter:title" content="MIT6S081：15Crash recovery">
<meta name="twitter:description" content="崩溃恢复是保障系统可靠性和数据完整性的关键机制，其重要性在于能够在系统遭遇故障或意外关机时，迅速恢复到一致性状态，防止数据丢失和损坏。崩溃恢复通常依赖于日志系统或检查点机制，通过记录操作日志或定期保存系统状态，实现恢复过程。在系统重新启动后，操作系统会借助这些日志或检查点信息重做或撤销未完成的操作，以此来重建数据的一致性状态。这一过程极大地减少了停机时间和服务中断，确保关键应用能够不间断运行，从而增强系统的稳健性。"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://echudet.github.io/p/mit6s08115crash-recovery/bg.jpg' />
    <link rel="shortcut icon" href="/timer.ico" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu11199958555974308744.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">⌨️</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">echudet</a></h1>
            <h2 class="site-description">探索编程的学生一枚</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/EchudeT'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://twitter.com'
                        target="_blank"
                        title="Twitter"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>档案</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>Links</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#课前预习">课前预习</a></li>
    <li><a href="#日志层">日志层</a></li>
    <li><a href="#日志设计">日志设计</a></li>
    <li><a href="#代码日志">代码：日志</a></li>
    <li><a href="#代码块分配器">代码：块分配器</a></li>
    <li><a href="#正课">正课</a></li>
    <li><a href="#file-system-crash概述">File system crash概述</a></li>
    <li><a href="#file-system-crash示例">File system crash示例</a></li>
    <li><a href="#file-system-logging">File system logging</a></li>
    <li><a href="#log_write函数">log_write函数</a></li>
    <li><a href="#end_op函数">end_op函数</a></li>
    <li><a href="#file-system-recovering">File system recovering</a></li>
    <li><a href="#log写磁盘流程">Log写磁盘流程</a></li>
    <li><a href="#file-system-challenges">File system challenges</a>
      <ol>
        <li><a href="#第一个是cache-eviction">第一个是cache eviction。</a></li>
        <li><a href="#第二个挑战是文件系统操作必须适配log的大小">第二个挑战是，文件系统操作必须适配log的大小。</a></li>
        <li><a href="#最后一个挑战是并发文件系统调用">最后一个挑战是并发文件系统调用。</a></li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/mit6s08115crash-recovery/">
                <img src="/p/mit6s08115crash-recovery/bg_hu5277658011936752031.jpg"
                        srcset="/p/mit6s08115crash-recovery/bg_hu5277658011936752031.jpg 800w, /p/mit6s08115crash-recovery/bg_hu12529128250392577342.jpg 1600w"
                        width="800" 
                        height="450" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：15Crash recovery" />
                
            </a>
        </div>
    

    <div class="article-details">


    
    <header class="article-category">
        
            <a href="/categories/mit6s081/" >
                Mit6s081
            </a>
        
            <a href="/categories/os/" >
                Os
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/mit6s08115crash-recovery/">MIT6S081：15Crash recovery</a>
        </h2>
    
        
        <h3 class="article-subtitle">
            崩溃恢复是保障系统可靠性和数据完整性的关键机制，其重要性在于能够在系统遭遇故障或意外关机时，迅速恢复到一致性状态，防止数据丢失和损坏。崩溃恢复通常依赖于日志系统或检查点机制，通过记录操作日志或定期保存系统状态，实现恢复过程。在系统重新启动后，操作系统会借助这些日志或检查点信息重做或撤销未完成的操作，以此来重建数据的一致性状态。这一过程极大地减少了停机时间和服务中断，确保关键应用能够不间断运行，从而增强系统的稳健性。
        </h3>
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2024-09-29</time>
            </div>
        

        
            <div>
                <?xml version="1.0" encoding="iso-8859-1"?>
<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="792px" height="792px" viewBox="0 0 792 792" style="enable-background:new 0 0 792 792;" xml:space="preserve">
<g>
	<g id="_x31_0_19_">
		<g>
			<path d="M643.5,742.5H594V569.25C594,473.566,516.434,396,420.75,396C516.434,396,594,318.434,594,222.75V49.5h49.5
				c13.662,0,24.75-11.088,24.75-24.75S657.162,0,643.5,0h-495c-13.662,0-24.75,11.088-24.75,24.75S134.838,49.5,148.5,49.5H198
				v173.25C198,318.434,275.566,396,371.25,396C275.566,396,198,473.566,198,569.25V742.5h-49.5c-13.662,0-24.75,11.088-24.75,24.75
				S134.838,792,148.5,792h495c13.662,0,24.75-11.088,24.75-24.75S657.162,742.5,643.5,742.5z M247.5,222.75
				c0-43.387,0-173.25,0-173.25h297c0,0,0,133.427,0,173.25c0,68.335-58.188,123.75-129.938,123.75h-37.125
				C305.687,346.5,247.5,291.085,247.5,222.75z M544.5,742.5h-297c0,0,0-129.888,0-173.25c0-68.335,58.187-123.75,129.938-123.75
				h37.125c71.75,0,129.938,55.415,129.938,123.75C544.5,609.072,544.5,742.5,544.5,742.5z"/>
		</g>
	</g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
</svg>

                <time class="article-time--reading">
                    阅读时长: 41 分钟
                </time>
            </div>
        

         
        <div>
            <?xml version="1.0" encoding="iso-8859-1"?>
<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="79.536px" height="79.536px" viewBox="0 0 79.536 79.536" style="enable-background:new 0 0 79.536 79.536;"
	 xml:space="preserve">
<g>
	<path style="fill:#010002;" d="M40.162,17.906C37.415,15.275,21.614,6.141,0,15.451c0,0.138,0,2.722,0,6.654v44.418h32.747
		c1.126,0.968,3.798,1.651,6.926,1.651c3.119,0,5.802-0.684,6.931-1.651h32.933V22.105c0-3.933,0-6.517,0-6.654
		C58.813,6.314,42.257,15.982,40.162,17.906z M37.229,63.349c0-1.75-15.372-11.981-33.125-0.818V19.216
		c3.516-2.014,8.246-3.249,13.463-3.249c10.864,0,19.662,3.562,19.662,10.175V63.349z M75.684,62.53
		c-17.751-11.163-33.108-0.932-33.108,0.818V26.146c0-6.612,8.792-10.175,19.646-10.175c5.22,0,9.952,1.235,13.463,3.249V62.53z"/>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
</svg>

            <time class="article-words">
                文章字数：20391字
            </time>
        </div>
        <div class="article-lastmod">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time>
                    Nov 12, 2024 23:44 &#43;0800
                </time>
            </div></footer>
    

    




    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="lec15-crash-recovery">Lec15 Crash recovery
</h1><h2 id="课前预习">课前预习
</h2><h2 id="日志层">日志层
</h2><p>文件系统设计中最有趣的问题之一是崩溃恢复。</p>
<p>出现此问题的原因是，许多文件系统操作都涉及到对磁盘的多次写入，并且在完成写操作的部分子集后崩溃可能会使磁盘上的文件系统处于不一致的状态。</p>
<p>例如，假设在文件截断（将文件长度设置为零并释放其内容块）期间发生崩溃。根据磁盘写入的顺序，崩溃可能会留下对标记为空闲的内容块的引用的inode，也可能留下已分配但未引用的内容块。</p>
<p>后者相对来说是良性的，但引用已释放块的inode在重新启动后可能会导致严重问题。</p>
<p>重新启动后，内核可能会将该块分配给另一个文件，现在我们有两个不同的文件无意中指向同一块。</p>
<p>如果xv6支持多个用户，这种情况可能是一个安全问题，因为旧文件的所有者将能够读取和写入新文件中的块，而新文件的所有者是另一个用户。</p>
<p>Xv6通过简单的日志记录形式解决了文件系统操作期间的崩溃问题。</p>
<p>xv6系统调用不会直接写入磁盘上的文件系统数据结构。</p>
<p>相反，它会在磁盘上的<em>log</em>（日志）中放置它希望进行的所有磁盘写入的描述。</p>
<p>一旦系统调用记录了它的所有写入操作，它就会向磁盘写入一条特殊的<em>commit</em>（提交）记录，表明日志包含一个完整的操作。</p>
<p>此时，系统调用将写操作复制到磁盘上的文件系统数据结构。</p>
<p>完成这些写入后，系统调用将擦除磁盘上的日志。</p>
<p>如果系统崩溃并重新启动，则在运行任何进程之前，文件系统代码将按如下方式从崩溃中恢复。</p>
<p>如果日志标记为包含完整操作，则恢复代码会将写操作复制到磁盘文件系统中它们所属的位置。</p>
<p>如果日志没有标记为包含完整操作，则恢复代码将忽略该日志。恢复代码通过擦除日志完成。</p>
<p>为什么xv6的日志解决了文件系统操作期间的崩溃问题？</p>
<ul>
<li>如果崩溃发生在操作提交之前，那么磁盘上的登录将不会被标记为已完成，恢复代码将忽略它，并且磁盘的状态将如同操作尚未启动一样。</li>
<li>如果崩溃发生在操作提交之后，则恢复将重播操作的所有写入操作，如果操作已开始将它们写入磁盘数据结构，则可能会重复这些操作。</li>
</ul>
<p>在任何一种情况下，日志都会使操作在崩溃时成为原子操作：恢复后，要么操作的所有写入都显示在磁盘上，要么都不显示。</p>
<h2 id="日志设计">日志设计
</h2><p>日志驻留在超级块中指定的已知固定位置。</p>
<blockquote>
<p><strong>超级块</strong> 是 xv6 文件系统中的一个重要结构，它存储了文件系统的基本信息和元数据。超级块在文件系统中扮演着类似于“目录”的角色，记录了关于文件系统布局的全局信息。超级块是存储在文件系统的特定块中，并且它会在文件系统被挂载时读入内存</p>
<p>超级块的主要作用是提供以下关键信息：</p>
<ol>
<li><strong>文件系统的总体布局</strong>：超级块中包含文件系统中各个区域的大小和位置，例如：
<ul>
<li><strong>inode（索引节点）区域的起始位置和数量</strong>。</li>
<li><strong>数据块区域的起始位置和数量</strong>。</li>
<li><strong>位图的起始位置</strong>，用于管理块的分配。</li>
</ul>
</li>
<li><strong>块的总数和 inode 的总数</strong>：超级块记录了文件系统中总的块数和 inode 数。inode 是文件系统中的一种数据结构，每个 inode 对应一个文件或目录，存储了它们的元数据信息（如文件大小、权限等）。</li>
<li><strong>文件系统的其他元数据</strong>：例如文件系统的版本号、磁盘块大小等信息。</li>
</ol>
</blockquote>
<p>它由一个头块（header block）和一系列更新块的副本（logged block）组成。</p>
<p>头块包含一个扇区号数组（每个logged block对应一个扇区号）以及日志块的计数。</p>
<p>磁盘上的头块中的计数或者为零，表示日志中没有事务；或者为非零，表示日志包含一个完整的已提交事务，并具有指定数量的logged block。</p>
<p>在事务提交（commit）时Xv6才向头块写入数据，在此之前不会写入，并在将logged blocks复制到文件系统后将计数设置为零。</p>
<p>因此，事务中途崩溃将导致日志头块中的计数为零；提交后的崩溃将导致非零计数。</p>
<blockquote>
<p>注：logged block表示已经记录了操作信息的日志块，而log block仅表示日志块</p>
</blockquote>
<p>每个系统调用的代码都指示写入序列的起止，考虑到崩溃，写入序列必须具有原子性。</p>
<p>为了允许不同进程并发执行文件系统操作，日志系统可以将多个系统调用的写入累积到一个事务中。</p>
<p>因此，单个提交可能涉及多个完整系统调用的写入。</p>
<p>为了避免在事务之间拆分系统调用，日志系统仅在没有文件系统调用进行时提交。</p>
<p>同时提交多个事务的想法称为<strong>组提交</strong>（group commit）。</p>
<p>组提交减少了磁盘操作的数量，因为成本固定的一次提交分摊了多个操作。</p>
<p>组提交还同时为磁盘系统提供更多并发写操作，可能允许磁盘在一个磁盘旋转时间内写入所有这些操作。</p>
<p>Xv6的virtio驱动程序不支持这种批处理，但是Xv6的文件系统设计允许这样做。</p>
<p>Xv6在磁盘上<strong>留出固定的空间</strong>来保存日志。</p>
<p>事务中系统调用写入的块总数必须可容纳于该空间。</p>
<p>这导致两个后果：任何单个系统调用都不允许写入超过日志空间的不同块。</p>
<p>这对于大多数系统调用来说都不是问题，但其中两个可能会写入许多块：<code>write</code>和<code>unlink</code>。</p>
<p>一个大文件的<code>write</code>可以写入多个数据块和多个位图块以及一个inode块；<code>unlink</code>大文件可能会写入许多位图块和inode。</p>
<p>Xv6的<code>write</code>系统调用将大的写入分解为适合日志的多个较小的写入，<code>unlink</code>不会导致此问题，因为实际上Xv6文件系统只使用一个位图块。</p>
<p>日志空间有限的另一个后果是，除非确定系统调用的写入将可容纳于日志中剩余的空间，否则日志系统无法允许启动系统调用。</p>
<h2 id="代码日志">代码：日志
</h2><p>在系统调用中一个典型的日志使用就像这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"> <span class="nf">begin_op</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="p">...</span>
</span></span><span class="line"><span class="cl"> <span class="n">bp</span> <span class="o">=</span> <span class="nf">bread</span><span class="p">(...);</span>
</span></span><span class="line"><span class="cl"> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[...]</span> <span class="o">=</span> <span class="p">...;</span>
</span></span><span class="line"><span class="cl"> <span class="nf">log_write</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">...</span>
</span></span><span class="line"><span class="cl"> <span class="nf">end_op</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>begin_op</code>（<em><strong>kernel/log.c</strong></em>:126）等待直到日志系统当前<strong>未处于提交</strong>中，并且直到有足够的未被占用的日志空间来保存此调用的写入。</p>
<p><code>log.outstanding</code>统计预定了日志空间的系统调用数；为此保留的总空间为<code>log.outstanding</code>乘以<code>MAXOPBLOCKS</code>。</p>
<p>递增<code>log.outstanding</code>会预定空间并防止在此系统调用期间发生提交。代码保守地假设每个系统调用最多可以写入<code>MAXOPBLOCKS</code>个不同的块。</p>
<p><code>log_write</code>（<em><strong>kernel/log.c</strong></em>:214）充当<code>bwrite</code>的代理。它将块的扇区号记录在内存中，在磁盘上的日志中预定一个槽位，并调用<code>bpin</code>将缓存固定在block cache中，以防止block cache将其逐出。</p>
<blockquote>
<p>注：固定在block cache是指在缓存不足需要考虑替换时，不会将这个block换出，因为事务具有原子性：假设块45被写入，将其换出的话需要写入磁盘中文件系统对应的位置，而日志系统要求所有内存必须都存入日志，最后才能写入文件系统。</p>
<p><code>bpin</code>是通过增加引用计数防止块被换出的，之后需要再调用<code>bunpin</code></p>
</blockquote>
<p>在提交之前，块必须留在缓存中：在提交之前，缓存的副本是修改的唯一记录；只有在提交后才能将其写入磁盘上的位置；同一事务中的其他读取必须看到修改。</p>
<p><code>log_write</code>会注意到在单个事务中多次写入一个块的情况，并在日志中为该块分配相同的槽位。这种优化通常称为合并（absorption）。</p>
<p>例如，包含多个文件inode的磁盘块在一个事务中被多次写入是很常见的。通过将多个磁盘写入合并到一个磁盘中，文件系统可以节省日志空间并实现更好的性能，因为只有一个磁盘块副本必须写入磁盘。</p>
<blockquote>
<p>注：日志需要写入磁盘，以便重启后读取，但日志头块和日志数据块也会在block cache中有一个副本</p>
</blockquote>
<p><code>end_op</code>（<em><strong>kernel/log.c</strong></em>:146）首先减少未完成系统调用的计数。</p>
<p>如果计数现在为零，则通过调用<code>commit()</code>提交当前事务。这一过程分为四个阶段。</p>
<p><code>write_log()</code>（<em><strong>kernel/log.c</strong></em>:178）将事务中修改的每个块从缓冲区缓存复制到磁盘上日志槽位中。</p>
<p><code>write_head()</code>（<em><strong>kernel/log.c</strong></em>:102）将头块写入磁盘：这是提交点，写入后的崩溃将导致从日志恢复重演事务的写入操作。</p>
<p><code>install_trans</code>（<em><strong>kernel/log.c</strong></em>:69）从日志中读取每个块，并将其写入文件系统中的适当位置。</p>
<p>最后，<code>end_op</code>写入计数为零的日志头；这必须在下一个事务开始写入日志块之前发生，以便崩溃不会导致使用一个事务的头块和后续事务的日志块进行恢复。</p>
<p><code>recover_from_log</code>（<em><strong>kernel/log.c</strong></em>:116）是由<code>initlog</code>（<em><strong>kernel/log.c</strong></em>:55）调用的，而它又是在第一个用户进程运行（<em><strong>kernel/proc.c</strong></em>:539）之前的引导期间由<code>fsinit</code>（<em><strong>kernel/fs.c</strong></em>:42）调用的。它读取日志头，如果头中指示日志包含已提交的事务，则模拟<code>end_op</code>的操作。</p>
<p>日志的一个示例使用发生在<code>filewrite</code>（<em><strong>kernel/file.c</strong></em>:135）中。事务如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"> <span class="nf">begin_op</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl"> <span class="nf">ilock</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"> <span class="n">r</span> <span class="o">=</span> <span class="nf">writei</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span> <span class="p">...);</span> 
</span></span><span class="line"><span class="cl"> <span class="nf">iunlock</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"> <span class="nf">end_op</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这段代码被包装在一个循环中，该循环一次将大的写操作分解为几个扇区的单个事务，以避免日志溢出。作为此事务的一部分，对<code>writei</code>的调用写入许多块：文件的inode、一个或多个位图块以及一些数据块。</p>
<h2 id="代码块分配器">代码：块分配器
</h2><p>文件和目录内容存储在磁盘块中，磁盘块必须从空闲池中分配。xv6的块分配器在磁盘上维护一个空闲位图，每一位代表一个块。0表示对应的块是空闲的；1表示它正在使用中。程序<code>mkfs</code>设置对应于引导扇区、超级块、日志块、inode块和位图块的比特位。</p>
<p>块分配器提供两个功能：<code>balloc</code>分配一个新的磁盘块，<code>bfree</code>释放一个块。</p>
<p><code>Balloc</code>中位于<em><strong>kernel/fs.c</strong></em>:71的循环从块0到<code>sb.size</code>（文件系统中的块数）遍历每个块。它查找位图中位为零的空闲块。</p>
<p>如果<code>balloc</code>找到这样一个块，它将更新位图并返回该块。为了提高效率，循环被分成两部分。</p>
<p>外部循环读取位图中的每个块。内部循环检查单个位图块中的所有BPB位。</p>
<p>由于任何一个位图块在buffer cache中一次只允许一个进程使用，因此，如果两个进程同时尝试分配一个块，可能会发生争用。</p>
<p><code>Bfree</code>（<em><strong>kernel/fs.c</strong></em>:90）找到正确的位图块并清除正确的位。同样，<code>bread</code>和<code>brelse</code>隐含的独占使用避免了显式锁定的需要。</p>
<p>与本章其余部分描述的大部分代码一样，必须在事务内部调用<code>balloc</code>和<code>bfree</code>。</p>
<h2 id="正课">正课
</h2><h2 id="file-system-crash概述">File system crash概述
</h2><p>今天的课程是有关文件系统中的Crash safety。</p>
<p>这里的Crash safety并不是一个通用的解决方案，而是只关注一个特定的问题的解决方案，也就是crash或者电力故障可能会导致在磁盘上的文件系统处于不一致或者不正确状态的问题。</p>
<p>当我说不正确的状态时，是指例如一个data block属于两个文件，或者一个inode被分配给了两个不同的文件。</p>
<p>这个问题<strong>可能出现的场景</strong>可能是这样，当你在运行make指令时，make与文件系统会有频繁的交互，并读写文件，但是在make执行的过程中断电了，可能是你的笔记本电脑没电了，也可能就是停电了，之后电力恢复之后，你重启电脑并运行ls指令，你会期望你的文件系统仍然在一个好的可用的状态。</p>
<p>这里我们关心的crash或者故障包括了：</p>
<ul>
<li>
<p>在文件系统操作过程中的电力故障</p>
</li>
<li>
<p>在文件系统操作过程中的内核panic</p>
<blockquote>
<p>包括XV6在内的大部分内核都会panic，panic可能是由内核bug引起，它会突然导致你的系统故障，但是你肯定期望能够在重启之后还能使用文件系统。</p>
</blockquote>
</li>
</ul>
<p>文件系统的操作都包含了多个步骤，在多个步骤的错误位置crash或者电力故障了，存储在磁盘上的文件系统可能会是一种不一致的状态，之后可能会发生一些坏的事情。</p>
<p>这类特定问题的解决方法，也就是logging。</p>
<p>这是一个最初来自于数据库世界的很流行的解决方案，现在很多文件系统都在使用logging。</p>
<p>之所以它很流行，是因为它是一个很好用的方法。</p>
<p>XV6的实现非常简单，几乎是最简单的实现logging的方法，因为我们只是为了演示关键的思想。</p>
<p>由于XV6实现的较为简单，XV6中的logging存在一个缺点，它的性能并不咋样，尽管logging系统原则上来说可以获得好的性能。</p>
<blockquote>
<p>在下节课我们将通过学习Linux的ext3文件系统所使用的logging系统，来看一下如何实现一个高性能logging系统。</p>
</blockquote>
<p>这是我们最后一节有关XV6的课程。这节课之后，我们将切换到阅读论文。</p>
<p>因为这节课讲完了之后，我们就覆盖了操作系统的基本概念，我们可以通过阅读论文看一些更高级的操作系统思想。</p>
<p>这节课关注的场景。类似于创建文件，写文件这样的文件系统操作，都包含了多个步骤的写磁盘操作。</p>
<p>如何创建一个文件，这里多个步骤的顺序是（注，实际步骤会更多，详见14.5）：</p>
<ul>
<li>分配inode，或者在磁盘上将inode标记为已分配</li>
<li>之后更新包含了新文件的目录的data block</li>
</ul>
<p>如果在这两个步骤之间，操作系统crash了。这时可能会使得文件系统的属性被破坏。</p>
<p>这里的属性是指，每一个磁盘block要么是空闲的，要么是只分配给了一个文件。即使故障出现在磁盘操作的过程中，我们期望这个属性仍然能够保持。</p>
<p>如果这个属性被破坏了，那么重启系统之后程序可能会运行出错，比如：</p>
<ul>
<li>操作系统可能又立刻crash了，因为文件系统中的一些数据结构现在可能处于一种文件系统无法处理的状态。</li>
<li>或者，更可能的是操作系统没有crash，但是数据丢失了或者读写了错误的数据。</li>
</ul>
<h2 id="file-system-crash示例">File system crash示例
</h2><p>为了更清晰的理解这里的风险，让我们看一些基于XV6的例子，并看一下哪里可能出错。</p>
<p>XV6有一个非常简单的文件系统和磁盘数据的排布方式。</p>
<p>在super block之后就是log block，我们今天主要介绍的就是log block。</p>
<p>log block之后是inode block，每个block可能包含了多个inode。</p>
<p>之后是bitmap block，它记录了哪个data block是空闲的。</p>
<p>最后是data block，这里包含了文件系统的实际数据。</p>
<p>操作系统与磁盘block的交互过程，创建一个文件涉及到了多个操作：</p>
<ul>
<li>首先是分配inode，因为首先写的是block 33</li>
<li>之后inode被初始化，然后又写了一次block 33</li>
<li>之后是写block 46，是将文件x的inode编号写入到x所在目录的inode的data block中</li>
<li>之后是更新root inode，因为文件x创建在根目录，所以需要更新根目录的inode的size字段，以包含这里新创建的文件x</li>
<li>最后再次更新了文件x的inode</li>
</ul>
<p><img src="/p/mit6s08115crash-recovery/p26.png"
	width="1017"
	height="212"
	srcset="/p/mit6s08115crash-recovery/p26_hu13609032275745756791.png 480w, /p/mit6s08115crash-recovery/p26_hu6504221620410115434.png 1024w"
	loading="lazy"
	
		alt="p26"
	
	
		class="gallery-image" 
		data-flex-grow="479"
		data-flex-basis="1151px"
	
></p>
<p>在出现电力故障之后，因为内存数据保存在RAM中，所有的内存数据都丢失了。</p>
<p>所有的进程数据，所有的文件描述符，内存中所有的缓存都没有了，因为内存数据不是持久化的。</p>
<p>我们唯一剩下的就是磁盘上的数据，因为磁盘的介质是持久化的，所以只有磁盘上的数据能够在电力故障之后存活。</p>
<p>基于这些事实，如果我们在上面的位置出现故障，并且没有额外的机制，没有logging，会有多糟糕呢？我们这里会有什么风险？</p>
<p>在这个位置，我们先写了block 33表明inode已被使用，之后出现了电力故障，然后计算机又重启了。</p>
<p>这时，我们丢失了刚刚分配给文件x的inode。这个inode虽然被标记为已被分配，但是它并没有放到任何目录中，所以也就没有出现在任何目录中，因此我们也就没办法删除这个inode。</p>
<p>所以在这个位置发生电力故障会导致我们丢失inode。</p>
<p>你或许会认为，我们应该改一改代码，将写block的顺序调整一下，这样就不会丢失inode了。所以我们可以先写block 46来更新目录内容，之后再写block 32来更新目录的size字段，最后再将block 33中的inode标记为已被分配。</p>
<p>这里的效果是一样的，只是顺序略有不同。并且这样我们应该可以避免丢失inode的问题。那么问题来了，这里可以工作吗？我们应该问问自己，如果在下面的位置发生了电力故障会怎样？</p>
<p>在这个位置，目录被更新了，但是还没有在磁盘上分配inode。</p>
<p>电力故障之后机器重启，文件系统会是一个什么状态？或者说，如果我们读取根目录下的文件x，会发生什么，因为现在在根目录的data block已经有了文件x的记录？</p>
<p>是的，我们会读取一个未被分配的inode，因为inode在crash之前还未被标记成被分配。更糟糕的是，如果inode之后被分配给一个不同的文件，这样会导致有两个应该完全不同的文件共享了同一个inode。</p>
<p>如果这两个文件分别属于用户1和用户2，那么用户1就可以读到用户2的文件了。所以上面的解决方案也不好。</p>
<p>所以调整写磁盘的顺序并不能彻底解决我们的问题，我们只是从一个问题换到了一个新的问题。</p>
<p>让我们再看一个例子，这个例子中会向文件x写入“hi”（注，也就是14.5介绍的第二个部分）</p>
<p><img src="/p/mit6s08115crash-recovery/p27.png"
	width="914"
	height="299"
	srcset="/p/mit6s08115crash-recovery/p27_hu14353094372252244078.png 480w, /p/mit6s08115crash-recovery/p27_hu12476567672705489126.png 1024w"
	loading="lazy"
	
		alt="p27"
	
	
		class="gallery-image" 
		data-flex-grow="305"
		data-flex-basis="733px"
	
></p>
<p>一旦成功的创建了文件x，之后会调用write系统调用，我们在上节课看到了write系统调用也执行了多个写磁盘的操作。</p>
<ul>
<li>首先会从bitmap block，也就是block 45中，分配data block，通过从bitmap中分配一个bit，来表明一个data block已被分配。</li>
<li>上一步分配的data block是block 595，这里将字符“h”写入到block 595。</li>
<li>将字符“i”写入到block 595。</li>
<li>最后更新文件夹x的inode来更新size字段。</li>
</ul>
<p>这里我们也可以问自己一个问题，我们在下面的位置crash了会怎样？</p>
<p><img src="/p/mit6s08115crash-recovery/p28.png"
	width="1028"
	height="155"
	srcset="/p/mit6s08115crash-recovery/p28_hu11492647275442548050.png 480w, /p/mit6s08115crash-recovery/p28_hu26238801969509571.png 1024w"
	loading="lazy"
	
		alt="p28"
	
	
		class="gallery-image" 
		data-flex-grow="663"
		data-flex-basis="1591px"
	
></p>
<p>这里我们从bitmap block中分配了一个data block，但是又还没有更新到文件x的inode中。</p>
<p>当我们重启之后，磁盘处于一个特殊的状态，这里的风险是什么？是的，我们这里丢失了data block，因为这个data block被分配了，但是却没有出现在任何文件中，因为它还没有被记录在任何inode中。</p>
<p>你或许会想，是因为这里的顺序不对才会导致丢失data block的问题。我们应该先写block 33来更新inode来包含data block 595（同样的问题，这个时候data block都还没有分配怎么知道是595），之后才通过写block 45将data block 595标记为已被分配。</p>
<p>所以，为了避免丢失data block，我们将写block的顺序改成这样。现在我们考虑一下，如果故障发生在这两个操作中间会怎样？(略)</p>
<p>这时inode会认为data block 595属于文件x，但是在磁盘上它还被标记为未被分配的。之后如果另一个文件被创建了，block 595可能会被另一个文件所使用。所以现在两个文件都会在自己的inode中记录block 595。如果两个文件属于两个用户，那么两个用户就可以读写彼此的数据了。很明显，我们不想这样，文件系统应该确保每一个data block要么属于且只属于一个文件，要么是空闲的。所以这里的修改会导致磁盘block在多个文件之间共享的安全问题，这明显是错误的。</p>
<p>所以这里的问题并不在于操作的顺序，而在于我们这里有多个写磁盘的操作，这些操作必须作为一个原子操作出现在磁盘上。</p>
<h2 id="file-system-logging">File system logging
</h2><p>我们这节课要讨论的针对文件系统crash之后的问题的解决方案，其实就是logging。</p>
<p>这是来自于数据库的一种解决方案。它有一些好的属性：</p>
<p>解决方案。它有一些好的属性：</p>
<ul>
<li>首先，它可以确保文件系统的系统调用是<strong>原子性</strong>的。比如你调用create/write系统调用，这些系统调用的效果是要么完全出现，要么完全不出现，这样就避免了一个系统调用只有部分写磁盘操作出现在磁盘上。</li>
<li>其次，它支持<strong>快速恢复</strong>（Fast Recovery）。在重启之后，我们不需要做大量的工作来修复文件系统，只需要非常小的工作量。这里的快速是相比另一个解决方案来说，在另一个解决方案中，你可能需要读取文件系统的所有block，读取inode，bitmap block，并检查文件系统是否还在一个正确的状态，再来修复。而logging可以有快速恢复的属性。</li>
<li>最后，原则上来说，它可以<strong>非常的高效</strong>，尽管我们在XV6中看到的实现不是很高效。</li>
</ul>
<p>如何构建一个logging系统，并同时具有原子性的系统调用，快速恢复和高性能，而今天，我们只会关注前两点。</p>
<p>logging的基本思想还是很直观的。</p>
<p>首先，你将磁盘分割成两个部分，其中一个部分是log，另一个部分是文件系统，文件系统可能会比log大得多。</p>
<p>1.（log write）当需要更新文件系统时，我们并不是更新文件系统本身。</p>
<p>假设我们在内存中缓存了bitmap block，也就是block 45。</p>
<p>当需要更新bitmap时，我们并不是直接写block 45，而是将数据写入到log中，并记录这个更新应该写入到block 45。</p>
<p>对于所有的写 block都会有相同的操作，例如更新inode，也会记录一条写block 33的log。</p>
<p>所以基本上，任何一次写操作都是先写入到log，我们并不是直接写入到block所在的位置，而总是先将写操作写入到log中。</p>
<p>2.（commit op）之后在某个时间，当文件系统的操作结束了，比如说我们前一节看到的4-5个写block操作都结束，并且都存在于log中，我们会commit文件系统的操作。</p>
<p>这意味着我们需要在log的某个位置记录属于同一个文件系统的操作的个数，例如5。</p>
<p>3.（install log）当我们在log中存储了所有写block的内容时，如果我们要真正执行这些操作，只需要将block从log分区移到文件系统分区。</p>
<p>我们知道第一个操作该写入到block 45，我们会直接将数据从log写到block45，第二个操作该写入到block 33，我们会将它写入到block 33，依次类推。</p>
<p>4.（clean log）一旦完成了，就可以清除log。清除log实际上就是将属于同一个文件系统的操作的个数设置为0。</p>
<p>以上就是log的基本工作方式。</p>
<p>为什么这样的工作方式是好的呢？假设我们crash并重启了。在重启的时候，文件系统会查看log的commit记录值，如果是0的话，那么什么也不做。</p>
<p>如果大于0的话，我们就知道log中存储的block需要被写入到文件系统中，很明显我们在crash的时候并不一定完成了install log，我们可能是在commit之后，clean log之前crash的。</p>
<p>所以这个时候我们需要做的就是reinstall（注，也就是将log中的block再次写入到文件系统），再clean log。</p>
<p>这里的方法之所以能起作用，是因为可以确保当发生crash（并重启之后），我们要么将写操作所有相关的block都在文件系统中更新了，要么没有更新任何一个block，我们永远也不会只写了一部分block。</p>
<p>为什么可以确保呢？我们考虑crash的几种可能情况。</p>
<ul>
<li>
<p>在第1步和第2步之间crash会发生什么？</p>
<p>在重启的时候什么也不会做，就像系统调用从没有发生过一样，也像crash是在文件系统调用之前发生的一样。这完全可以，并且也是可接受的。</p>
</li>
<li>
<p>在第2步和第3步之间crash会发生什么？</p>
<p>在这个时间点，所有的log block都落盘了，因为有commit记录，所以完整的文件系统操作必然已经完成了。我们可以将log block写入到文件系统中相应的位置，这样也不会破坏文件系统。所以这种情况就像系统调用正好在crash之前就完成了。</p>
</li>
<li>
<p>在install（第3步）过程中和第4步之前这段时间crash会发生什么？</p>
<p>在下次重启的时候，我们会redo log，我们或许会再次将log block中的数据再次拷贝到文件系统。这样也是没问题的，因为log中的数据是固定的，我们就算重复写了文件系统，每次写入的数据也是不变的。</p>
<p>重复写入并没有任何坏处，因为我们写入的数据可能本来就在文件系统中，所以多次install log完全没问题。当然在这个时间点，我们不能执行任何文件系统的系统调用。我们应该在重启文件系统之前，在重启或者恢复的过程中完成这里的恢复操作。</p>
<p>换句话说，install log是幂等操作（注，idempotence，表示执行多次和执行一次效果一样），你可以执行任意多次，最后的效果都是一样的。</p>
</li>
</ul>
<blockquote>
<p>学生提问：因为这里的接口只有read/write，但是如果我们做append操作，就不再安全了，对吧？</p>
<p>Frans教授：某种程度来说，append是文件系统层面的操作，在这个层面，我们可以使用上面介绍的logging机制确保其原子性（注，append也可以拆解成底层的read/write）。</p>
<p>学生提问：当正在commit log的时候crash了会发生什么？比如说你想执行多个写操作，但是只commit了一半。</p>
<p>Frans教授：在上面的第2步，执行commit操作时，你只会在记录了所有的write操作之后，才会执行commit操作。所以在执行commit时，所有的write操作必然都在log中。而commit操作本身也有个有趣的问题，它究竟会发生什么？如我在前面指出的，commit操作本身只会写一个block。文件系统通常可以这么假设，单个block或者单个sector的write是原子操作（注，有关block和sector的区别详见14.3）。这里的意思是，如果你执行写操作，要么整个sector都会被写入，要么sector完全不会被修改。所以sector本身永远也不会被部分写入，并且commit的目标sector总是包含了有效的数据。而commit操作本身只是写log的header，如果它成功了只是在commit header中写入log的长度，例如5，这样我们就知道log的长度为5。这时crash并重启，我们就知道需要重新install 5个block的log。如果commit header没能成功写入磁盘，那这里的数值会是0。我们会认为这一次事务并没有发生过。这里本质上是write ahead rule，它表示logging系统在所有的写操作都记录在log中之前，不能install log。</p>
</blockquote>
<p>Logging的实现方式有很多，我这里展示的指示一种非常简单的方案，这个方案中clean log和install log都被推迟了。</p>
<p>接下来我会运行这种非常简单的实现方式，之后在下节课我们会看到更加复杂的logging协议。</p>
<p>不过所有的这些协议都遵循了write ahead rule，也就是说在写入commit记录之前，你需要确保所有的写操作都在log中。</p>
<p>在这个范围内，还有大量设计上的灵活性可以用来设计特定的logging协议。</p>
<p>在XV6中，我们会看到数据有两种状态，是在磁盘上还是在内存中。内存中的数据会在crash或者电力故障之后丢失。</p>
<p>XV6的log结构如往常一样也是极其的简单。</p>
<p>我们在最开始有一个header block，也就是我们的commit record，里面包含了：</p>
<ul>
<li>数字n代表有效的log block的数量</li>
<li>每个log block的实际对应的block编号</li>
</ul>
<p>之后就是log的数据，也就是每个block的数据，依次为bn0对应的block的数据，bn1对应的block的数据以此类推。这就是log中的内容，并且log也不包含其他内容。</p>
<p>当文件系统在运行时，在内存中也有header block的一份拷贝，拷贝中也包含了n和block编号的数组。</p>
<p>这里的block编号数组就是log数据对应的实际block编号，并且相应的block也会缓存在block cache中，这个在Lec14有介绍过。</p>
<p>与前一节课对应，log中第一个block编号是45，那么在block cache的某个位置，也会有block 45的cache。</p>
<h2 id="log_write函数">log_write函数
</h2><p>接下来让我们看一些代码来帮助我们理解这里是怎么工作的。</p>
<p>前面我提过事务（transaction），也就是我们不应该在所有的写操作完成之前写入commit record。</p>
<p>这意味着文件系统操作必须表明事务的开始和结束。</p>
<p>在XV6中，以创建文件的sys_open为例（在sysfile.c文件中）每个文件系统操作，都有begin_op和end_op分别表示事物的开始和结束。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">uint64</span>
</span></span><span class="line"><span class="cl"><span class="nf">sys_open</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">path</span><span class="p">[</span><span class="n">MAXPATH</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">omode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="nf">argstr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">MAXPATH</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nf">argint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">omode</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">begin_op</span><span class="p">();</span><span class="c1">//THIS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">omode</span> <span class="o">&amp;</span> <span class="n">O_CREATE</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">ip</span> <span class="o">=</span> <span class="nf">create</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">T_FILE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">ip</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="nf">end_op</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">((</span><span class="n">ip</span> <span class="o">=</span> <span class="nf">namei</span><span class="p">(</span><span class="n">path</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="nf">end_op</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">T_DIR</span> <span class="o">&amp;&amp;</span> <span class="n">omode</span> <span class="o">!=</span> <span class="n">O_RDONLY</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="nf">iunlockput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nf">end_op</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">T_DEVICE</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">major</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">major</span> <span class="o">&gt;=</span> <span class="n">NDEV</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">iunlockput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">end_op</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">((</span><span class="n">f</span> <span class="o">=</span> <span class="nf">filealloc</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="n">fd</span> <span class="o">=</span> <span class="nf">fdalloc</span><span class="p">(</span><span class="n">f</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nf">fileclose</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">iunlockput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">end_op</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">T_DEVICE</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">f</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">FD_DEVICE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">f</span><span class="o">-&gt;</span><span class="n">major</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">major</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">f</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">FD_INODE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">f</span><span class="o">-&gt;</span><span class="n">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">f</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">f</span><span class="o">-&gt;</span><span class="n">readable</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">omode</span> <span class="o">&amp;</span> <span class="n">O_WRONLY</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">f</span><span class="o">-&gt;</span><span class="n">writable</span> <span class="o">=</span> <span class="p">(</span><span class="n">omode</span> <span class="o">&amp;</span> <span class="n">O_WRONLY</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">omode</span> <span class="o">&amp;</span> <span class="n">O_RDWR</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">((</span><span class="n">omode</span> <span class="o">&amp;</span> <span class="n">O_TRUNC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">T_FILE</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">itrunc</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">end_op</span><span class="p">();</span><span class="c1">//THIS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>begin_op表明想要开始一个事务，在最后有end_op表示事务的结束。</p>
<p>并且事务中的所有写block操作具备原子性，这意味着这些写block操作要么全写入，要么全不写入。</p>
<p>XV6中的文件系统调用都有这样的结构，最开始是begin_op，之后是实现系统调用的代码，最后是end_op。</p>
<p>在end_op中会实现commit操作。</p>
<p>在begin_op和end_op之间，磁盘上或者内存中的数据结构会更新。</p>
<p>但是在end_op之前，并不会有实际的改变（注，也就是不会写入到实际的block中）。</p>
<p>在end_op时，我们会将数据写入到log中，之后再写入commit record或者log header。</p>
<p>这里有趣的是，当文件系统调用执行写磁盘时会发生什么？</p>
<p>让我们看一下fs.c中的ialloc，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// Allocate an inode on device dev.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Mark it as allocated by  giving it type type.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Returns an unlocked but allocated and referenced inode.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="n">inode</span><span class="o">*</span>
</span></span><span class="line"><span class="cl"><span class="nf">ialloc</span><span class="p">(</span><span class="n">uint</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">short</span> <span class="n">type</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">inum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">dinode</span> <span class="o">*</span><span class="n">dip</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="n">inum</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">inum</span> <span class="o">&lt;</span> <span class="n">sb</span><span class="p">.</span><span class="n">ninodes</span><span class="p">;</span> <span class="n">inum</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">bp</span> <span class="o">=</span> <span class="nf">bread</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nf">IBLOCK</span><span class="p">(</span><span class="n">inum</span><span class="p">,</span> <span class="n">sb</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">dip</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dinode</span><span class="o">*</span><span class="p">)</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">inum</span><span class="o">%</span><span class="n">IPB</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>  <span class="c1">// a free inode
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nf">memset</span><span class="p">(</span><span class="n">dip</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dip</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="n">dip</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nf">log_write</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>   <span class="c1">// mark it allocated on the disk
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nf">brelse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nf">iget</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">inum</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">brelse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">panic</span><span class="p">(</span><span class="s">&#34;ialloc: no inodes&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个函数中，并没有直接调用bwrite，这里实际调用的是log_write函数。</p>
<p>log_write是由文件系统的logging实现的方法。</p>
<p>任何一个文件系统调用的begin_op和end_op之间的写操作总是会走到log_write。</p>
<p>log_write函数位于log.c文件，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// Caller has modified b-&gt;data and is done with the buffer.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Record the block number and pin in the cache by increasing refcnt.
</span></span></span><span class="line"><span class="cl"><span class="c1">// commit()/write_log() will do the disk write.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// log_write() replaces bwrite(); a typical use is:
</span></span></span><span class="line"><span class="cl"><span class="c1">//   bp = bread(...)
</span></span></span><span class="line"><span class="cl"><span class="c1">//   modify bp-&gt;data[]
</span></span></span><span class="line"><span class="cl"><span class="c1">//   log_write(bp)
</span></span></span><span class="line"><span class="cl"><span class="c1">//   brelse(bp)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">log_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">LOGSIZE</span> <span class="o">||</span> <span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">log</span><span class="p">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">panic</span><span class="p">(</span><span class="s">&#34;too big a transaction&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">outstanding</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">panic</span><span class="p">(</span><span class="s">&#34;log_write outside of trans&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">blockno</span><span class="p">)</span>   <span class="c1">// log absorbtion
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">blockno</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Add new block to log?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">bpin</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>log_write还是很简单直观的，我们已经向block cache中的某个block写入了数据。</p>
<p>比如写block 45，我们已经更新了block cache中的block 45。</p>
<p>接下来我们需要在内存中记录，在稍后的commit中，要将block 45写入到磁盘的log中。</p>
<p>这里的代码先获取log header的锁，之后再更新log header。</p>
<p>首先代码会查看block 45是否已经被log记录了。</p>
<p>如果是的话，其实不用做任何事情，因为block 45已经会被写入了。</p>
<p>这种忽略的行为称为log absorbtion。</p>
<p>如果block 45不在需要写入到磁盘中的block列表中，接下来会对n加1，并将block 45记录在列表的最后。</p>
<p>之后，这里会通过调用bpin函数将block 45固定在block cache中，我们稍后会介绍为什么要这么做（注，详见15.8）。</p>
<p>以上就是log_write的全部工作了。</p>
<p>任何文件系统调用，如果需要更新block或者说更新block cache中的block，都会将block编号加在这个内存数据中（注，也就是log header在内存中的cache），除非编号已经存在。</p>
<blockquote>
<p>学生提问：这是不是意味着，bwrite不能直接使用？</p>
<p>Frans教授：是的，可以这么认为，文件系统中的所有bwrite都需要被log_write替换。</p>
</blockquote>
<h2 id="end_op函数">end_op函数
</h2><p>位于log.c中的end_op函数中会发生什么？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// called at the end of each FS system call.
</span></span></span><span class="line"><span class="cl"><span class="c1">// commits if this was the last outstanding operation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">end_op</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">do_commit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">log</span><span class="p">.</span><span class="n">outstanding</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">committing</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">panic</span><span class="p">(</span><span class="s">&#34;log.committing&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">outstanding</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">do_commit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">log</span><span class="p">.</span><span class="n">committing</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// begin_op() may be waiting for log space,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// and decrementing log.outstanding has decreased
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// the amount of reserved space.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">do_commit</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// call commit w/o holding locks, since not allowed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// to sleep with locks.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">commit</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">log</span><span class="p">.</span><span class="n">committing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，即使是这么简单的一个文件系统也有一些微秒的复杂之处，代码的最开始就是一些复杂情况的处理（注，15.8有这部分的解释）。</p>
<p>我直接跳到正常且简单情况的代码。在简单情况下，没有其他的文件系统操作正在处理中。</p>
<p>这部分代码非常简单直观，首先调用了commit函数。让我们看一下commit函数的实现，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">commit</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">write_log</span><span class="p">();</span>     <span class="c1">// Write modified blocks from cache to log
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">write_head</span><span class="p">();</span>    <span class="c1">// Write header to disk -- the real commit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">install_trans</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// Now install writes to home locations
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">write_head</span><span class="p">();</span>    <span class="c1">// Erase the transaction from the log
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>commit中有两个操作：</p>
<ul>
<li>
<p>首先是write_log。</p>
<p>这基本上就是将所有存在于内存中的log header中的block编号对应的block，从block cache写入到磁盘上的log区域中（注，也就是将变化先从内存拷贝到log中）。</p>
</li>
<li>
<p>write_head会将内存中的log header写入到磁盘中。</p>
</li>
</ul>
<p>看一下write_log的实现。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// Copy modified blocks from cache to log.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">write_log</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">tail</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tail</span> <span class="o">&lt;</span> <span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span><span class="p">;</span> <span class="n">tail</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="nf">bread</span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="n">log</span><span class="p">.</span><span class="n">start</span><span class="o">+</span><span class="n">tail</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// log block
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">from</span> <span class="o">=</span> <span class="nf">bread</span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">block</span><span class="p">[</span><span class="n">tail</span><span class="p">]);</span> <span class="c1">// cache block
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">memmove</span><span class="p">(</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">BSIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">bwrite</span><span class="p">(</span><span class="n">to</span><span class="p">);</span>  <span class="c1">// write the log
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">brelse</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">brelse</span><span class="p">(</span><span class="n">to</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>函数中依次遍历log中记录的block，并写入到log中。</p>
<p>它首先读出log block，将cache中的block拷贝到log block，最后再将log block写回到磁盘中。</p>
<p>这样可以确保需要写入的block都记录在log中。但是在这个位置，我们还没有commit，现在我们只是将block存放在了log中。</p>
<p>如果我们在这个位置也就是在write_head之前crash了，那么最终的表现就像是transaction从来没有发生过。</p>
<p>接下来看一下write_head函数，我之前将write_head称为commit point。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// Write in-memory log header to disk.
</span></span></span><span class="line"><span class="cl"><span class="c1">// This is the true point at which the
</span></span></span><span class="line"><span class="cl"><span class="c1">// current transaction commits.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">write_head</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="nf">bread</span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="n">log</span><span class="p">.</span><span class="n">start</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">logheader</span> <span class="o">*</span><span class="n">hb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">logheader</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">hb</span><span class="o">-&gt;</span><span class="n">n</span> <span class="o">=</span> <span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">hb</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">bwrite</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">brelse</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>函数也比较直观，首先读取log的header block。</p>
<p>将n拷贝到block中，将所有的block编号拷贝到header的列表中。最后再将header block写回到磁盘。</p>
<p>函数中的倒数第2行，bwrite是实际的commit point吗？如果crash发生在这个bwrite之前，会发生什么？</p>
<p>这时虽然我们写了log的header block，但是数据并没有落盘。</p>
<p>所以crash并重启恢复时，并不会发生任何事情。那crash发生在bwrite之后会发生什么呢？</p>
<p>这时header会写入到磁盘中，当重启恢复相应的文件系统操作会被恢复。在恢复过程的某个时间点，恢复程序可以读到log header并发现比如说有5个log还没有install，恢复程序可以将这5个log拷贝到实际的位置。</p>
<p>所以这里的bwrite就是实际的<strong>commit point</strong>。</p>
<p>在commit point之前，transaction并没有发生，在commit point之后，只要恢复程序正确运行，transaction必然可以完成。</p>
<p>回到commit函数，在commit point之后，就会实际应用transaction。</p>
<p>这里很直观，就是读取log block再查看header这个block属于文件系统中的哪个block，最后再将log block写入到文件系统相应的位置。</p>
<p>让我们看一下install_trans函数，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// Copy committed blocks from log to their home location
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">install_trans</span><span class="p">(</span><span class="kt">int</span> <span class="n">recovering</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">tail</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tail</span> <span class="o">&lt;</span> <span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span><span class="p">;</span> <span class="n">tail</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">lbuf</span> <span class="o">=</span> <span class="nf">bread</span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="n">log</span><span class="p">.</span><span class="n">start</span><span class="o">+</span><span class="n">tail</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// read log block
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">dbuf</span> <span class="o">=</span> <span class="nf">bread</span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">block</span><span class="p">[</span><span class="n">tail</span><span class="p">]);</span> <span class="c1">// read dst
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">memmove</span><span class="p">(</span><span class="n">dbuf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">lbuf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">BSIZE</span><span class="p">);</span>  <span class="c1">// copy block to dst
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">bwrite</span><span class="p">(</span><span class="n">dbuf</span><span class="p">);</span>  <span class="c1">// write dst to disk
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">recovering</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nf">bunpin</span><span class="p">(</span><span class="n">dbuf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">brelse</span><span class="p">(</span><span class="n">lbuf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">brelse</span><span class="p">(</span><span class="n">dbuf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里先读取log block，再读取文件系统对应的block。</p>
<p>将数据从log拷贝到文件系统，最后将文件系统block缓存落盘。</p>
<p>这里实际上就是将block数据从log中拷贝到了实际的文件系统block中。</p>
<p>当然，可能在这里代码的某个位置会出现问题，但是这应该也没问题，因为在恢复的时候，我们会从最开始重新执行过。</p>
<p>在commit函数中，install结束之后，会将log header中的n设置为0，再将log header写回到磁盘中。将n设置为0的效果就是清除log。</p>
<blockquote>
<p>学生提问：install_trans函数在写block的时候，先写的缓存。可不可以优化一下直接写磁盘而不写缓存让代码运行的更快一些？</p>
<p>Frans教授：这里的接口是不太好。你可能会想问反正都要写入新数据，为什么要先读出目标block来。这里的代码肯定还有很多优化空间，但是为了看起来简单我们并没有这么做。</p>
</blockquote>
<p>以上就是commit内容。</p>
<h2 id="file-system-recovering">File system recovering
</h2><p>接下来我们看一下发生在XV6的启动过程中的文件系统的恢复流程。</p>
<p>当系统crash并重启了，在XV6启动过程中做的一件事情就是调用initlog函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">initlog</span><span class="p">(</span><span class="kt">int</span> <span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">superblock</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">logheader</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">BSIZE</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">panic</span><span class="p">(</span><span class="s">&#34;initlog: too big logheader&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">initlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="s">&#34;log&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">log</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">logstart</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">log</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">nlog</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">log</span><span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">recover_from_log</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>initlog基本上就是调用recover_from_log函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">recover_from_log</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">read_head</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="nf">install_trans</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// if committed, copy from log to disk
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">write_head</span><span class="p">();</span> <span class="c1">// clear the log
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>recover_from_log先调用read_head函数从磁盘中读取header，之后调用install_trans函数。</p>
<p>这个函数之前在commit函数中也调用过，它就是读取log header中的n，然后根据n将所有的log block拷贝到文件系统的block中。recover_from_log在最后也会跟之前一样清除log。</p>
<p>这就是恢复的全部流程。</p>
<p>如果我们在install_trans函数中又crash了，也不会有问题，因为之后再重启时，XV6会再次调用initlog函数，再调用recover_from_log来重新install log。</p>
<p>如果我们在commit之前crash了多次，在最终成功commit时，log可能会install多次。</p>
<blockquote>
<p>学生提问：如果一个进程向磁盘写了一些数据，但是在commit之前进程出现了故障，假设故障之后进程退出了，这样会有问题吗？</p>
<p>Frans教授：简单回答是没问题，因此磁盘不会被更新，所以效果就像文件系统操作没有发生过一样。并且进程并不能在故障后恢复，唯一能在故障之后还能保持的是保存在磁盘中的状态。（注，应该是没有理解问题。进程通过write系统调用成功写入的数据，就算在成功落盘之前进程异常退出了，内核还是会写入到磁盘中，前提是内核还在运行。）</p>
</blockquote>
<h2 id="log写磁盘流程">Log写磁盘流程
</h2><p>我已经在bwrite函数中加了一个print语句。</p>
<p>bwrite函数是block cache中实际写磁盘的函数，所以我们将会看到实际写磁盘的记录。</p>
<p>在上节课（Lec 14）我将print语句放在了log_write中，log_write只能代表文件系统操作的记录，并不能代表实际写磁盘的记录。</p>
<p>我们这里会像上节课一样执行echo &ldquo;hi&rdquo; &gt; x，并看一下实际的写磁盘过程。</p>
<p><img src="/p/mit6s08115crash-recovery/p29.png"
	width="248"
	height="604"
	srcset="/p/mit6s08115crash-recovery/p29_hu14027739820400206619.png 480w, /p/mit6s08115crash-recovery/p29_hu4905950303556274497.png 1024w"
	loading="lazy"
	
		alt="p29"
	
	
		class="gallery-image" 
		data-flex-grow="41"
		data-flex-basis="98px"
	
></p>
<p>很明显这里的记录要比只在log_write中记录要长的多。</p>
<p>之前的log_write只有11条记录（注，详见14.5）但是可以看到实际上背后有很多个磁盘写操作，让我们来分别看一下这里的写磁盘操作：</p>
<ul>
<li>
<p>首先是前3行的bwrite 3，4，5。</p>
<p>因为block 3是第一个log data block，所以前3行是在log中记录了3个写操作。这3个写操作都保存在log中，并且会写入到磁盘中的log部分。</p>
</li>
<li>
<p>第4行的bwrite 2。</p>
<p>因为block 2是log的起始位置，也就是log header，所以这条是commit记录。</p>
</li>
<li>
<p>第5，6，7行的bwrite 33，46，32。</p>
<p>这里实际就是将前3行的log data写入到实际的文件系统的block位置，这里实际是install log。</p>
</li>
<li>
<p>第8行的bwrite 2，是清除log（注，也就是将log header中的n设置为0）。</p>
<p>到此为止，完成了实际上的写block 33，46，32这一系列的操作。第一部分是log write，第二部分是install log，每一部分后面还跟着一个更新commit记录（注，也就是commit log和clean log）。</p>
</li>
</ul>
<blockquote>
<p>学生提问：可以从这里的记录找到一次文件操作的begin_op和end_op位置吗？</p>
<p>Frans教授：大概可以知道。我们实际上不知道begin_op的位置，但是所有的文件系统操作都从begin_op开始。更新commit记录必然在end_op中，所以我们可以找到文件系统操作的end_op位置，之后就是begin_op（注，其实这里所有的操作都在end_op中，只需要区分每一次end_op的调用就可以找到begin_op）。</p>
</blockquote>
<p>所以以上就是XV6中文件系统的logging介绍，即使是这么一个简单的logging系统也有一定的复杂度。</p>
<p>这里立刻可以想到的一个问题是，通过观察这些记录，这是一个很有效的实现吗？很明显不是的，因为数据被写了两次。</p>
<p>如果我写一个大文件，我需要在磁盘中将这个大文件写两次。所以这必然不是一个高性能的实现，为了实现Crash safety我们将原本的性能降低了一倍。</p>
<p>当你们去读ext3论文时，你们应该时刻思考如何避免这里的性能降低一倍的问题。</p>
<h2 id="file-system-challenges">File system challenges
</h2><p>前面说到XV6的文件系统有一定的复杂性，接下来我将介绍一下三个复杂的地方或者也可以认为是三个挑战。</p>
<h3 id="第一个是cache-eviction">第一个是cache eviction。
</h3><p>假设transaction还在进行中，我们刚刚更新了block 45，正要更新下一个block，而整个buffer cache都满了并且决定撤回block 45。</p>
<p>在buffer cache中撤回block 45意味着我们需要将其写入到磁盘的block 45位置，这里会不会有问题？如果我们这么做了的话，会破坏什么规则吗？</p>
<p>是的，如果将block 45写入到磁盘之后发生了crash，就会破坏transaction的原子性。</p>
<p>这里也破坏了前面说过的write ahead rule，write ahead rule的含义是，你需要先将所有的block写入到log中，之后才能实际的更新文件系统block。</p>
<p>所以buffer cache不能撤回任何还位于log的block。</p>
<p>前面在介绍log_write函数时，其中调用了一个叫做bpin的函数，这个函数的作用就如它的名字一样，将block固定在buffer cache中。</p>
<p>它是通过给block cache增加引用计数来避免cache撤回对应的block。</p>
<p>在之前（注，详见14.6）我们看过，如果引用计数不为0，那么buffer cache是不会撤回block cache的。</p>
<p>相应的在将来的某个时间，所有的数据都写入到了log中，我们可以在cache中unpin block（注，在15.5中的install_trans函数中会有unpin，因为这时block已经写入到了log中）。</p>
<p>所以这是第一个复杂的地方，我们需要pin/unpin buffer cache中的block。</p>
<h3 id="第二个挑战是文件系统操作必须适配log的大小">第二个挑战是，文件系统操作必须适配log的大小。
</h3><p>在XV6中，总共有30个log block（注，详见14.3）。</p>
<p>当然我们可以提升log的尺寸，在真实的文件系统中会有大得多的log空间。</p>
<p>但是无所谓啦，不管log多大，文件系统操作必须能放在log空间中。</p>
<p>如果一个文件系统操作尝试写入超过30个block，那么意味着部分内容需要直接写到文件系统区域，而这是不被允许的，因为这违背了write ahead rule。</p>
<p>所以所有的文件系统操作都必须适配log的大小。</p>
<p>为什么XV6的log大小是30？因为30比任何一个文件系统操作涉及的写操作数都大，Robert和我看了一下所有的文件系统操作，发现都远小于30，所以就将XV6的log大小设为30。</p>
<p>我们目前看过的一些文件系统操作，例如创建一个文件只包含了写5个block。</p>
<p>实际上大部分文件系统操作只会写几个block。</p>
<p>你们可以想到什么样的文件系统操作会写很多很多个block吗？是的，写一个大文件。如果我们调用write系统调用并传入1M字节的数据，这对应了写1000个block，这看起来会有很严重的问题，因为这破坏了我们刚刚说的“文件系统操作必须适配log的大小”这条规则。</p>
<p>让我们看一下file.c文件中的file_write函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// Write to file f.
</span></span></span><span class="line"><span class="cl"><span class="c1">// addr is a user virtual address.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="nf">filewrite</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">writable</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">FD_PIPE</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="o">=</span> <span class="nf">pipewrite</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">FD_DEVICE</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">major</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">major</span> <span class="o">&gt;=</span> <span class="n">NDEV</span> <span class="o">||</span> <span class="o">!</span><span class="n">devsw</span><span class="p">[</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">major</span><span class="p">].</span><span class="n">write</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="o">=</span> <span class="n">devsw</span><span class="p">[</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">major</span><span class="p">].</span><span class="nf">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">FD_INODE</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// write a few blocks at a time to avoid exceeding
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// the maximum log transaction size, including
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// i-node, indirect block, allocation blocks,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// and 2 blocks of slop for non-aligned writes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// this really belongs lower down, since writei()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// might be writing a device like the console.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="p">((</span><span class="n">MAXOPBLOCKS</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">BSIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span><span class="n">n1</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">n1</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="nf">begin_op</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="nf">ilock</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="nf">writei</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">off</span><span class="p">,</span> <span class="n">n1</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">f</span><span class="o">-&gt;</span><span class="n">off</span> <span class="o">+=</span> <span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nf">iunlock</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nf">end_op</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="n">n1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// error from writei
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="n">i</span> <span class="o">+=</span> <span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">n</span> <span class="o">?</span> <span class="nl">n</span> <span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">panic</span><span class="p">(</span><span class="s">&#34;filewrite&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从这段代码可以看出，如果写入的block数超过了30，那么一个写操作会被分割成多个小一些的写操作。</p>
<p>这里整个写操作不是原子的，但是这还好，因为write系统调用的语义并不要求所有1000个block都是原子的写入，它只要求我们不要损坏文件系统。</p>
<p>所以XV6会将一个大的写操作分割成多个小的写操作，每一个小的写操作通过独立的transaction写入。这样文件系统本身不会陷入不正确的状态中。</p>
<p>这里还需要注意，因为block在落盘之前需要在cache中pin住，所以buffer cache的尺寸也要大于log的尺寸。</p>
<h3 id="最后一个挑战是并发文件系统调用">最后一个挑战是并发文件系统调用。
</h3><p>让我先来解释一下这里会有什么问题，再看对应的解决方案。</p>
<p>假设我们有一段log，和两个并发的执行的transaction，其中transaction t0在log的前半段记录，transaction t1在log的后半段记录。可能我们用完了log空间，但是任何一个transaction都还没完成。</p>
<p>现在我们能提交任何一个transaction吗？我们不能，因为这样的话我们就提交了一个部分完成的transaction，这违背了write ahead rule，log本身也没有起到应该的作用。</p>
<p>所以必须要保证多个并发transaction加在一起也适配log的大小。</p>
<p>所以当我们还没有完成一个文件系统操作时，我们必须在确保可能写入的总的log数小于log区域的大小的前提下，才允许另一个文件系统操作开始。</p>
<p>XV6通过限制并发文件系统操作的个数来实现这一点。</p>
<p>在begin_op中，我们会检查当前有多少个文件系统操作正在进行。</p>
<p>如果有太多正在进行的文件系统操作，我们会通过sleep停止当前文件系统操作的运行，并等待所有其他所有的文件系统操作都执行完并commit之后再唤醒。</p>
<p>这里的其他所有文件系统操作都会一起commit。</p>
<p>有的时候这被称为group commit，因为这里将多个操作像一个大的transaction一样提交了，这里的多个操作要么全部发生了，要么全部没有发生。</p>
<blockquote>
<p>学生提问：group commit有必要吗？不能当一个文件系统操作结束的时候就commit掉，然后再commit其他的操作吗？</p>
<p>Frans教授：如果这样的话你需要非常非常小心。因为有一点我没有说得很清楚，我们需要保证write系统调用的顺序。如果一个read看到了一个write，再执行了一次write，那么第二个write必须要发生在第一个write之后。在log中的顺序，本身就反应了write系统调用的顺序，你不能改变log中write系统调用的执行顺序，因为这可能会导致对用户程序可见的奇怪的行为。所以必须以transaction发生的顺序commit它们，而一次性提交所有的操作总是比较安全的，这可以保证文件系统处于一个好的状态。</p>
</blockquote>
<p>最后我们再回到最开始，看一下begin_op，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// called at the start of each FS system call.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">begin_op</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">committing</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="nf">sleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span> <span class="o">+</span> <span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">outstanding</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">MAXOPBLOCKS</span> <span class="o">&gt;</span> <span class="n">LOGSIZE</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// this op might exhaust log space; wait for commit.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nf">sleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">log</span><span class="p">.</span><span class="n">outstanding</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>首先，如果log正在commit过程中，那么就等到log提交完成，因为我们不能在install log的过程中写log；</p>
<p>其次，如果当前操作是允许并发的操作个数的后一个，那么当前操作可能会超过log区域的大小，我们也需要sleep并等待所有之前的操作结束；</p>
<p>最后，如果当前操作可以继续执行，需要将log的outstanding字段加1，最后再退出函数并执行文件系统操作。</p>
<p>再次看一下end_op函数，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// called at the end of each FS system call.
</span></span></span><span class="line"><span class="cl"><span class="c1">// commits if this was the last outstanding operation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">end_op</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">do_commit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">log</span><span class="p">.</span><span class="n">outstanding</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">committing</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">panic</span><span class="p">(</span><span class="s">&#34;log.committing&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">outstanding</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">do_commit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">log</span><span class="p">.</span><span class="n">committing</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// begin_op() may be waiting for log space,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// and decrementing log.outstanding has decreased
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// the amount of reserved space.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">do_commit</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// call commit w/o holding locks, since not allowed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// to sleep with locks.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">commit</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">log</span><span class="p">.</span><span class="n">committing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在最开始首先会对log的outstanding字段减1，因为一个transaction正在结束；</p>
<p>其次检查committing状态，当前不可能在committing状态，所以如果是的话会触发panic；</p>
<p>如果当前操作是整个并发操作的最后一个的话（log.outstanding == 0），接下来立刻就会执行commit；</p>
<p>如果当前操作不是整个并发操作的最后一个的话，我们需要唤醒在begin_op中sleep的操作，让它们检查是不是能运行。</p>
<p>（注，这里的outstanding有点迷，它表示的是当前正在并发执行的文件系统操作的个数，MAXOPBLOCKS定义了一个操作最大可能涉及的block数量。在begin_op中，只要log空间还足够，就可以一直增加并发执行的文件系统操作。所以XV6是通过设定了MAXOPBLOCKS，再间接的限定支持的并发文件系统操作的个数）</p>
<p>所以，即使是XV6中这样一个简单的文件系统，也有一些复杂性和挑战。</p>
<p>最后让我总结一下：</p>
<p>这节课讨论的是使用logging来解决crash safety或者说多个步骤的文件系统操作的安全性。这种方式对于安全性来说没有问题，但是性能不咋地。</p>
<blockquote>
<p>学生提问：前面说到cache size至少要跟log size一样大，如果它们一样大的话，并且log pin了30个block，其他操作就不能再进行了，因为buffer中没有额外的空间了。</p>
<p>Frans教授：如果buffer cache中没有空间了，XV6会直接panic。这并不理想，实际上有点恐怖。所以我们在挑选buffer cache size的时候希望用一个不太可能导致这里问题的数字。这里为什么不能直接返回错误，而是要panic？因为很多文件系统操作都是多个步骤的操作，假设我们执行了两个write操作，但是第三个write操作找不到可用的cache空间，那么第三个操作无法完成，我们不能就直接返回错误，因为我们可能已经更新了一个目录的某个部分，为了保证文件系统的正确性，我们需要撤回之前的更新。所以如果log pin了30个block，并且buffer cache没有额外的空间了，会直接panic。当然这种情况不太会发生，只有一些极端情况才会发生。</p>
</blockquote>

</section>


    <footer class="article-footer">
    

    <section class="article-lastmod">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <span>
            最后更新于 Nov 12, 2024 23:44 &#43;0800
        </span>
    </section></footer>




    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI&#43;WdtXRGWt2kTvGFasHpSy3SV"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG&#43;vnGctmUb0ZY0l8"crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05"crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.body, {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>
    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="has-image">
    <a href="/p/mit6s08123rcu/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08123rcu/bg.91a08bf3fe0a8ca435e8fbc902291fd5_hu4589796922609635382.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：23RCU"
                        
                        data-hash="md5-kaCL8/4KjKQ16PvJAikf1Q==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：23RCU</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/mit6s08122meltdown/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08122meltdown/19.8d880549dccba2f0c1613b3e41a721e5_hu3753156070077914420.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：22Meltdown"
                        
                        data-hash="md5-jYgFSdzLovDBYTs&#43;Qach5Q==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：22Meltdown</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/mit6s08121networking/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08121networking/bg.68c4376fd87b0b35da07319dd155c90d_hu10351534106733688476.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：21Networking"
                        
                        data-hash="md5-aMQ3b9h7CzXaBzGd0VXJDQ==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：21Networking</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/mit6s08120kernels-and-hll/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08120kernels-and-hll/bg.4175e6a2793e0fc340e5aced2529e40b_hu6405785273338381617.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：20Kernels and HLL"
                        
                        data-hash="md5-QXXmonk&#43;D8NA5aztJSnkCw==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：20Kernels and HLL</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/mit6s08119virtual-machines/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08119virtual-machines/bg.b02a7ba1d946705c0cf2809bcf960db8_hu14546491865979434532.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：19Virtual Machines  "
                        
                        data-hash="md5-sCp7odlGcFwM8oCbz5YNuA==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：19Virtual Machines  </h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    

    <footer class="site-footer">

    <section class="copyright">
        &copy; 
        
        2024 echudet
    </section>
    
    <section class="powerby">
        


        <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>

        <script language="javascript"> 
            var now = new Date();
            function createtime(){
                now.setTime(now.getTime()+250);
                var grt= new Date("2024/11/10 00:00:00"); 
                days = (now - grt ) / 1000 / 60 / 60 / 24;
                dnum = Math.floor(days);
                hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
                hnum = Math.floor(hours);
                if(String(hnum).length ==1 ){hnum = "0" + hnum;}
                minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
                mnum = Math.floor(minutes);
                if(String(mnum).length ==1 ){mnum = "0" + mnum;}
                seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
                snum = Math.round(seconds);
                if(String(snum).length ==1 ){snum = "0" + snum;}

                document.getElementById("timeDate").innerHTML = "本站已稳定运行"+dnum+" 天 ";
                document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒<br>"
            }
            setInterval("createtime()",250); 
        </script> 

        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        
    
        
         
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
        

        共 572699 字 , 25 篇文章<br>使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.29.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>

</footer>



    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>


    </body>
</html>
