<!DOCTYPE html>
<html lang="en-us" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="Meltdown漏洞破坏了这种隔离机制，使攻击者能够访问内核内存。这一漏洞不依赖操作系统或软件漏洞，而是通过利用处理器硬件特性来实施攻击。这一漏洞广泛影响了个人计算机、云服务器中的虚拟机等设备。">
<title>MIT6S081：22Meltdown</title>

<link rel='canonical' href='https://echudet.github.io/p/mit6s08122meltdown/'>

<link rel="stylesheet" href="/scss/style.min.209f2315995b57a9cdd733e5afe32e05ebb1138a0b3bb750cfcb86dff885e546.css"><meta property='og:title' content="MIT6S081：22Meltdown">
<meta property='og:description' content="Meltdown漏洞破坏了这种隔离机制，使攻击者能够访问内核内存。这一漏洞不依赖操作系统或软件漏洞，而是通过利用处理器硬件特性来实施攻击。这一漏洞广泛影响了个人计算机、云服务器中的虚拟机等设备。">
<meta property='og:url' content='https://echudet.github.io/p/mit6s08122meltdown/'>
<meta property='og:site_name' content='echudet'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2024-10-07T22:02:50&#43;08:00'/><meta property='article:modified_time' content='2025-09-03T22:10:01&#43;08:00'/><meta property='og:image' content='https://echudet.github.io/p/mit6s08122meltdown/19.jpg' />
<meta name="twitter:title" content="MIT6S081：22Meltdown">
<meta name="twitter:description" content="Meltdown漏洞破坏了这种隔离机制，使攻击者能够访问内核内存。这一漏洞不依赖操作系统或软件漏洞，而是通过利用处理器硬件特性来实施攻击。这一漏洞广泛影响了个人计算机、云服务器中的虚拟机等设备。"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://echudet.github.io/p/mit6s08122meltdown/19.jpg' />
    <link rel="shortcut icon" href="/timer.ico" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu_c2920364e6534697.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">⌨️</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">echudet</a></h1>
            <h2 class="site-description">探索编程的学生一枚</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/EchudeT'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://twitter.com'
                        target="_blank"
                        title="Twitter"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>档案</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>Links</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#课前预习">课前预习</a></li>
    <li><a href="#论文速览">论文速览</a></li>
    <li><a href="#侧信道攻击side-channel-attack">侧信道攻击（Side-Channel Attack）</a></li>
    <li><a href="#meltdown--侧信道攻击-的完整过程">Meltdown + 侧信道攻击 的完整过程</a></li>
    <li><a href="#数据读取过程微架构状态如何转换为架构状态">数据读取过程（微架构状态如何转换为架构状态）</a></li>
    <li><a href="#预测执行">预测执行</a></li>
    <li><a href="#flushreload">Flush+Reload</a></li>
    <li><a href="#flushreload-查询对象">Flush+Reload 查询对象</a></li>
    <li><a href="#缓存未命中复习">缓存未命中复习</a></li>
    <li><a href="#meltdown-的-异常-0-值">Meltdown 的 异常 0 值</a></li>
    <li><a href="#区分内核值-0-与异常-0">区分内核值 <code>0</code> 与异常 <code>0</code></a></li>
    <li><a href="#meltdown调整内存值大小">Meltdown调整内存值大小</a></li>
    <li><a href="#kaiser">KAISER</a></li>
    <li><a href="#memory-type-range-registers-mtrrs">Memory-Type Range Registers (MTRRs)</a></li>
    <li><a href="#microarchitectural-state-和-architectural-state">Microarchitectural state 和 architectural state</a></li>
    <li><a href="#正课部分">正课部分</a></li>
    <li><a href="#meltdown发生的背景">Meltdown发生的背景</a></li>
    <li><a href="#speculative-execution1">Speculative execution(1)</a></li>
    <li><a href="#speculative-execution2">Speculative execution(2)</a></li>
    <li><a href="#cpu-caches">CPU caches</a></li>
    <li><a href="#flush-and-reload">Flush and Reload</a></li>
    <li><a href="#meltdown-attack">Meltdown Attack</a></li>
    <li><a href="#meltdown-fix">Meltdown Fix</a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/mit6s08122meltdown/">
                <img src="/p/mit6s08122meltdown/19_hu_bd238d0bd4ea8de8.jpg"
                        srcset="/p/mit6s08122meltdown/19_hu_bd238d0bd4ea8de8.jpg 800w, /p/mit6s08122meltdown/19_hu_987bd40a9e1ddbaf.jpg 1600w"
                        width="800" 
                        height="500" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：22Meltdown" />
                
            </a>
        </div>
    

    <div class="article-details">


    
    <header class="article-category">
        
            <a href="/categories/mit6s081/" >
                Mit6s081
            </a>
        
            <a href="/categories/os/" >
                Os
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/mit6s08122meltdown/">MIT6S081：22Meltdown</a>
        </h2>
    
        
        <h3 class="article-subtitle">
            Meltdown漏洞破坏了这种隔离机制，使攻击者能够访问内核内存。这一漏洞不依赖操作系统或软件漏洞，而是通过利用处理器硬件特性来实施攻击。这一漏洞广泛影响了个人计算机、云服务器中的虚拟机等设备。
        </h3>
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2024-10-07</time>
            </div>
        

        
            <div>
                <?xml version="1.0" encoding="iso-8859-1"?>
<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="792px" height="792px" viewBox="0 0 792 792" style="enable-background:new 0 0 792 792;" xml:space="preserve">
<g>
	<g id="_x31_0_19_">
		<g>
			<path d="M643.5,742.5H594V569.25C594,473.566,516.434,396,420.75,396C516.434,396,594,318.434,594,222.75V49.5h49.5
				c13.662,0,24.75-11.088,24.75-24.75S657.162,0,643.5,0h-495c-13.662,0-24.75,11.088-24.75,24.75S134.838,49.5,148.5,49.5H198
				v173.25C198,318.434,275.566,396,371.25,396C275.566,396,198,473.566,198,569.25V742.5h-49.5c-13.662,0-24.75,11.088-24.75,24.75
				S134.838,792,148.5,792h495c13.662,0,24.75-11.088,24.75-24.75S657.162,742.5,643.5,742.5z M247.5,222.75
				c0-43.387,0-173.25,0-173.25h297c0,0,0,133.427,0,173.25c0,68.335-58.188,123.75-129.938,123.75h-37.125
				C305.687,346.5,247.5,291.085,247.5,222.75z M544.5,742.5h-297c0,0,0-129.888,0-173.25c0-68.335,58.187-123.75,129.938-123.75
				h37.125c71.75,0,129.938,55.415,129.938,123.75C544.5,609.072,544.5,742.5,544.5,742.5z"/>
		</g>
	</g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
</svg>

                <time class="article-time--reading">
                    阅读时长: 76 分钟
                </time>
            </div>
        

         
        <div>
            <?xml version="1.0" encoding="iso-8859-1"?>
<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="79.536px" height="79.536px" viewBox="0 0 79.536 79.536" style="enable-background:new 0 0 79.536 79.536;"
	 xml:space="preserve">
<g>
	<path style="fill:#010002;" d="M40.162,17.906C37.415,15.275,21.614,6.141,0,15.451c0,0.138,0,2.722,0,6.654v44.418h32.747
		c1.126,0.968,3.798,1.651,6.926,1.651c3.119,0,5.802-0.684,6.931-1.651h32.933V22.105c0-3.933,0-6.517,0-6.654
		C58.813,6.314,42.257,15.982,40.162,17.906z M37.229,63.349c0-1.75-15.372-11.981-33.125-0.818V19.216
		c3.516-2.014,8.246-3.249,13.463-3.249c10.864,0,19.662,3.562,19.662,10.175V63.349z M75.684,62.53
		c-17.751-11.163-33.108-0.932-33.108,0.818V26.146c0-6.612,8.792-10.175,19.646-10.175c5.22,0,9.952,1.235,13.463,3.249V62.53z"/>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
</svg>

            <time class="article-words">
                文章字数：37774字
            </time>
        </div>
        <div class="article-lastmod">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time>
                    Sep 03, 2025 22:10 &#43;0800
                </time>
            </div></footer>
    

    




    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="lecture-22-meltdown">Lecture 22 Meltdown
</h1><h2 id="课前预习">课前预习
</h2><h2 id="论文速览">论文速览
</h2><p><a class="link" href="https://pdos.csail.mit.edu/6.828/2020/readings/meltdown.pdf"  target="_blank" rel="noopener"
    >论文链接</a>

</p>
<p><strong>摘要部分</strong>概述了Meltdown漏洞的关键概念。Meltdown利用现代处理器的乱序执行特性来从用户空间读取内核内存数据。它不依赖于任何软件漏洞，而是利用硬件层面的设计缺陷。这一漏洞广泛影响了个人计算机、云服务器中的虚拟机等设备。文章还特别提到KAISER防御机制在阻止Meltdown方面的意外效果。漏洞的严重性在于，它打破了内存隔离的安全保证，使攻击者能够读取其他进程或虚拟机的内存。</p>
<p><strong>引言部分</strong>深入讨论了现代操作系统中内存隔离的重要性，特别是用户进程和内核之间的隔离。文章指出，Meltdown漏洞破坏了这种隔离机制，使攻击者能够访问内核内存。这一漏洞不依赖操作系统或软件漏洞，而是通过利用处理器硬件特性来实施攻击。引言还强调了Meltdown可以在不需要权限的情况下读取敏感数据，这对个人计算机用户和云计算环境中的用户都构成了重大威胁。</p>
<p><strong>背景部分</strong>介绍了Meltdown攻击所依赖的关键技术，包括乱序执行、地址翻译和缓存攻击。乱序执行是现代处理器的性能优化机制，它允许CPU提前执行指令以提高效率，然而这种执行方式会带来缓存的副作用，成为信息泄露的基础。地址翻译部分解释了虚拟地址如何映射到物理地址，并描述了内核地址如何与用户空间隔离。缓存攻击则涉及利用缓存的时序差异来推断内存中的数据。</p>
<p><strong>玩具示例</strong>提供了一个简单的代码示例，用以演示乱序执行如何通过缓存的副作用泄露数据。代码中，虽然某些指令会由于异常而未实际执行，但其带来的缓存变化仍然能够被利用来推测数据。这一部分的核心在于展示了即使未完成的指令也可能对微架构状态产生影响，而这正是Meltdown攻击的基础。</p>
<p><strong>攻击组成部分</strong>描述了Meltdown的两个主要组成部分。首先是“瞬态指令”的执行，这些指令是由于乱序执行而提前执行的，尽管它们在架构层面上没有影响，但它们可以通过微架构层次泄露数据。其次是通过隐蔽通道将泄露的信息传递到外部世界。文章详细解释了如何通过这些瞬态指令访问和泄露内核中的数据。</p>
<p><strong>Meltdown攻击部分</strong>具体介绍了如何在实际系统中实施攻击。通过利用乱序执行，攻击者可以访问操作系统的内核内存，包括敏感的用户数据、密码等。Meltdown能够在多种操作系统上进行攻击，包括Linux、Windows和Android。文中还描述了在这些系统中读取整个物理内存的方法，并讨论了攻击的速度和成功率。</p>
<p><strong>评估部分</strong>通过实验验证了Meltdown的攻击效果。实验在不同的硬件平台上进行了攻击测试，结果表明攻击的成功率和速度与缓存状态密切相关。评估数据展示了在最佳情况下，攻击者可以以数百KB每秒的速度读取内核内存数据，并且攻击在不同操作系统上的表现也有所不同。</p>
<p><strong>局限性部分</strong>讨论了Meltdown在ARM和AMD处理器上的效果。虽然Meltdown能够在大多数Intel处理器上成功运行，但在某些ARM和AMD架构上，Meltdown无法被复现。文章推测这是由于这些处理器在处理权限检查和内存访问时的不同实现方式所致。</p>
<p><strong>防御措施部分</strong>概述了针对Meltdown的可能防御手段。主要提到了通过硬件和软件改进来阻止攻击的方式。硬件设计的改变可以有效阻止此类漏洞的再次出现，例如通过严格的内存访问权限检查。文章特别提到，KAISER补丁是目前最有效的短期解决方案，因为它阻止了攻击者访问内核内存。</p>
<p><strong>相关工作部分</strong>回顾了与Meltdown相关的研究，包括之前的缓存侧信道攻击和推测执行攻击。文中强调了Meltdown与这些攻击的区别，并说明了Meltdown在攻击范围和成功率上的独特之处。</p>
<p><strong>结论部分</strong>总结了Meltdown漏洞对现代计算系统的严重威胁，并呼吁立即采取防御措施，特别是部署KAISER补丁。文章还指出，长期的解决方案可能需要从硬件设计的角度进行修复，以防止未来类似漏洞的产生。</p>
<hr>
<h2 id="侧信道攻击side-channel-attack">侧信道攻击（Side-Channel Attack）
</h2><p><strong>侧信道攻击</strong>（Side-Channel Attack）是一类通过分析计算机系统中硬件、软件执行时产生的<strong>物理信息或微观行为特征</strong>来获取敏感信息的攻击手段，而不是通过传统的软件漏洞或直接的破解加密算法等方式进行攻击。侧信道攻击通常利用处理器执行时的<strong>时序、功耗、电磁辐射、缓存访问行为</strong>等外部特征来推测出某些敏感数据。</p>
<p>在论文中，讨论的是<strong>乱序处理器（out-of-order processor）<strong>的</strong>缓存侧信道攻击</strong>，并且是与<strong>Meltdown</strong>漏洞相关。这涉及到现代处理器中复杂的<strong>执行优化技术</strong>，以及这些技术在某些极端情况下可能暴露的信息安全隐患。</p>
<p><strong>Meltdown 漏洞</strong>是什么？<strong>Meltdown</strong> 是在 2018 年公开的一类严重的硬件漏洞，主要影响英特尔的处理器（也有部分 AMD 和 ARM 处理器）。该漏洞利用了现代处理器的<strong>乱序执行</strong>机制，允许攻击者在未授权的情况下读取内核空间或其他进程中的敏感数据。</p>
<p><strong>乱序执行</strong>是处理器为了提高性能，提前执行一些看似可以立即进行的指令，即使这些指令的前置条件（如内存访问权限检查）还未完成。而 Meltdown 恰恰利用了这个特性：虽然最终系统会撤销未经授权的操作，但在执行期间，数据可能已经进入了处理器的<strong>缓存</strong>中，从而留下痕迹。</p>
<p><strong>缓存侧信道攻击</strong>是什么？侧信道攻击常与<strong>缓存</strong>的行为密切相关。缓存是一种快速存取的数据存储区域，存放处理器频繁访问的数据。不同级别的缓存（L1、L2、L3）会极大地影响程序的执行效率和数据访问时延。</p>
<p>在 Meltdown 攻击中，攻击者利用乱序执行机制，通过分析内存访问时引发的缓存行为，泄露出敏感信息。具体来说，缓存侧信道攻击可以通过<strong>缓存命中与失效的时序差异</strong>来判断某些内存单元是否已被访问（即是否已加载到缓存中）。这可以通过类似于<strong>Flush+Reload</strong>或<strong>Prime+Probe</strong>这样的攻击技术实现：</p>
<ul>
<li><strong>Flush+Reload</strong>：攻击者使用 <code>clflush</code> 指令清空特定的缓存行，然后观察该缓存行的加载时延。如果攻击目标的某个内存地址被加载回缓存，攻击者通过时延测量可以推断出相关数据。</li>
<li><strong>Prime+Probe</strong>：攻击者在缓存中占据一定的空间，然后测量其他程序对该缓存区域的影响，进而推测程序行为。</li>
</ul>
<p>Meltdown 漏洞与缓存侧信道攻击的<strong>结合</strong>非常关键。Meltdown 攻击本质上是通过乱序执行让处理器提前访问到<strong>本不应被访问</strong>的数据，虽然这些数据无法直接被读取或使用，但它们会短暂存储在缓存中。然后，攻击者可以通过侧信道分析技术（如缓存时序分析）推测出这些数据。</p>
<p>例如，攻击者在利用 Meltdown 读取未经授权的内核空间数据时，可以在数据进入缓存后，使用<strong>缓存时序分析</strong>来判断访问了哪些内存地址，以及这些地址存放了什么数据。</p>
<p>所以，在论文讨论的<strong>对乱序处理器缓存进行侧信道攻击</strong>，是在描述一种通过缓存行为监控的方式，利用处理器在乱序执行过程中暴露的安全漏洞（如 Meltdown），从而窃取敏感数据的攻击手段。</p>
<p>这种攻击方式的流程可能如下：</p>
<ol>
<li>攻击者诱使处理器触发乱序执行。</li>
<li>在处理器访问未经授权的内核空间或其他进程的数据时，这些数据会暂时存入缓存中。</li>
<li>攻击者通过缓存侧信道技术（如 Flush+Reload 或 Prime+Probe）分析缓存行为，获取敏感数据的相关信息。</li>
</ol>
<p>这种类型的攻击利用了硬件的特性（如乱序执行、缓存行为）以及微架构中的信息泄漏漏洞，超越了传统的安全模型，因此在公开时引发了广泛的关注和讨论。</p>
<hr>
<h2 id="meltdown--侧信道攻击-的完整过程">Meltdown + 侧信道攻击 的完整过程
</h2><p>从攻击的准备开始，逐步展示攻击者是如何利用处理器的<strong>乱序执行</strong>特性、缓存行为以及侧信道分析来泄露内核或其他敏感数据的。</p>
<ol>
<li>
<p><strong>攻击准备：隔离的内存空间</strong></p>
<p>在现代操作系统中，用户进程和内核空间（包括操作系统的关键数据和其他进程的内存）是隔离的。通常情况下，用户进程不能直接访问内核空间的数据，因为这种访问会触发<strong>页面故障</strong>（page fault）并**作系统阻止。</p>
<p>但是，Meltdown 攻击利用处理器的<strong>乱序执行</strong>特性，使得在某些情况下，即使内核数据不应被用户态进程访问，处理器仍可能提前执行读取内核内存的指令——即使最终这些指令会因为权限问题被回滚。</p>
</li>
<li>
<p><strong>利用乱序执行访问未经授权的内核数据</strong></p>
<p>Meltdown 的核心在于处理器的<strong>乱序执行</strong>机制。乱序执行允许处理器为了优化性能，提前执行一些指令，而不必等待前面的指令完成。例如，当处理器等待较慢的内存访问完成时，它可以提前执行某些后续指令。</p>
<p>在 Meltdown 攻击中，攻击者可以诱使处理器访问属于内核空间的数据，尽管这类访问通常是不被允许的。这可以通过构造如下代码实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">kernel_data</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">kernel_address</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>此代码试图从内核地址 <code>kernel_address</code> 读取数据。尽管内核数据通常不能被用户态程序直接访问，<strong>处理器可能会通过乱序执行提前读取该数据</strong>。但是，一旦处理器发现该读取操作无权限，它将撤销此操作，并触发页面故障异常。但在 Meltdown 攻击中，尽管读取的结果不能被直接使用，<strong>该数据已被暂时存入缓存</strong>中。</p>
</li>
<li>
<p><strong>数据进入缓存，留下痕迹</strong></p>
<p>乱序执行导致的数据被存储到缓存，即使随后这些数据被撤销且处理器不允许访问它们。然而，这些内存访问留下了一个副作用：<strong>数据被加载到了缓存中</strong>。此时，数据的物理内容可能无法被直接访问，但缓存的行为泄露了这些信息。</p>
</li>
<li>
<p><strong>通过缓存侧信道攻击获取数据</strong></p>
<p>接下来，攻击者利用<strong>缓存侧信道技术</strong>，如 <strong>Flush+Reload</strong>，来提取数据。这个步骤关键在于，通过测量<strong>缓存的访问时延</strong>，攻击者可以推测哪些数据已经加载到了缓存中，从而间接推测内核数据。</p>
<p><strong>Flush+Reload 攻击机制的具体步骤</strong>：</p>
<ul>
<li><strong>步骤 1：清空缓存</strong>
攻击者首先使用 <code>clflush</code> 指令清空缓存中的特定内存行。通过清空缓存，攻击者确保之后的访问会重新加载数据到缓存中，从而使得缓存命中与失效的时间差异显著。</li>
<li><strong>步骤 2：诱导乱序执行读取内核数据</strong>
通过前面提到的代码，诱导处理器乱序执行去读取未经授权的内核数据。尽管最终读取会被操作系统阻止，但在短时间内该数据已经被加载到缓存中。</li>
<li><strong>步骤 3：测量时延，推测数据</strong>
攻击者再次尝试访问缓存中被加载的数据，通过测量访问的时间差，可以推测出这些数据是否已经在缓存中。如果数据已经被缓存，访问时间会非常短（命中缓存）；如果数据没有被缓存，访问时间则会显著增加（缓存未命中，需要从内存加载）。通过这种时延分析，攻击者可以逐字节推测内核数据的值。</li>
</ul>
</li>
<li>
<p><strong>整个流程的总结</strong></p>
<p>从上面的步骤可以看出，Meltdown + 侧信道攻击的关键点在于处理器的<strong>乱序执行</strong>和缓存行为。攻击者利用乱序执行机制读取到不应访问的内核数据，并利用缓存时延差异通过侧信道技术来间接推测数据的内容。这个攻击过程分为以下主要阶段：</p>
<ol>
<li><strong>触发乱序执行</strong>：攻击者构造代码，迫使处理器访问未经授权的内核数据。</li>
<li><strong>数据进入缓存</strong>：虽然访问被撤销，但数据暂时存入缓存。</li>
<li><strong>缓存时延分析</strong>：通过 Flush+Reload 等侧信道攻击技术，利用缓存命中与失效的时间差，攻击者间接获取敏感数据。</li>
</ol>
</li>
</ol>
<p><strong>例子：泄露内核空间中的一个字节</strong></p>
<p>假设攻击者想要泄露内核地址 <code>0xFFFF0000</code> 中的数据，该地址包含一个字节的敏感数据。</p>
<ol>
<li>
<p><strong>首先，攻击者清空缓存中的某些内存行</strong>，确保后续缓存行为是可测量的。</p>
</li>
<li>
<p><strong>通过乱序执行读取内核数据</strong>：</p>
<ul>
<li>
<p>攻击者构造代码，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">kernel_data</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="mh">0xFFFF0000</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">array</span><span class="p">[</span><span class="n">kernel_data</span> <span class="o">*</span> <span class="mi">4096</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个操作试图从内核地址读取一个字节，并将其值用于访问一个数组。这段代码会被乱序执行提前处理，而敏感数据会被存入缓存。</p>
</li>
</ul>
</li>
<li>
<p><strong>缓存中的数据被测量</strong>：</p>
<ul>
<li>由于内存访问时敏感数据已经进入缓存，攻击者通过<strong>测量缓存时延</strong>来判断 <code>array[kernel_data * 4096]</code> 是否已经在缓存中。</li>
<li>通过多个猜测，最终可以推断出 <code>kernel_data</code> 的实际值。</li>
</ul>
</li>
</ol>
<p>总而言之，Meltdown 攻击利用了处理器的乱序执行，允许攻击者访问通常无法读取的内核数据，而缓存侧信道攻击则为这些数据的提取提供了有效手段。通过缓存命中和未命中的时延差异，攻击者能够逐步推测出内核空间中的数据，尽管系统本身阻止了未经授权的访问。</p>
<hr>
<h2 id="数据读取过程微架构状态如何转换为架构状态">数据读取过程（微架构状态如何转换为架构状态）
</h2><p>虽然侧信道可以让我们知道缓存的某个位置是否被加载了数据，但<strong>如何从缓存中真正推测出数据的值</strong>似乎还不够清晰。确实，侧信道攻击通过分析缓存访问时延，能够推测哪些数据被缓存，但问题是如何利用这些信息来推断具体的数值。在下面，我将进一步细化这个过程，以解释数据<strong>具体是如何从缓存中读取出来</strong>的。</p>
<p><strong>关键点：使用缓存时延推测数据值</strong></p>
<p><strong>侧信道攻击本质上不是直接读取数据，而是通过缓存行为推测出数据的内容</strong>。在 Meltdown + 侧信道攻击中，缓存的命中或失效是由我们控制的代码触发的，而我们可以利用这个控制来获取敏感数据。</p>
<p>为了更直观地理解，一个具体的例子将详细解释，<strong>如何通过缓存时延分析逐字节提取敏感数据</strong>。</p>
<ol>
<li>
<p><strong>攻击环境准备</strong>，假设攻击者正在尝试通过 Meltdown 漏洞访问内核空间中某个敏感字节的值。为了实现这一目的，攻击者构建如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">kernel_data</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">kernel_address</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">array</span><span class="p">[</span><span class="n">kernel_data</span> <span class="o">*</span> <span class="mi">4096</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p><strong><code>kernel_address</code></strong> 是攻击者试图访问的敏感内核数据的地址。</p>
</li>
<li>
<p><strong><code>array[]</code></strong> 是一个攻击者可控的数组，大小足够大，通常为 256 * 4096 字节，这样可以利用每个缓存行（通常是 64 字节）的不同位置来探测数据。</p>
</li>
</ul>
<p>关键在于 <code>kernel_data</code> 是从内核空间读取的未经授权的数据。虽然处理器最终会拒绝这一访问并触发页面故障（权限不允许访问），但在触发异常之前，<strong>乱序执行</strong>可能已经将数据暂时加载到缓存中，并用于后续的代码执行。</p>
</li>
<li>
<p><strong>使用乱序执行加载数据</strong>，当处理器提前执行这段代码时，<code>kernel_data</code> 的值会用于数组 <code>array[]</code> 的索引计算。即使最终这个操作因为权限问题被撤销，<strong>处理器已经使用了 <code>kernel_data</code> 的值，并将它反映在缓存行为中</strong>。</p>
</li>
<li>
<p><strong>测量缓存时延来推测数据</strong>，关键步骤来了：攻击者如何通过缓存侧信道推测出 <code>kernel_data</code> 的具体值？这就是通过测量缓存时延来完成的，通常使用类似 <strong>Flush+Reload</strong> 或 <strong>Prime+Probe</strong> 技术。以 <strong>Flush+Reload</strong> 为例，具体操作步骤如下：</p>
<ol>
<li>
<p><strong>清空缓存（Flush）</strong>：在执行上述代码之前，攻击者先通过 <code>clflush</code> 指令清空缓存中 <code>array[]</code> 的所有内容。这样可以确保接下来的操作导致的数据访问都会重新加载。</p>
</li>
<li>
<p><strong>执行代码，触发乱序执行</strong>：处理器在运行乱序执行时，提前读取了 <code>kernel_address</code> 并且把这个读取的结果 <code>kernel_data</code> 作为索引用于访问 <code>array[kernel_data * 4096]</code>。此时，虽然实际的 <code>kernel_data</code> 未被攻击者直接读取到，但它的值影响了数组访问的缓存命中。</p>
</li>
<li>
<p><strong>测量时延（Reload）</strong>：代码执行后，攻击者尝试依次访问 <code>array[]</code> 的不同部分（每个间隔 4096 字节），并测量每次访问的时延。由于缓存命中时访问会比缓存失效时更快，攻击者可以通过时延分析发现哪一部分的 <code>array[]</code> 访问速度明显较快。</p>
<ul>
<li>如果某个地址 <code>array[kernel_data * 4096]</code> 的访问非常快（即缓存命中），攻击者就可以推测 <code>kernel_data</code> 的值为该部分的索引。</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>具体例子：<strong>逐字节提取数据</strong>。假设 <code>kernel_address</code> 指向的内存地址包含一个字节的值，例如 <code>0x41</code>（ASCII 对应 &lsquo;A&rsquo;）。此时，<code>kernel_data = 0x41</code>。攻击者通过以下方式逐步推测出 <code>kernel_data</code> 的值：</p>
<ol>
<li>处理器执行代码 <code>array[kernel_data * 4096] = 1;</code>，此时 <code>array[0x41 * 4096]</code> 被访问，导致这部分数据加载到缓存中。</li>
<li>攻击者接着通过 <code>clflush</code> 清除缓存，并开始依次访问 <code>array[0 * 4096], array[1 * 4096], ..., array[255 * 4096]</code>，测量每个访问的时延。</li>
<li>当攻击者访问 <code>array[0x41 * 4096]</code> 时，发现该访问非常快（缓存命中），因此可以推测出 <code>kernel_data = 0x41</code>，即这个字节的值是 <code>0x41</code>。</li>
</ol>
<p>整个攻击过程的核心是：<strong>通过乱序执行使得敏感数据进入缓存，并通过缓存时延分析侧信道技术，间接推测出这些敏感数据的值</strong>。</p>
<p>侧信道分析并不是直接读取缓存中的数据，而是通过控制访问和测量缓存时延，来推测哪些数据在缓存中被命中了，从而一步步推导出 <code>kernel_data</code> 的值。</p>
<p><strong>完整过程回顾</strong></p>
<ol>
<li><strong>诱导乱序执行</strong>：通过访问内核数据并构建某种操作，使得数据暂时存入缓存。</li>
<li><strong>清空缓存</strong>：在测量之前清除缓存，以确保后续时延测量的准确性。</li>
<li><strong>测量缓存时延</strong>：通过访问特定缓存行并测量访问时间差，推测缓存中已命中的数据值。</li>
<li><strong>逐字节推测内核数据</strong>：通过这种方式，可以字节级地推测出敏感数据。</li>
</ol>
<p>通过这种缓存时延分析，Meltdown 能够从无法直接读取的内存区域中逐字节地提取出数据。</p>
<hr>
<h2 id="预测执行">预测执行
</h2><p>为了确保 <strong>预测执行</strong>（或称为<strong>乱序执行</strong>）一定发生，特别是在你提到的<strong>循环中</strong>，可以采取一些策略，这些策略能够诱导处理器执行<strong>提前加载（prefetching）<strong>或</strong>预测性执行</strong>，以提高成功的概率。在详细解释之前，我们先定义一些相关概念：</p>
<ol>
<li>
<p><strong>预测执行与乱序执行</strong></p>
<ul>
<li>
<p><strong>预测执行</strong>（Speculative Execution）是处理器在不确定某个条件是否成立时，提前执行可能需要执行的指令。比如，在条件判断（如 <code>if</code> 或 <code>while</code>）之前，处理器可能会提前执行某些后续的指令，假设条件为真或假。</p>
</li>
<li>
<p><strong>乱序执行</strong>（Out-of-Order Execution）是指处理器根据当前的资源可用性、指令的依赖关系等，提前执行不依赖于当前正在等待的指令的部分操作。这种执行机制有助于提高处理器的吞吐量。</p>
</li>
</ul>
</li>
<li>
<p><strong>如何确保预测执行一定发生</strong>，为了确保预测执行在循环（或其他控制结构）中尽可能发生，可以设计代码，使处理器尽量进入预测执行路径。以下是常用的策略：</p>
<ol>
<li><strong>使用条件分支和预测</strong>，预测执行经常发生在<strong>条件分支</strong>的地方，特别是 <code>if-else</code> 或 <code>switch</code> 语句。处理器通过预测某个条件将会成立（例如分支预测器认为 <code>if</code> 条件为真），进而提前执行某些指令。为了确保预测执行可以发生，你可以故意引入复杂的条件判断：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 关键指令在这里执行
</span></span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这种情况下，处理器会根据历史记录和分支预测算法，决定是否提前执行 <code>if</code> 分支中的代码。你可以通过构造<strong>复杂且动态的条件</strong>，让预测执行变得更加可能。</p>
<ol start="2">
<li><strong>控制指令顺序</strong>，确保代码中有足够多的指令可以并行执行，特别是在循环体中。当前面的指令可能导致内存访问等需要等待的操作时，处理器会试图执行后续的指令。这种环境下，乱序执行也会发生。你可以在循环中引入一些独立的指令，从而确保处理器在等待某些内存访问时，仍然可以预测性地执行其他指令。</li>
</ol>
</li>
<li>
<p><strong>prefetch 的含义</strong>，<strong>Prefetch</strong> 是指<strong>提前加载数据</strong>到缓存中，目的是减少内存访问时的延迟。现代处理器会自动进行预取操作，但程序员也可以手动触发<strong>预取指令</strong>，将将来可能需要的数据提前加载到缓存中。它的主要作用是<strong>提高程序的性能</strong>，避免因访问主内存而产生的高延迟。</p>
<p>在具体操作中，<strong>预取</strong>可以通过硬件自动完成，也可以通过显式的指令实现，比如 <code>__builtin_prefetch()</code>，它允许程序员手动指定要提前加载的数据。这在需要频繁访问大量数据的情况下尤其有用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">__builtin_prefetch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里 <code>&amp;data</code> 是预取的数据地址，<code>0</code> 表示这是只读预取，<code>3</code> 是预取的优先级。通过预取，程序可以在需要数据之前将它加载到缓存中，避免内存访问延迟。</p>
</li>
<li>
<p><strong>如何结合预取与预测执行</strong>，在使用 Meltdown 或其他类似攻击时，如果你希望诱导处理器提前加载某些数据（例如敏感数据）到缓存中，你可以：</p>
<ul>
<li>
<p>利用循环和条件分支来确保乱序执行或预测执行。</p>
</li>
<li>
<p><strong>结合预取</strong>，让处理器将目标内存数据提前加载到缓存中。</p>
</li>
</ul>
<p>例如，你可以在一个循环中使用 <code>__builtin_prefetch()</code> 来让处理器提前加载内核中的某些内存地址。尽管这些内核地址在用户态不允许直接访问，但利用 Meltdown 类漏洞，攻击者可以通过侧信道技术推测它们的内容。</p>
<p>假设你有一个想要预取的内核地址 <code>kernel_address</code>，你可以在循环中手动预取该地址：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">__builtin_prefetch</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">kernel_address</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 后续操作触发缓存侧信道攻击
</span></span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p><strong>总结</strong></p>
<ul>
<li><strong>预测执行</strong>可以通过复杂的条件判断和控制指令顺序来诱发，特别是在循环和分支结构中，它能提高触发 Meltdown 类攻击的可能性。</li>
<li><strong>乱序执行</strong>是处理器自动进行的一种优化，程序设计中可以通过提供独立的操作来诱导它提前执行某些指令。</li>
<li><strong>Prefetch</strong> 是提前将数据加载到缓存的手段，可以手动指定特定的内存地址进行预取，从而在攻击中加快对缓存状态的推测。</li>
</ul>
<hr>
<h2 id="flushreload">Flush+Reload
</h2><p><strong>Flush+Reload</strong> 是一种典型的缓存侧信道攻击方法，广泛应用于如 Meltdown、Spectre 等漏洞的利用中。它主要利用了共享内存（如共享库或页面）中的缓存行为，结合缓存命中与失效的时延差异，来推测内存中的数据内容。Flush+Reload 的核心在于通过<strong>清除缓存</strong>和<strong>测量缓存命中时的时延</strong>，获取受害者程序对特定内存区域的访问情况。</p>
<p><strong>Flush+Reload</strong> 攻击依赖于现代处理器的多级缓存体系和内存共享机制。其基本工作流程如下：</p>
<ol>
<li><strong>Flush（清空缓存）</strong>：攻击者首先通过 <code>clflush</code> 指令将目标内存地址对应的缓存行从缓存中移除，确保接下来对该地址的访问会从主内存重新加载，而不是从缓存读取。</li>
<li><strong>Victim 访问（受害者访问）</strong>：受害者程序运行期间，可能会访问这个内存地址。当受害者访问该地址时，数据会被加载到缓存中，而这个缓存行为是攻击者所无法直接观察到的。</li>
<li><strong>Reload（重新加载并测量时延）</strong>：接着，攻击者再次访问该地址，并测量访问的时延。如果访问时延较短，说明数据已经在缓存中（受害者程序访问过该地址）；如果时延较长，说明缓存未命中，数据需要从主内存加载。</li>
</ol>
<p><strong>Flush+Reload 的详细流程</strong></p>
<ol>
<li>
<p><strong>准备阶段：确定共享内存区域</strong>。Flush+Reload 攻击通常需要一个<strong>共享的内存区域</strong>，攻击者和受害者程序都可以访问这一内存区域。这可以是一个共享的库（如 <code>.so</code> 文件），或者是一个共享的内存页面。在 Meltdown 攻击中，攻击者可能会试图访问内核空间的某个地址。</p>
</li>
<li>
<p><strong>Flush：清除缓存行</strong>。攻击者首先使用 <code>clflush</code> 指令将目标地址对应的缓存行从缓存中清除。<code>clflush</code> 是一个处理器指令，它会强制清空某个内存地址所在的缓存行，无论该地址是否在 L1、L2 或 L3 缓存中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">clflush</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared_memory_address</span><span class="p">);</span>  <span class="c1">// 清空 shared_memory_address 对应的缓存行
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>通过这一步操作，攻击者确保缓存中没有目标地址的数据，确保接下来对该地址的访问一定会引发缓存行为（缓存命中或未命中）。</p>
</li>
<li>
<p><strong>受害者程序执行</strong>。在攻击者执行 <code>clflush</code> 后，受害者程序继续执行。在它的执行过程中，如果受害者程序访问了之前被清空缓存的那个地址，数据会被重新加载到缓存中。</p>
<p>这一步对于攻击者是不可见的，攻击者无法直接知道受害者程序是否访问了该地址，但这正是 Flush+Reload 要通过测量时延来推测的部分。</p>
</li>
<li>
<p><strong>Reload：访问并测量时延</strong>。攻击者接下来会重新访问刚刚清空缓存的那个内存地址，并测量访问的时延。这里使用类似 <code>rdtsc</code>（读取时间戳计数器）的指令来精确计量该地址的访问时延。</p>
<ul>
<li>
<p><strong>缓存命中</strong>：如果受害者程序访问了该地址，数据已经被加载到缓存中，那么攻击者的访问会<strong>非常快</strong>，通常在几个 CPU 周期内完成。</p>
</li>
<li>
<p><strong>缓存未命中</strong>：如果受害者程序没有访问该地址，数据没有被加载到缓存中，攻击者的访问会<strong>较慢</strong>，因为处理器需要从主内存重新加载数据。</p>
</li>
</ul>
<p><strong>代码示例</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">start_time</span> <span class="o">=</span> <span class="nf">rdtsc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nf">access</span><span class="p">(</span><span class="n">shared_memory_address</span><span class="p">);</span>  <span class="c1">// 访问目标内存地址
</span></span></span><span class="line"><span class="cl"><span class="n">end_time</span> <span class="o">=</span> <span class="nf">rdtsc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">time_diff</span> <span class="o">=</span> <span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过<strong>访问时延</strong>的差异，攻击者可以推测受害者程序是否访问了该地址。如果访问时间短，则说明该地址已经在缓存中（缓存命中）；如果访问时间长，则说明该地址未被缓存（缓存未命中）。</p>
</li>
<li>
<p><strong>多次重复，推测数据</strong>。Flush+Reload 攻击的威力在于，它可以通过<strong>多次采样</strong>，并结合对多个地址的访问时延，逐步推测出受害者程序访问了哪些数据，并且可能进一步推测这些数据的值。</p>
<p>在某些攻击场景中，例如 Meltdown，攻击者会构造某种数据依赖关系，使得内核数据（或其他敏感数据）加载到缓存中，通过时延差异来推测这些数据。</p>
</li>
</ol>
<p><strong>Flush+Reload 的应用场景</strong></p>
<ol>
<li><strong>加密算法泄露</strong>：Flush+Reload 经常被用来攻击基于内存访问模式的加密算法（如 AES）。攻击者可以监控加密算法在执行过程中对内存的访问，从而推测出加密密钥的部分或全部。</li>
<li><strong>Meltdown/Spectre 攻击</strong>：Flush+Reload 在 Meltdown 和 Spectre 攻击中被广泛使用。Meltdown 攻击诱导处理器乱序执行访问不该访问的内核空间数据，而 Flush+Reload 则用来通过缓存时延分析间接提取这些数据。</li>
<li><strong>共享库攻击</strong>：攻击者可以通过 Flush+Reload 分析共享库的缓存行为，监控其他程序对共享库函数的调用情况，从而推测出程序的行为或数据。</li>
</ol>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th style="text-align: center">优点</th>
          <th style="text-align: center">局限</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center"><strong>精确性高</strong>：Flush+Reload 的缓存时延测量非常精确，可以区分出极小的访问时间差异。</td>
          <td style="text-align: center"><strong>需要共享内存</strong>：Flush+Reload 依赖于攻击者和受害者程序共享某个内存区域，才能有效地监控缓存行为。</td>
      </tr>
      <tr>
          <td style="text-align: center"><strong>高效性</strong>：因为只需通过测量缓存行为进行推测，Flush+Reload 可以在无需直接访问内存数据的情况下泄露信息。</td>
          <td style="text-align: center"><strong>防御机制有效</strong>：现代操作系统和处理器在修复 Meltdown、Spectre 等漏洞时，采取了一些防御机制，如缓存隔离、限制缓存刷新指令的使用等，可能会降低 Flush+Reload 的效果。</td>
      </tr>
  </tbody>
</table></div>
<p>总的来说，Flush+Reload 是一种强大的缓存侧信道攻击方法，利用缓存时延分析推测内存访问行为。它通过 <code>clflush</code> 指令清空缓存、受害者程序访问内存、攻击者重新加载数据并测量时延，来判断受害者程序是否访问了特定的内存区域。这种方法在加密算法泄露和 Meltdown、Spectre 等漏洞的利用中具有广泛的应用，但它也需要依赖共享内存和较高精度的时延测量技术。</p>
<hr>
<h2 id="flushreload-查询对象">Flush+Reload 查询对象
</h2><p>在 <strong>Flush+Reload</strong> 攻击中，查询的是<strong>缓存中的数据</strong>，而不是直接查询<strong>页表</strong>或<strong>页表中的缓存行</strong>。Flush+Reload 的核心是基于缓存行的<strong>状态</strong>（命中或未命中），而不涉及具体的页表结构。</p>
<p>为了更清楚地解释这一点，让我们深入了解 <strong>Flush+Reload</strong> 的运作机制：</p>
<ol>
<li>
<p><strong>缓存与内存的关系</strong></p>
<p>在现代处理器中，内存访问的速度相对较慢，而<strong>缓存</strong>（L1、L2、L3）是一种高速的存储层，用于存放处理器频繁使用的数据。缓存以 <strong>缓存行</strong>（通常 64 字节）的单位进行管理。</p>
<p>当处理器访问某个内存地址时，它首先会检查该地址是否已经在缓存中：</p>
<ul>
<li>
<p><strong>命中（Cache Hit）</strong>：如果该数据已经在缓存中，处理器可以直接读取，速度极快。</p>
</li>
<li>
<p><strong>未命中（Cache Miss）</strong>：如果缓存中没有该数据，处理器需要从更慢的主内存中加载，造成较大的时延。</p>
</li>
</ul>
</li>
<li>
<p><strong>Flush+Reload 的基本原理</strong></p>
<p>Flush+Reload 是一种<strong>缓存侧信道攻击技术</strong>，它的工作原理基于对特定缓存行的命中与未命中状态的监控。具体操作步骤如下：</p>
<ul>
<li>
<p><strong>Flush</strong>：首先，攻击者使用 <code>clflush</code> 指令，将目标内存地址对应的缓存行<strong>从缓存中移除</strong>，确保缓存行处于未命中的状态。这个目标地址通常指向一个共享的内存区域，比如一个共享的库或页面（在 Meltdown 攻击中，可能是敏感数据的地址）。</p>
</li>
<li>
<p><strong>Victim 访问</strong>：然后，受害者程序可能会访问这个内存地址。这会导致数据被重新加载到缓存中，但攻击者此时不知道受害者是否真的访问了这个地址。</p>
</li>
<li>
<p><strong>Reload</strong>：攻击者随后再访问相同的内存地址，并测量访问时延。如果访问速度非常快（缓存命中），攻击者可以推测该地址已经被受害者程序访问并加载到缓存中。</p>
</li>
</ul>
</li>
<li>
<p><strong>与物理页表无关</strong></p>
<p><strong>Flush+Reload</strong> 攻击关注的是内存地址对应的<strong>缓存行</strong>，而不是查询或直接操作物理页表或页表缓存。</p>
<p>页表是操作系统管理虚拟内存和物理内存映射的结构。它决定虚拟地址映射到哪个物理地址。然而，<strong>Flush+Reload 的核心关注点是物理内存地址的缓存状态</strong>，并不涉及页表的具体内容或查询页表中的缓存行。</p>
</li>
<li>
<p><strong>攻击对象是缓存行，而非页表</strong></p>
<p>在 Flush+Reload 中：</p>
<ul>
<li>
<p><strong>Flush</strong> 清除的是目标内存地址的缓存行。</p>
</li>
<li>
<p><strong>Reload</strong> 通过测量时延，检查是否该地址对应的缓存行已经被加载到缓存中。</p>
</li>
</ul>
<p>虽然页表决定了虚拟地址和物理地址之间的映射，但在<strong>缓存系统</strong>中，数据是按照<strong>物理地址</strong>进行缓存的。因此，当处理器访问某个内存地址时，处理器会先查找这个物理地址对应的缓存行。</p>
<p><strong>Flush+Reload</strong> 主要是<strong>查询内存地址对应的缓存行状态</strong>（命中或未命中），而不是直接查询物理页表或页表中的缓存行。</p>
</li>
</ol>
<hr>
<h2 id="缓存未命中复习">缓存未命中复习
</h2><p>当缓存<strong>未命中</strong>时，加载的内容<strong>不是物理页表本身</strong>，而是<strong>内存地址对应的实际数据</strong>。具体来说：</p>
<ul>
<li><strong>未命中时</strong>，处理器会从<strong>主内存</strong>中将目标内存地址对应的数据块（即<strong>缓存行</strong>）加载到缓存中，而不是加载物理页表。缓存行通常是内存中某个物理地址的一小块（比如 64 字节）。</li>
<li><strong>页表的作用</strong>是将虚拟地址映射到物理地址。当处理器需要访问某个虚拟地址时，它首先通过页表查找该虚拟地址对应的物理地址。这个查找过程会通过 <strong>TLB（Translation Lookaside Buffer）</strong> 来加速。</li>
<li>如果<strong>TLB 命中</strong>，处理器可以快速得到物理地址，然后访问该物理地址并加载相应的数据到缓存中。</li>
<li>如果<strong>TLB 未命中</strong>，处理器需要从页表中查找对应的物理地址，这会导致页表的查找过程。而这个过程通常涉及<strong>访问页表</strong>（页表存放在主内存中），然后将查找到的物理地址对应的数据加载到缓存中。</li>
</ul>
<p>缓存行（Cache Line）：</p>
<ul>
<li>缓存是按块（即<strong>缓存行</strong>）来管理的，每个缓存行对应内存中连续的一段数据。</li>
<li>例如，当处理器访问某个内存地址时，如果该地址所在的缓存行未命中，则处理器会从主内存中加载整个缓存行（如 64 字节）到缓存，而不是只加载单个字节或单个指令。</li>
</ul>
<p>空间局部性原理：</p>
<ul>
<li>缓存设计通常基于<strong>空间局部性</strong>原理，这意味着如果处理器访问了某个内存地址，它很有可能会在接下来访问<strong>相邻的地址</strong>。因此，处理器每次加载一个较大的数据块（即缓存行）到缓存中，而不是只加载一个特定字节或单个数据项。</li>
</ul>
<p>假设处理器访问内存地址 <code>0x1000</code>，该地址对应的缓存行未命中：</p>
<ul>
<li>如果缓存行大小为 64 字节，处理器会从 <code>0x1000</code> 开始加载一段内存，可能从 <code>0x1000</code> 到 <code>0x103F</code>（64 字节的范围）。</li>
<li>整个缓存行（64 字节）会被存储在缓存中，之后处理器对这些地址范围内的数据访问就可以直接从缓存中读取，避免再次访问主内存。</li>
</ul>
<p>缓存行大小的选择:</p>
<ul>
<li><strong>常见缓存行大小</strong>：典型的缓存行大小为 <strong>64 字节</strong>，但某些系统可能会有不同的缓存行大小，如 32 字节或 128 字节。这种大小通常是处理器设计时的固定参数，旨在平衡性能和内存带宽使用。</li>
<li><strong>优势</strong>：一次加载较大的数据块有助于提高缓存命中率，并减少处理器与主内存之间的数据传输开销，因为后续访问同一缓存行的相邻数据不需要再从主内存读取。</li>
</ul>
<p><strong>加载整个缓存物理页表</strong>的地方，指的是 <strong>TLB（Translation Lookaside Buffer，翻译后备缓冲区）</strong>，它与虚拟地址和物理地址映射过程中的缓存机制有关。TLB 是一种<strong>专用缓存</strong>，用于加速虚拟地址到物理地址的转换。</p>
<p>TLB 是处理器内的一个<strong>小型高速缓存</strong>，它存储了<strong>最近使用的虚拟地址到物理地址的映射</strong>，即页表条目。当处理器访问虚拟内存时，TLB 可以直接提供虚拟地址对应的物理地址，而不必每次都查找完整的页表。这样极大地提升了地址转换的效率。</p>
<p>TLB <strong>缓存的是页表的部分条目</strong>，通常是页表中的一组映射关系，而不是整个页表本身。具体来说，每个 TLB 条目包含虚拟页面号（VPN）和物理页面号（PPN）之间的映射关系。每当 TLB 未命中时，处理器需要从内存中的页表中查找该虚拟地址对应的物理地址，并将这一映射加载到 TLB 中，以便加速后续的内存访问。典型的 TLB 加载过程：</p>
<ol>
<li>
<p>TLB 命中：处理器首先查找 TLB。如果命中，虚拟地址直接被转换为物理地址，继续执行程序。</p>
</li>
<li>
<p>TLB 未命中:  如果未命中，处理器会访问内存中的页表结构，找到对应的物理地址映射，然后将这一映射加载到 TLB 中。</p>
<ul>
<li><strong>页表是分层的</strong>，因此处理器可能需要多次内存访问来查找页表，尤其是在多级页表的系统中。</li>
</ul>
</li>
</ol>
<ul>
<li>一旦找到对应的物理页表条目，处理器会将其加载到 TLB 中。</li>
</ul>
<p>“加载一张缓存的物理页表”是指 TLB 在加载页表条目时，起到了<strong>页表缓存</strong>的作用。它并不缓存整个页表，而是缓存最近使用的页表条目。因为页表查找相对耗时，通过 TLB 缓存，可以避免每次都进行完整的页表查找。</p>
<p>假设系统使用的是 4KB 的页（常见的页面大小）：</p>
<ol>
<li><strong>虚拟地址访问</strong>：处理器访问一个虚拟地址时，首先会查询 TLB 是否存在该地址对应的物理地址映射。</li>
<li><strong>TLB 未命中</strong>：如果 TLB 没有该虚拟地址的映射，处理器需要通过页表查找物理地址（这涉及访问内存中的多级页表）。</li>
<li><strong>更新 TLB</strong>：查找到物理地址后，该映射会被存入 TLB，后续对该虚拟地址范围内的访问会直接命中 TLB，不再需要查页表。</li>
</ol>
<p>TLB 通常非常小，可能只有几十到几百个条目，但它的存在可以显著减少处理器访问完整页表的频率。通常情况下，每个 TLB 条目会缓存一整个页面的映射信息。例如，如果页面大小是 4KB，那么一次 TLB 加载可以加速对该 4KB 内存范围内的所有地址访问。</p>
<p>总的来说，当缓存未命中时，处理器加载的是目标<strong>物理地址对应的数据块</strong>，即<strong>缓存行</strong>，而不是直接加载页表。页表的作用是在虚拟地址到物理地址的转换过程中使用，而最终缓存的内容是物理地址对应的<strong>数据本身</strong>，不是页表结构。一般情况下，处理器在缓存未命中时会从主内存加载一个缓存行的数据，大小通常为 64 字节，这是缓存设计中常用的大小。</p>
<p>“加载一张缓存物理页表”的地方指的是 <strong>TLB</strong>，它缓存的是<strong>页表中的部分条目</strong>，即最近使用的虚拟地址到物理地址的映射。TLB 的作用是加速地址转换，避免每次访问虚拟内存时都查找页表，而是通过缓存常用的页表条目来提高效率。</p>
<hr>
<h2 id="meltdown-的-异常-0-值">Meltdown 的 异常 0 值
</h2><p>在 <strong>Meltdown + 侧信道攻击</strong> 中，出现“异常读取到 0 值”的情况，通常与以下几个方面有关：</p>
<ol>
<li><strong>权限问题导致的异常访问</strong>：由于内存访问违规（试图访问不允许的地址，如内核空间），导致读取的数据无效，处理器返回 <code>0</code> 值或触发异常。</li>
<li><strong>缓存行为异常</strong>：某些情况下，处理器在非法访问内存时，会导致数据未能正确加载到缓存中，进而在侧信道攻击中读取时得到错误的 <code>0</code> 值。</li>
</ol>
<p>为了避免在这种攻击中读取到无效的 <code>0</code> 值，需要从以下几个方面进行调整：</p>
<ol>
<li>
<p><strong>避免异常提前终止执行</strong>。Meltdown 攻击依赖于处理器的<strong>乱序执行</strong>，即使触发了非法内存访问异常，处理器仍然会提前执行部分指令。因此，以下措施可以帮助减少读取到 <code>0</code> 值的可能性：</p>
<ol>
<li>
<p><strong>限制异常处理</strong></p>
<p>在进行 Meltdown 攻击时，尽量减少异常的影响。例如，通过构造某种条件，使得异常发生后处理器仍然可以继续执行读取操作。可以使用信号处理机制来捕捉异常，并避免程序在异常发生后立即崩溃。</p>
<p><strong>方法</strong>：使用类似以下代码结构捕捉异常：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="nf">setjmp</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这里执行 Meltdown 攻击的代码
</span></span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">kernel_data</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">kernel_address</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">array</span><span class="p">[</span><span class="n">kernel_data</span> <span class="o">*</span> <span class="mi">4096</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 异常发生时的处理逻辑
</span></span></span><span class="line"><span class="cl">    <span class="c1">// 可以重试或者记录错误
</span></span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过 <code>setjmp</code> 和 <code>longjmp</code>，程序可以在发生非法访问异常后返回并继续执行。</p>
</li>
<li>
<p><strong>多次采样，减少误差</strong></p>
<p>由于缓存命中与失效的时间差异较小，有时单次攻击可能因数据加载失败或异常读取到 <code>0</code>。为了解决这个问题，可以使用<strong>多次采样</strong>的方式：</p>
<ul>
<li>
<p><strong>多次尝试访问同一个地址</strong>，并记录多次访问的结果。</p>
</li>
<li>
<p>统计访问时的时延，并通过取平均值或最大值的方式，确定数据是否正确。</p>
</li>
</ul>
<p>通过多次采样，可以减少单次访问异常带来的误差，增加推测数据的准确性。</p>
</li>
</ol>
</li>
<li>
<p><strong>优化侧信道分析</strong>。当缓存行为异常，或者数据没有正确加载到缓存时，侧信道技术可能读取到无效数据。在这种情况下，可以优化<strong>缓存时延的测量方法</strong>，确保对缓存命中状态的判断更准确。</p>
<ol>
<li>
<p><strong>更精准的时延测量</strong></p>
<p>有时，测量时延的精度不够高，导致读取的结果不准确。可以通过更精准的计时器（如 <strong>rdtsc</strong> 指令）来测量缓存访问的时间差，确保能够正确区分缓存命中与未命中。</p>
</li>
<li>
<p><strong>设置更明确的触发条件</strong></p>
<p>通过调整缓存的刷新和测量时机，可以确保攻击中处理器将数据正确加载到缓存中，避免读取到无效的 <code>0</code> 值。例如，控制 <code>clflush</code> 指令的调用时机，以确保在读取敏感数据之前缓存被正确刷新。</p>
</li>
</ol>
</li>
<li>
<p><strong>避免处理器的零填充机制</strong>。某些现代处理器在检测到非法内存访问时，可能会出于安全考虑返回 <code>0</code>（或其他固定值），而不是读取实际的数据。这是一种防止侧信道攻击的硬件机制。为了应对这种情况，攻击者可以：</p>
<ol>
<li>
<p><strong>使用较旧的硬件</strong></p>
<p>某些较旧的处理器没有这种安全机制，因此可以使用这些处理器进行攻击，从而避免数据被零填充。</p>
</li>
<li>
<p><strong>探测并绕过零填充</strong></p>
<p>在硬件中如果存在零填充机制，可以通过探测不同的访问模式，分析哪些数据读取到的 <code>0</code> 值是由于这个机制引起的，进而在攻击逻辑中规避这些地址。</p>
</li>
</ol>
</li>
<li>
<p><strong>处理异常返回的零值</strong>。在攻击过程中，针对出现的异常情况返回 <code>0</code> 值，可以通过<strong>重试策略</strong>来解决。每当读取到 <code>0</code> 值时，可以重新尝试访问同一个内存地址，直到获取到非 <code>0</code> 值为止。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span> <span class="o">=</span> <span class="nf">attempt_to_read_data</span><span class="p">(</span><span class="n">kernel_address</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">// 重试直到获取到非 0 的数据
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p>在 <strong>Meltdown + 侧信道攻击</strong> 中，读取到 <code>0</code> 值的原因可能是由于异常处理、缓存行为或硬件机制。要减少这种情况的发生，可以通过<strong>捕捉异常、增加多次采样、优化时延测量</strong>等手段改进攻击的准确性。此外，了解处理器的硬件特性也是关键，尤其是在现代处理器中，某些硬件防护机制可能会主动返回 <code>0</code> 或其他无效数据。</p>
<hr>
<h2 id="区分内核值-0-与异常-0">区分内核值 <code>0</code> 与异常 <code>0</code>
</h2><p>在 <strong>Meltdown + 侧信道攻击</strong> 中，确实存在一种情况：内核中的值本身可能为 <code>0</code>，而你又可能因为异常处理（如权限问题）得到了一个 <code>0</code>。那么，如何区分这两种 <code>0</code>，即区分<strong>真实的内存值为 <code>0</code></strong> 和<strong>异常导致的 <code>0</code></strong>，是侧信道攻击中的一个挑战。</p>
<p>可以通过<strong>多次采样</strong>和<strong>时延分析</strong>等技术来区分这两种情况。具体的方法如下：</p>
<ol>
<li>
<p><strong>多次采样</strong>。通过<strong>多次采样</strong>可以有效地减少由于异常返回 <code>0</code> 的影响。基本思路是，如果数据在多次采样过程中稳定地返回 <code>0</code>，那么它更可能是内存中的真实值；而如果采样结果波动不定（有时返回 <code>0</code>，有时返回其他值或异常），那么就可能是由于异常导致的。<strong>步骤</strong>：</p>
<ul>
<li>
<p>对同一个内存地址进行多次攻击，测量每次的访问结果。</p>
</li>
<li>
<p>如果多次采样都返回 <code>0</code>，可以初步判断内核中的值可能确实是 <code>0</code>。</p>
</li>
<li>
<p>如果 <code>0</code> 只是偶尔出现，并且伴随有其他非 <code>0</code> 的返回值，则可以推测该 <code>0</code> 可能是由于异常处理机制导致的。</p>
</li>
</ul>
</li>
<li>
<p><strong>缓存时延分析</strong>。为了进一步提高区分的精度，<strong>缓存时延分析</strong>仍然是关键。你可以结合时延测量来帮助判断：</p>
<ul>
<li>
<p><strong>真实的内存值为 <code>0</code> 时</strong>，读取缓存中的 <code>0</code> 值通常伴随着<strong>缓存命中</strong>，此时访问的时延应该是很短的。</p>
</li>
<li>
<p><strong>异常导致返回 <code>0</code> 时</strong>，由于处理器未能正常加载该内存地址的数据，缓存未命中时的访问时延通常会更长。</p>
</li>
</ul>
<p>通过时延测量，攻击者可以识别出<strong>缓存命中</strong>的情况，从而区分正常的内存访问（真实的 <code>0</code>）和异常情况导致的返回值 <code>0</code>。假设要判断 <code>kernel_address</code> 的值是否为 <code>0</code>：</p>
<ol>
<li>
<p><strong>刷新缓存</strong>：使用 <code>clflush</code> 指令清除缓存中 <code>kernel_address</code> 对应的缓存行。</p>
</li>
<li>
<p><strong>执行读取操作</strong>：触发 Meltdown 攻击，尝试从 <code>kernel_address</code> 读取数据。</p>
</li>
<li>
<p><strong>测量时延</strong>：使用 <code>rdtsc</code>（读取时间戳计数器）测量对 <code>kernel_address</code> 的访问时延。</p>
</li>
<li>
<p><strong>多次采样</strong>:  重复步骤 1-3，采集多个结果。</p>
<ul>
<li>
<p>如果时延总是很短且返回 <code>0</code>，则说明内存中的真实值可能就是 <code>0</code>。</p>
</li>
<li>
<p>如果时延较长，或是时延不稳定、偶尔返回 <code>0</code>，则很可能是由于异常导致的。</p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p><strong>信号处理与异常控制</strong>。如前面提到的，你可以通过 <strong><code>setjmp</code> 和 <code>longjmp</code></strong> 等机制捕捉异常并确保程序在发生异常时不会崩溃。这种方法不仅可以减少因异常直接返回 <code>0</code>，还可以通过异常处理来<strong>重试访问</strong>，进一步确保结果的准确性。</p>
<p>当你捕获到异常时，可以记录异常次数和触发位置。如果某个内存地址频繁触发异常且返回 <code>0</code>，则这个 <code>0</code> 可能与异常有关。</p>
</li>
<li>
<p><strong>随机访问测试</strong>。另一个技术是对目标内存地址周围的地址进行<strong>随机访问</strong>。如果周围地址的访问正常且没有返回异常的 <code>0</code>，但目标地址却持续返回 <code>0</code>，这更有可能表明目标地址中的数据确实是 <code>0</code>。可以通过以下策略进行随机测试：</p>
<ul>
<li>
<p>对比 <code>kernel_address</code> 的相邻地址（例如 <code>kernel_address - 1</code> 和 <code>kernel_address + 1</code>）的访问情况。</p>
</li>
<li>
<p>如果相邻地址的数据返回正常，但目标地址频繁出现异常 <code>0</code>，则该 <code>0</code> 可能是由于异常引起的。</p>
</li>
</ul>
</li>
<li>
<p><strong>重试机制</strong>。为了应对异常返回 <code>0</code> 的情况，可以设计一个<strong>重试机制</strong>，即每次读取到 <code>0</code> 时，进行多次重试，直到结果稳定。如果经过多次重试结果仍然是 <code>0</code>，则该 <code>0</code> 更有可能是内存中的真实值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>  <span class="c1">// 设定重试次数
</span></span></span><span class="line"><span class="cl"><span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span> <span class="o">=</span> <span class="nf">attempt_to_read_data</span><span class="p">(</span><span class="n">kernel_address</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">retries</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">retries</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">// 重试，直到获取到非 0 的数据或达到重试上限
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p>总而言之，要区分 Meltdown + 侧信道攻击中读取到的 <code>0</code> 是<strong>内存中的真实值</strong>还是<strong>异常导致的返回值</strong>，可以通过以下几种方法：</p>
<ol>
<li><strong>多次采样</strong>：多次读取同一地址，判断 <code>0</code> 是否稳定出现。</li>
<li><strong>缓存时延分析</strong>：通过测量缓存访问时延，判断是否发生了缓存命中，命中意味着数据可能是真实的。</li>
<li><strong>信号处理与异常控制</strong>：捕捉异常，记录异常次数，并重试访问来确认结果。</li>
<li><strong>随机访问测试</strong>：对目标地址附近的地址进行测试，通过对比结果进一步验证。</li>
<li><strong>重试机制</strong>：当读取到 <code>0</code> 时，尝试重试多次，以确保返回值的准确性。</li>
</ol>
<p>通过以上手段，可以大大提高攻击的成功率，并有效区分异常导致的 <code>0</code> 和内存中的真实值。</p>
<hr>
<h2 id="meltdown调整内存值大小">Meltdown调整内存值大小
</h2><p>在 Meltdown 的侧信道攻击中，要调整每次能得到的内存值的大小，通常涉及到以下几个技巧：</p>
<ol>
<li>
<p><strong>控制访问粒度</strong>。一般来说，Meltdown 攻击可以逐字节读取数据。如果你想调整每次读取的数据大小，可以通过以下方式：</p>
<ol>
<li>
<p><strong>逐字节访问</strong></p>
<ul>
<li>
<p><strong>典型实现</strong>：构造攻击代码，使每次读取一个字节。</p>
</li>
<li>
<p>示例代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">data_size</span><span class="p">;</span> <span class="n">offset</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">value</span> <span class="o">=</span> <span class="nf">read_byte</span><span class="p">(</span><span class="n">kernel_address</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 处理读取的 value
</span></span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>
<p><strong>逐多字节访问</strong></p>
<ul>
<li>
<p>如果希望每次读取多字节，可以将多次字节读取合并，例如使用<code>memcpy</code>优化攻击代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">data_size</span><span class="p">;</span> <span class="n">offset</span> <span class="o">+=</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">kernel_address</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 处理读取的 buffer
</span></span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>这个方法需要确保攻击代码能连续加载所需字节到缓存。</p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p><strong>优化缓存行为</strong>。缓存行是以固定大小（通常 64 字节）的块进行管理的。调整数据读取大小时，需要考虑缓存行对齐的问题：</p>
<ul>
<li>
<p><strong>缓存对齐</strong>：确保读取的数据恰好在一个或多个完整的缓存行中。这样能减少多余的内存访问和缓存未命中。</p>
</li>
<li>
<p><strong>预取优化</strong>：通过 <code>prefetch</code> 指令提前加载大块数据，帮助提高获取率。</p>
</li>
</ul>
</li>
<li>
<p><strong>使用批量处理</strong>。如果希望每次读取更多数据，考虑使用批量攻击来同时处理多个字节：</p>
<ul>
<li>
<p><strong>结合流水线和乱序执行</strong>：调整内存访问模式，让处理器能够提前执行多个字节加载。</p>
</li>
<li>
<p><strong>批量缓存刷新</strong>：在攻击中，批量刷新缓存行以准备加载更多字节。</p>
</li>
</ul>
</li>
<li>
<p><strong>利用高级指令</strong>。某些处理器架构支持高级指令，可以用于更大范围的内存操作。有助于提高每次读取的字节量。</p>
</li>
<li>
<p><strong>异常处理调整</strong>。在 Meltdown 攻击中，如果要提高每次读取数据的粒度，可以结合异常处理调整策略：</p>
<ul>
<li>
<p><strong>细化异常捕获</strong>：确保每个读取操作的边界条件和异常处理得当，以避免数据丢失或错误。</p>
</li>
<li>
<p><strong>调整 <code>setjmp</code> 和 <code>longjmp</code> 的使用</strong>：确保在更大连续内存读取中保持执行连续性。</p>
</li>
</ul>
</li>
</ol>
<p>要在 Meltdown 的侧信道攻击中调整每次能得到的内存值大小，可以通过控制访问粒度、优化缓存行为、使用批量处理和高级指令来实现。同时调整异常处理策略，确保读取准确和有效。通过这些方法，可以更灵活地控制每次读取的数据量。</p>
<hr>
<h2 id="kaiser">KAISER
</h2><p>KAISER 是一种改进的内存隔离技术，旨在强化用户空间和内核空间之间的隔离。其主要步骤包括：</p>
<ul>
<li><strong>内存映射调整</strong>：KAISER 会确保在用户空间中不映射任何内核内存，只保留一些x86架构必须的部分（例如中断处理程序）。</li>
<li><strong>消除直接物理映射</strong>：用户空间无法访问物理内存或内核内存，因此无法通过地址解析来泄露这些内存。</li>
<li><strong>防止漏洞利用</strong>：通过不在用户空间映射敏感内核内存，阻止像Meltdown这样的攻击从内核中泄露信息。</li>
</ul>
<p>假设一个攻击者正在尝试定位某个关键的内存处理函数，该函数在用户空间中只留下了微小的踪迹（比如只有几千字节），而整体用户空间的大小可能是数十GB。同时，如果这些内存位置随着KASLR（内核地址空间布局随机化）不断随机化，攻击者需要经历极多次尝试才能有效猜测到这些位置，因此增加了攻击的难度。</p>
<p>KAISER通过以下方式保护这个攻击面：</p>
<ol>
<li><strong>使用跳板函数</strong>：对必要的内核指针位置使用&quot;跳板（trampoline）&ldquo;函数。这意味着中断处理程序和其他必要的内核代码不直接调用内核，而是通过一个单独的跳板函数进行。</li>
<li><strong>跳板函数内存分离</strong>：确保这些跳板函数只被映射到内核中，并且与其他内核代码使用不同的随机偏移量进行随机化。</li>
<li><strong>隔离作用</strong>：即使Meltdown攻击成功，攻击者只能获取到跳板代码的指针，而无法获取到内核的其余随机化偏移，从而保护内核地址的随机化信息。</li>
</ol>
<p>假设一个系统需要在用户空间中保持中断处理程序的映射，以正常操作。</p>
<ul>
<li><strong>传统方法</strong>：可能直接映射中断处理程序，容易让攻击者通过Meltdown攻击获取其地址并推断其他内核信息。</li>
<li><strong>通过KAISER防护</strong>：
<ul>
<li>将中断处理程序地址指向一个跳板函数。</li>
<li>这个跳板函数的地址在内核中被随机化。</li>
<li>当需要访问中断处理程序时，首先通过被完全随机化了的跳板函数进行处理，以覆盖整个内核的直接地址。</li>
</ul>
</li>
</ul>
<p>通过这种方式，KAISER减少了直接暴露给用户空间的内核地址数量，即使在攻击者可以通过Meltdown获得一些地址，也无法得知内核的具体随机化偏移和其他信息。这种方式在安全和性能之间找到了妥协点，保护了“剩余攻击面”。</p>
<hr>
<h2 id="memory-type-range-registers-mtrrs">Memory-Type Range Registers (MTRRs)
</h2><p>MTRRs 是一个特性，允许系统定义内存区域的缓存特性。通过这些寄存器，系统可以指定某些内存区域是可缓存的、不可缓存的、写合并等。这对于优化系统性能和特定硬件行为很重要。</p>
<hr>
<h2 id="microarchitectural-state-和-architectural-state">Microarchitectural state 和 architectural state
</h2><p>&ldquo;<strong>Microarchitectural state</strong>&rdquo; 和 &ldquo;<strong>architectural state</strong>&rdquo; 是计算机体系结构中两个不同的概念，涉及处理器如何管理和表现数据。</p>
<ol>
<li><strong>微架构状态（Microarchitectural state）</strong>：这是处理器内部的细节层次，它包括缓存、分支预测器、管道、加载/存储队列等部件的状态。这些状态反映了处理器如何在硬件层面优化执行指令，但这些信息通常对软件程序不可见，也不会直接影响程序执行的逻辑结果。</li>
<li><strong>架构状态（Architectural state）</strong>：这是处理器从程序员或系统的角度所能看到的状态，主要包括寄存器、内存中的数据、程序计数器等。这些状态决定了程序的执行逻辑和可见结果。</li>
</ol>
<p>“<strong>Microarchitectural state is translated into an architectural state</strong>” 指的是微架构中的某些临时状态，最终可能影响到架构状态，也就是说，处理器内部的一些优化行为（例如缓存命中或未命中）可能在某些情况下改变程序的实际执行结果或可见结果。</p>
<p><strong>缓存和微架构攻击</strong>：</p>
<ul>
<li>在微架构层面上，缓存中的数据是可见的，但这不属于程序的架构状态。然而，通过侧信道攻击（如Meltdown或Spectre），攻击者可以通过观察缓存行为（例如缓存命中与未命中）推断出某些本应不可见的架构状态。</li>
<li>假设一个程序访问了一个数据地址，如果这个地址在缓存中（微架构状态），访问速度会快。如果攻击者能够利用侧信道推断出这个缓存访问时间的差异，他们可以推断出该数据地址的位置或内容，进而影响架构状态（例如，暴露寄存器或内存中的数据）。</li>
</ul>
<p>微架构状态（如缓存中的数据或管道中的指令）通常对程序不可见，但某些侧信道攻击能够利用这些状态的变化，最终推导出影响程序执行的架构状态。这种“转换”通常并不是直接的，而是通过观察微架构行为来推断出架构级别的信息。</p>
<hr>
<h2 id="正课部分">正课部分
</h2><h2 id="meltdown发生的背景">Meltdown发生的背景
</h2><p>今天讲的是Meltdown，之所以我会读这篇论文，是因为我们在讲解如何设计内核时总是会提到安全。内核提供安全性的方法是隔离，用户程序不能读取内核的数据，用户程序也不能读取其他用户程序的数据。</p>
<p>我们在操作系统中用来实现隔离的具体技术是硬件中的User/Supervisor mode，硬件中的Page Table，以及精心设计的内核软件，例如系统调用在使用用户提供的指针具备防御性。</p>
<p>但是同时也值得思考，如何可以破坏安全性？实际上，内核非常积极的提供隔离性安全性，但总是会有问题出现。</p>
<p>今天的<a class="link" href="https://pdos.csail.mit.edu/6.828/2020/readings/meltdown.pdf"  target="_blank" rel="noopener"
    >论文</a>

讨论的就是最近在操作系统安全领域出现的最有趣的问题之一，它发表于2018年。包括我在内的很多人发现对于用户和内核之间的隔离进行攻击是非常令人烦恼的，因为它破坏了人们对于硬件上的Page Table能够提供隔离性的设想。这里的攻击完全不支持这样的设想。</p>
<p>同时，Meltdown也是被称为Micro-Architectural Attack的例子之一，这一类攻击涉及利用CPU内隐藏的实现细节。通常来说CPU如何工作是不公开的，但是人们会去猜，一旦猜对了CPU隐藏的实现细节，就可以成功的发起攻击。</p>
<p>Meltdown是可被修复的，并且看起来已经被完全修复了。然后它使得人们担心还存在类似的Micro-Architectural Attack。所以这是最近发生的非常值得学习的一个事件。</p>
<p>让我从展示攻击的核心开始，之后我们再讨论具体发生了什么。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">char</span> <span class="n">buf</span> <span class="p">[</span><span class="mi">8192</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">r1</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">kernel</span> <span class="n">virtual</span> <span class="n">address</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">r2</span> <span class="o">=</span> <span class="o">*</span><span class="n">r1</span>
</span></span><span class="line"><span class="cl"><span class="n">r2</span> <span class="o">=</span> <span class="n">r2</span> <span class="o">&amp;</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="n">r2</span> <span class="o">=</span> <span class="n">r2</span> <span class="o">*</span> <span class="mi">4096</span>
</span></span><span class="line"><span class="cl"><span class="n">r3</span> <span class="o">=</span> <span class="n">buf</span> <span class="p">[</span><span class="n">r2</span><span class="p">]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这是论文中展示攻击是如何工作的代码的简化版。</p>
<p>如果你是攻击者，出于某种原因你可以在计算机上运行一些软件，这个计算机上有一些你想要窃取的数据。虽然你不能直接访问这些数据，但是这些数据还是位于内存中，或许是内核内存，或许是另一个进程的内存。</p>
<p>你可以在计算机上运行一个进程，或许因为你登录到了分时共享的机器，也或许你租用了运行在主机上的服务。你可以这样发起攻击：</p>
<ul>
<li>在程序中你在自己的内存中声明了一个buffer，这个buffer就是普通的用户内存且可以被正常访问。</li>
<li>然后你拥有了内核中的一个虚拟内存地址，其中包含了一些你想要窃取的数据。</li>
<li>这里的程序是C和汇编的混合，第3行代码的意思是你拥有了内核的虚拟内存地址，你从这个内存地址取值出来并保存在寄存器r2中。</li>
<li>第4行获取寄存器r2的低bit位，所以这里这种特定的攻击只是从内核一个内存地址中读取一个bit。</li>
<li>第5行将这个值乘以4096，因为低bit要么是1，要么是0，所以这意味着r2要么是4096，要么是0。</li>
<li>第6行中，我们就是读取前面申请的buffer，要么读取位置0的buffer，要么读取位置4096的buffer。</li>
</ul>
<p>这就是攻击的基本流程。</p>
<p>这里的一个问题是，为什么这里不能直接工作？在第3行，我们读取了内核的内存地址指向的数据，我们可以直接读取内核的内存地址吗？并不能，我们相信答案是否定的。</p>
<p>如果我们在用户空间，我们不可能直接从内核读取数据。我们知道CPU不能允许这样的行为，因为当我们使用一个内核虚拟地址时，这意味着我们会通过Page Table进行查找，而Page Table有权限标志位，我们现在假设操作系统并没有在PTE中为内核虚拟地址设置标志位来允许用户空间访问这个地址，这里的标志位在RISC-V上就是pte_u标位置。</p>
<p>因此这里的读取内核内存地址指令必然会失败，必然会触发Page Fault。实际中如果我们运行代码，这些代码会触发Page Fault。如果我们在代码的最后增加printf来打印r3寄存器中的值，我们会在第3行得到Page Fault，我们永远也走不到printf。这时我们发现我们不能直接从内核中偷取数据。</p>
<p>然而，如论文展示的一样，这里的指令序列是有用的。虽然现在大部分场景下已经不是事实了，但是论文假设内核地址被映射到了每个用户进程的地址空间中了。也就是说，当用户代码在运行时，完整的内核PTE也出现在用户程序的Page Table中，但是这些PTE的pte_u比特位没有被设置，所以用户代码在尝试使用内核虚拟内存地址时，会得到Page Fault。</p>
<p>在论文写的时候，所有内核的内存映射都会在用户程序的Page Table中，只是它们不能被用户代码使用而已，如果用户代码尝试使用它们，会导致Page Fault。操作系统设计人员将内核和用户内存地址都映射到用户程序的Page Table中的原因是，这使得系统调用非常的快，因为这使得当发生系统调用时，你不用切换Page Table。</p>
<p>切换Page Table本身就比较费时，同时也会导致CPU的缓存被清空，使得后续的代码执行也变慢。所以通过同时将用户和内核的内存地址都映射到用户空间可以提升性能。但是上面的攻击依赖了这个习惯。我将会解释这里发生了什么使得上面的代码是有用的。</p>
<blockquote>
<p>学生提问：能重复一下上面的内容吗？</p>
<p>Robert教授：在XV6中，当进程在用户空间执行时，如果你查看它的Page Table，其中包含了用户的内存地址映射，trampoline和trap frame page的映射，除此之外没有别的映射关系，这是XV6的工作方式。</p>
<p>而这篇论文假设的Page Table不太一样，当这篇论文在写的时候，大部分操作系统都会将内核内存完整映射到用户空间程序。所以所有的内核PTE都会出现在用户程序的Page Table中，但是因为这些PTE的pte_u比特位没有被设置，用户代码并不能实际的使用内核内存地址。</p>
<p>这么做的原因是，当你执行系统调用时，你不用切换Page Table，因为当你通过系统调用进入到内核时，你还可以使用同一个Page Table，并且因为现在在Supervisor mode，你可以使用内核PTE。</p>
<p>这样在系统调用过程中，进出内核可以节省大量的时间。所以大家都使用这个技术，并且几乎可以肯定Intel也认为一个操作系统该这样工作。</p>
<p>在论文中讨论的攻击是基于操作系统使用了这样的结构。最直接的摆脱攻击的方法就是不使用这样的结构。但是当论文还在写的时候，所有的内核PTE都会出现在用户空间。</p>
<p>学生提问：所以为了能够攻击，需要先知道内核的虚拟内存地址？</p>
<p>Robert教授：是的。或许找到内存地址本身就很难，但是你需要假设攻击者有无限的时间和耐心，如果他们在找某个数据，他们或许愿意花费几个月的时间来窃取这个数据。</p>
<p>有可能这是某人用来登录银行账号或者邮件用的密码。这意味着攻击者可能需要尝试每一个内核内存地址，以查找任何有价值的数据。</p>
<p>或许攻击者会研究内核代码，找到内核中打印了数据的地址，检查数据结构和内核内存，最后理解内核是如何工作的，并找到对应的虚拟内存地址。因为类似的攻击已经存在了很长的时间，内核实际上会保护自己不受涉及到猜内核内存地址的攻击的影响。</p>
<p>论文中提到了Kernal address space layout randomization。所以现代的内核实际上会将内核加载到随机地址，这样使得获取内核虚拟地址更难。这个功能在论文发表很久之前就存在，因为它可以帮助防御攻击。</p>
<p>在这个攻守双方的游戏中，我们需要假设攻击者最后可以胜出并拿到内核的虚拟内存地址。所以我们会假设攻击者要么已经知道了一个内核虚拟地址，要么愿意尝试每一个内核虚拟内存地址。</p>
</blockquote>
<p>我们会好奇，上面的代码怎么会对攻击者是有用的？如果CPU如手册中一样工作，那么这里的攻击是没有意义的，在第三行会有Page Fault。但是实际上CPU比手册中介绍的要复杂的多，而攻击能生效的原因是一些CPU的实现细节。</p>
<p>这里攻击者依赖CPU的两个实现技巧，一个是Speculative execution（预测执行），另一个是CPU的缓存方式。</p>
<hr>
<h2 id="speculative-execution1">Speculative execution(1)
</h2><p>首先来看Speculative execution（预测执行），这里也有一个示例代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">r0</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">something</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">r1</span> <span class="o">=</span> <span class="n">valid</span> <span class="c1">//r1 is a register; valid is in RAM
</span></span></span><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">r1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">r2</span> <span class="o">=</span> <span class="o">*</span><span class="n">r0</span>
</span></span><span class="line"><span class="cl">  <span class="n">r3</span> <span class="o">=</span> <span class="n">r2</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">r3</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在我并没有讨论安全性，Speculative execution是一种用来提升CPU性能的技术，所以这是CPU使用的一些优化技巧。假设我们在运行这里的代码：</p>
<ul>
<li>在r0寄存器保存了一个内存地址，地址可能是有效的也可能是无效的，这取决于我代码的逻辑。</li>
<li>我们假设内存中还保存了一个valid变量。在使用r0中保存地址之前，我们会先将valid从内存中加载到r1。</li>
<li>并且只有当valid等于1时，才使用r0中的地址。如果valid等于0，我们将不会使用r0中的地址。</li>
<li>如果valid等于1，我们会将r0的地址指向的内容加载到r2。</li>
<li>并对r2寄存器加1，保存在r3寄存器中。</li>
</ul>
<p>在一个简单的CPU实现中，在代码的第2行，你会将valid从内存中加载到r1，这里对应了从内存中读取数据的load指令。任何一个需要从内存中读取数据的load指令都会花费2GHZ CPU的数百个CPU cycle。CPU最多可以在每个cycle执行一条指令，如果我们需要在代码的第2行等待几百个CPU cycle，那么机器会闲置数百个CPU cycle。</p>
<p>这是一个明显的降低性能的地方，因为如果一切都正常的话，CPU可以在每个cycle内执行一条指令，而不是每几百个cycle才执行一条指令。</p>
<p>所有现在的CPU都使用了叫做branch prediction的功能。第3行的if语句是一个branch，如果我们将其转换成机器指令，我们可以发现这里有一个branch，并且这是一个带条件的branch用来测试r1寄存器是否等于1。</p>
<p>CPU的branch prediction会至少为每个最近执行过的branch保存一个缓存，并记住这个branch是否被选中了，所以这里可能是基于上次branch的选择的预测。</p>
<p>但是即使CPU没有足够的信息做预测，它仍然会选择一个branch，并执行其中的指令。也就是说在CPU在知道第3行代码是否为true之前，它会选择某一个branch并开始执行。或许branch选错了，但是CPU现在还不知道。</p>
<p>所以在上面的代码中，或许在第2行代码的load结束之前，也就是在知道valid变量的值之前，CPU会开始执行第4行的指令，并通过load指令读取r0指向的内存地址的内容。</p>
<p>而r0中的内存地址或许是，也或许不是一个有效的指针。一旦load指令返回了一些内容，在代码的第5行对返回内容加1并设置到r3寄存器中。</p>
<p>或许很久之后，第2行的load指令终于完成了，现在我们知道valid变量的值。如果valid等于1，那么一切都好，如果valid等于0，CPU会取消它执行第4、5行代码的效果，并重新执行合适的分支代码，也就是第7行代码。</p>
<p>这里在确定是否应该执行之前就提前执行分支代码的行为，被称作预测执行。这是为了提升性能，如果CPU赌对了，那么它就可以超前执行一些指令，而不用等待费时的内存加载。</p>
<p>CPU中为了支持预测执行的硬件及其复杂，CPU里面有大量的设计来让这里能工作，但是没有一个设计被公开了，这些都是Intel的内部信息，并且不在手册中。所以在Meltdown Attack时，涉及到大量有关CPU是如何工作的猜测来确保攻击能生效。</p>
<p>为了能回滚误判的预测执行，CPU需要将寄存器值保存在别处。虽然代码中第4行，第5行将值保存在了r2，r3，但是实际上是保存在了临时寄存器中。</p>
<p>如果CPU赌对了，那么这些临时寄存器就成了真实寄存器，如果赌错了，CPU会抛弃临时寄存器，这样代码第4，5行就像从来没有发生过一样。</p>
<p>在这里的代码中，我们需要考虑如果r0中是有效的指针会发生什么，如果不是有效的指针，又会发生什么。如果我们在超前执行代码第4行，并且r0中是有效的指针，那么CPU会真实的加载指针的内容到r2寄存器的临时版本中。</p>
<p>如果r0中的指针指向的内容位于CPU的cache中，那么必然可以将内容拷贝到r2寄存器的临时版本。如果CPU的cache中没有包含数据，我并不清楚CPU是否会会从内存中读取r0中指针指向的内容。</p>
<p>对于我们来说，更有趣的一个问题是，如果r0中的指针不是一个有效的指针，会发生什么？如果r0中的指针不是一个有效的地址，并且我们在超前执行代码第4行，机器不会产生Fault。</p>
<p>机器或许知道r0是无效的地址，并且代码第4行尝试使用一个无效的地址，但是它不能产生Page Fault，因为它不能确定代码第4行是否是一个正确的代码分支，因为有可能CPU赌错了。</p>
<p>所以直到CPU知道了valid变量的内容，否则CPU不能在代码第4行生成Page Fault。也就是说，如果CPU发现代码第4行中r0内的地址是无效的，且valid变量为1，这时机器才会生成Page Fault。如果r0是无效的地址，且valid变量为0，机器不会生成Page Fault。</p>
<p>所以是否要产生Page Fault的决定，可能会推迟数百个CPU cycle，直到valid变量的值被确定。</p>
<p>当我们确定一条指令是否正确的超前执行了而不是被抛弃了这个时间点，对应的技术术语是Retired。</p>
<p>所以当我们说一个指令被超前执行，在某个时间点Retired，这时我们就知道这条指令要么会被丢弃，要么它应该实际生效，并且对机器处于可见状态。</p>
<p>一条指令如果是Retired需要满足两个条件，首先它自己要结束执行，比如说结束了从内存加载数据，结束了对数据加1；其次，所有之前的指令也需要Retired。</p>
<p>所以上面代码第4行在直到valid变量被从内存中加载出来且if被判定之前不能Retired，所以第4行的Retirement可能会延后数百个CPU cycle。</p>
<p>这是Meltdown攻击非常关键的一个细节。</p>
<hr>
<h2 id="speculative-execution2">Speculative execution(2)
</h2><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">r0</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">something</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">r1</span> <span class="o">=</span> <span class="n">valid</span> <span class="c1">//r1 is a register; valid is in RAM
</span></span></span><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">r1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">r2</span> <span class="o">=</span> <span class="o">*</span><span class="n">r0</span>
</span></span><span class="line"><span class="cl">  <span class="n">r3</span> <span class="o">=</span> <span class="n">r2</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">r3</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果r0中的内存地址是无效的，且在Page Table中完全没有映射关系，那么我也不知道会发生什么。如果r0中的内存地址在Page Table中存在映射关系，只是现在权限不够，比如说pte_u标志位为0，那么Intel的CPU会加载内存地址对应的数据，并存储在r2寄存器的临时版本中。</p>
<p>之后r2寄存器的临时版本可以被代码第5行使用。所以尽管r0中的内存地址是我们没有权限的内存，比如说一个内核地址，它的数据还是会被加载到r2，之后再加1并存储在r3中。</p>
<p>之后，当代码第4行Retired时，CPU会发现这是一个无效的读内存地址行为，因为PTE不允许读取这个内存地址。这时CPU会产生Page Fault取消执行后续指令，并回撤对于r2和r3寄存器的修改。</p>
<p>所以，在这里的例子中，CPU进行了两个推测：一个是CPU推测了if分支的走向，并选择了一个分支提前执行；除此之外，CPU推测了代码第4行能够成功完成。</p>
<p>对于load指令，如果数据在CPU缓存中且相应的PTE存在于Page Table，不论当前代码是否有权限，Intel CPU总是能将数据取出。如果没有权限，只有在代码第4行Retired的时候，才会生成Page Fault，并导致预测执行被取消。</p>
<blockquote>
<p>学生提问：我对CPU的第二个预测，也就是从r0中保存的内存地址加载数据有一些困惑，这是不是意味着r0对应的数据先被加载到了r2，然后再检查PTE的标志位？</p>
<p>Robert教授：完全正确。在预测的阶段，不论r0指向了什么地址，只要它指向了任何东西，内存中的数据会被加载到r2中。</p>
<p>之后，当load指令Retired时才会检查权限。如果我们并没有权限做操作，所有的后续指令的效果会被取消，也就是对于寄存器的所有修改会回滚。同时，Page Fault会被触发，同时寄存器的状态就像是预测执行的指令没有执行过一样。</p>
<p>学生提问：难道不能限制CPU在Speculative execution的时候，先检查权限，再执行load指令吗？看起来我们现在的问题就是我们在不知道权限的情况下读取了内存，如果我们能先知道权限，那么Speculative execution能不能提前取消？</p>
<p>Robert教授：这里有两个回答。首先，Intel芯片并不是这样工作的。其次，是的，我相信对于Intel来说如果先做权限检查会更简单，这样的话，在上面的例子中，r2寄存器就不会被修改。</p>
<p>你们或许注意到论文中提到，尽管AMD CPU的手册与Intel的一样，它们有相同的指令集，Meltdown Attack并不会在AMD CPU上生效。普遍接受的观点是，AMD CPU在Speculative execution时，如果没有权限读取内存地址，是不会将内存地址中的数据读出。</p>
<p>这就是为什么Meltdown Attack在AMD CPU上不生效的原因。最近的Intel CPU明显也采用了这种方法，如果程序没有权限，在Speculative execution的时候也不会加载内存数据。</p>
<p>这里使用哪种方式对于性能来说没有明显区别，或许在指令Retired的时候再检查权限能省一些CPU的晶体管吧。这里我要提醒一下，这里有很多内容都是猜的，不过我认为我说的都是对的。Intel和AMD并没有太披露具体的细节。</p>
</blockquote>
<p>这里有一些重要的术语。你可以从CPU手册中读到的，比如说一个add指令接收两个寄存器作为参数，并将结果存放在第三个寄存器，这一类设计被称为CPU的Architectural，或者通告的行为。</p>
<p>如果你读取一个你没有权限的内存地址，你会得到一个Page Fault，你不允许读取这个内存地址，这就是一种通告的行为。</p>
<p>CPU的实际行为被称作Micro-Architectural，CPU的通告行为与实际行为是模糊不清的。比如说CPU会悄悄的有Speculative execution。</p>
<p>CPU设计者在设计Micro-Architectural时的初衷是为了让它是透明的。的确有很多行为都发生在CPU内部，但是结果看起来就像是CPU完全按照手册在运行。</p>
<p>举个例子，在上面代码的第4行，或许Intel的CPU在读取内存时没有检查权限，但是如果权限有问题的话，在指令Retired的时候，所有的效果都会回滚，你永远也看不到你不该看到的内存内容。</p>
<p>所以看起来就跟CPU的手册一样，你不允许读取你没有权限的内存地址。这里Architectural和Micro-Architectural的区别是Meltdown Attack的主要攻击点。这里的攻击知道CPU内部是如何工作的。</p>
<hr>
<h2 id="cpu-caches">CPU caches
</h2><p>接下来我将介绍Micro-Architectural的另一个部分，也就是缓存。我知道大家都知道CPU有cache，但是缓存或多或少应该是也透明的。</p>
<p>让我画个图描述一下cache，因为我认为cache与Meltdown最相关。</p>
<p>首先，你有CPU核，这是CPU的一部分，它会解析指令，它包含了寄存器，它有加法单元，除法单元等等。所以这是CPU的执行部分。</p>
<p>当CPU核需要执行load/store指令时，CPU核会与内存系统通信。</p>
<p>内存系统一些cache其中包含了数据的缓存。首先是L1 data cache，它或许有64KB，虽然不太大，但是它特别的快。</p>
<p>如果你需要的数据在L1 cache中，只通过几个CPU cycle就可以将数据取回。L1 cache的结构包含了一些线路，每个线路持有了可能是64字节的数据。</p>
<p>这些线路是个表单，它们通过虚拟内存地址索引。如果一个虚拟内存地址在cache中，并且cache为这个虚拟内存地址持有了数据，那么实际中可以认为L1 cache中也包含了来自对应于虚拟内存地址的PTE的权限。</p>
<p>L1 cache是一个表单，当CPU核执行load指令时，首先硬件会检查L1 cache是否包含了匹配load指令的虚拟内存地址，如果有的话，CPU会直接将L1 cache中的数据返回，这样可以很快完成指令。</p>
<p>如果不在L1 cache，那么数据位于物理内存中，所以现在我们需要物理内存地址，这里需要Translation Lookaside Buffer（TLB），TLB是PTE的缓存。</p>
<p>现在我们会检查load指令中的虚拟内存地址是否包含在TLB中。如果不在TLB，我们就需要做大量的工作，我们需要从内存中读取相关的PTE。</p>
<p>让我们假设TLB中包含了虚拟内存地址对应的物理内存Page地址，我们就可以获取到所需要的物理内存地址。通常来说会有一个更大的cache（L2 cache），它是由物理内存地址索引。</p>
<p>现在通过TLB我们找到了物理内存地址，再通过L2 cache，我们有可能可以获取到数据。</p>
<p>如果我们没有在L2 cache中找到物理内存地址对应的数据。我们需要将物理内存地址发送给RAM系统。这会花费很长的时间，当我们最终获得了数据时，我们可以将从RAM读取到的数据加入到L1和L2 cache中，最终将数据返回给CPU核。</p>
<p><img src="/p/mit6s08122meltdown/p67.png"
	width="970"
	height="832"
	srcset="/p/mit6s08122meltdown/p67_hu_c2cfb38d83903353.png 480w, /p/mit6s08122meltdown/p67_hu_49922114e10bb0e3.png 1024w"
	loading="lazy"
	
		alt="p67"
	
	
		class="gallery-image" 
		data-flex-grow="116"
		data-flex-basis="279px"
	
></p>
<p>以上就是CPU的cache。</p>
<p>如果L1 cache命中的话可能只要几个CPU cycle，L2 cache命中的话，可能要几十个CPU cycle，如果都没有命中最后需要从内存中读取那么会需要几百个CPU cycle。</p>
<p>一个CPU cycle在一个2GHZ的CPU上花费0.5纳秒。所以拥有cache是极其有利的，如果没有cache的话，你将会牺牲掉几百倍的性能。所以cache对于性能来说是非常关键的。</p>
<p>在Meltdown Attack的目标系统中，如果我们运行在用户空间，L1和L2 cache可以既包含用户数据，也包含内核数据。L2 cache可以包含内核数据因为它只是物理内存地址。</p>
<p>L1 cache有点棘手，因为它是虚拟内存地址，当我们更换Page Table时，L1 cache的内容不再有效。因为更换Page Table意味着虚拟内存地址的意义变了，所以这时你需要清空L1 cache。不过实际中会有更多复杂的细节，可以使得你避免清空L1 cache。</p>
<p>论文中描述的操作系统并没有在内核空间和用户空间之间切换的时候更换Page Table，因为两个空间的内存地址都映射在同一个Page Table中了。这意味着我们不必清空L1 cache，也意味着L1 cache会同时包含用户和内核数据，这使得系统调用更快。</p>
<p>如果你执行系统调用，当系统调用返回时，L1 cache中还会有有用的用户数据，因为我们在这个过程中并没与更换Page Table。</p>
<p>所以，当程序运行在用户空间时，L1 cache中也非常有可能有内核数据。L1 cache中的权限信息拷贝自TLB中的PTE，如果用户空间需要访问内核内存数据，尽管内核数据在L1 cache中，你也不允许使用它，如果使用的话会触发Page Fault。</p>
<p>尽管Micro-Architectural的初衷是完全透明，实际中不可能做到，因为Micro-Architectural优化的意义在于提升性能，所以至少从性能的角度来说，它们是可见的。也就是说你可以看出来你的CPU是否有cache，因为如果没有的话，它会慢几百倍。</p>
<p>除此之外，如果你能足够精确测量时间，那么在你执行一个load指令时，如果load在几个CPU cycle就返回，数据必然是在cache中，如果load在几百个CPU cycle返回，数据可能是从RAM中读取，如果你能达到10纳秒级别的测量精度，你会发现这里区别还是挺大的。</p>
<p>所以从性能角度来说，Micro-Architectural绝对不是透明的。我们现在讨论的分支预测，cache这类功能至少通过时间是间接可见的。</p>
<p>所以尽管Micro-Architectural设计的细节都是保密的，但是很多人对它都有强烈的兴趣，因为这影响了很多的性能。比如说编译器作者就知道很多Micro-Architectural的细节，因为很多编译器优化都基于人们对于CPU内部工作机制的猜测。</p>
<p>实际中，CPU制造商发布的优化手册披露了一些基于Micro-Architectural的技巧，但是他们很少会介绍太多细节，肯定没有足够的细节来理解Meltdown是如何工作的。所以Micro-Architectural某种程度上说应该是透明的、隐藏的、不可见的，但同时很多人又知道一些随机细节。</p>
<blockquote>
<p>学生提问：L1 cache是每个CPU都有一份，L2 cache是共享的对吧？</p>
<p>Robert教授：不同CPU厂商，甚至同一个厂商的不同型号CPU都有不同的cache结构。今天普遍的习惯稍微有点复杂，在一个多核CPU上，每一个CPU核都有一个L1 cache，它离CPU核很近，它很快但是很小。每个CPU核也还有一个大点的L2 cache。除此之外，通常还会有一个共享的L3 cache。</p>
<p>另一种方式是所有的L2 cache结合起来，以方便所有的CPU共用L2 cache，这样我可以非常高速的访问我自己的L2 cache，但是又可以稍微慢的访问别的CPU的L2 cache，这样有效的cache会更大。</p>
<p>所以通常你看到的要么是三级cache，或者是两级cache但是L2 cache是合并在一起的。典型场景下，L2和L3是物理内存地址索引，L1是虚拟内存地址索引。</p>
<p>学生提问：拥有物理内存地址的缓存有什么意义？</p>
<p>Robert教授：如果同一个数据被不同的虚拟内存地址索引，虚拟内存地址并不能帮助你更快的找到它。而L2 cache与虚拟内存地址无关，不管是什么样的虚拟内存地址，都会在L2 cache中有一条物理内存地址记录。</p>
<p>学生提问：MMU和TLB这里位于哪个位置？</p>
<p>Robert教授：我认为在实际中最重要的东西就是TLB，并且我认为它是与L1 cache并列的。如果你miss了L1 cache，你会查看TLB并获取物理内存地址。MMU并不是一个位于某个位置的单元，它是分布在整个CPU上的。</p>
<p>学生提问：但是MMU不是硬件吗？</p>
<p>Robert教授：是的，这里所有的东西都是硬件。CPU芯片有数十亿个晶体管，所以尽管是硬件，我们讨论的也是使用非常复杂的软件设计的非常复杂的硬件。所以CPU可以做非常复杂和高级的事情。所以是的，它是硬件，但是它并不简单直观。</p>
<p>学生提问：Page Table的映射如果没有在TLB中命中的话，还是要走到内存来获取数据，对吧？</p>
<p>Robert教授：从L2 cache的角度来说，TLB miss之后的查找Page Table就是访问物理内存，所以TLB需要从内存中加载一些内存页，因为这就是加载内存，这些内容可以很容易将Page Table的内容缓存在L2中。</p>
<blockquote>
<p>虚拟地址到物理地址的映射表主要存储在内存中。不过，为了提高查询效率，系统使用了一个称为转换后备缓冲区（Translation Lookaside Buffer, TLB）的缓存装置。</p>
<p>TLB：</p>
<ol>
<li>存储最近使用的虚拟地址到物理地址的映射。</li>
<li>是一种小型的、高速的缓存，能加快地址转换过程。</li>
</ol>
<p>内存：</p>
<ol>
<li>完整的虚拟地址到物理地址映射表（页表）存储在内存中。</li>
<li>当TLB未命中时，需访问内存中的页表来完成地址转换。</li>
</ol>
<p>L1, L2, L3 缓存：</p>
<ol>
<li>主要用于缓存数据和指令，不存储地址映射表。</li>
</ol>
<p>总结：映射表主要在内存中，TLB用于缓存一部分映射以提高查询速度</p>
</blockquote>
</blockquote>
<hr>
<h2 id="flush-and-reload">Flush and Reload
</h2><p>为什么Cache与Meltdown相关呢？接下来我将讨论一下<a class="link" href="https://pdos.csail.mit.edu/6.828/2020/readings/meltdown.pdf"  target="_blank" rel="noopener"
    >论文</a>

中使用Cache的主要方法。</p>
<p>论文中讨论了这种叫做Flush and Reload的技术，这个技术回答了一个问题：一段特定的代码是否使用了特定内存地址的数据？这个技术本身并不是一个直接的安全漏洞，因为它只能基于你有权限的内存地址工作。</p>
<p>所以如果你是用户代码，你可以使用属于你的用户空间内存，并且你现在要调用一个你自己的函数，你可以使用Flush and Reload来知道你刚刚执行的函数是否使用了某个属于你自己的内存。</p>
<p>你不能直接使用这种技术来获取其他进程的私有内存。进程之间有时候会共享内存，你还是可以访问这部分共享的内存。所以Flush and Reload回答了这个问题，特定的函数是否使用了特定内存地址？</p>
<p>它的具体工作步骤如下：</p>
<ul>
<li>
<p>第一步，假设我们对地址X感兴趣，我们希望确保Cache中并没有包含位于X的内存数据。</p>
<p>实际中，为了方便，Intel提供了一条指令，叫做clflush，它接收一个内存地址作为参数，并确保该内存地址不在任何cache中。</p>
<p>这超级方便，不过即使CPU并没有提供这样的指令，实际中也有方法能够删除Cache中的数据，举个例子，如果你知道Cache有64KB，那么你load 64KB大小的随机内存数据，这些数据会被加载到Cache中，这时Cache中原本的数据会被冲走，因为Cache只有64KB大小。所以即使没有这个好用的指令，你仍然可以清空Cache中的所有数据。</p>
</li>
<li>
<p>第二步，如果你对某段可能使用了内存地址X的代码感兴趣，你可以调用这个函数，先不管这个函数做了什么，或许它使用了内存地址X，或许没有。</p>
</li>
<li>
<p>现在，你想要知道X是否在Cache中，如果是的话，因为在第一步清空了Cache，必然是因为第二步的函数中load了这个内存地址。所以你现在想要执行load，但是你更想知道load花费了多长时间，而且我们这里讨论的是纳秒级别的时间，比如5个纳秒或者100个纳秒，那么我们该怎样达到这种测量精度呢？</p>
<p>这是个困难的任务。Intel CPU会提供指令来向你返回CPU cycle的数量，这被称为rdtsc。所以这里我们会执行rdtsc指令，它会返回CPU启动之后总共经过了多少个CPU cycle。如果是2GHZ的CPU，这意味着通过这个指令我们可以得到0.5纳秒的测量精度。</p>
</li>
<li>
<p>现在我们会将内存地址X的数据加载到junk对象中。</p>
</li>
<li>
<p>然后再通过rdtsc读取时间。如果两次读取时间的差是个位数，那么上一步的load指令走到了cache中，也就是第二步的函数中使用了内存地址X的数据。</p>
<p>如果两次读取时间的差别超过100，这意味着内存地址X不在cache中，虽然这并不绝对，但是这可能代表了第二步的函数中并没有使用内存X的数据。因为函数中可能使用了内存地址X，然后又用了其他与X冲突的数据，导致内存地址X又被从cache中剔除了。</p>
<p>但是对于简单的情况，如果两次时间差较大那么第二步的函数没有使用内存地址X，如果两次时间差较小那么第二步函数使用了内存地址X。</p>
</li>
</ul>
<p>现在还没有涉及到攻击，因为这里我们需要能够访问到内存地址X，所以这是我们可以访问的内存地址。</p>
<p>以上就是有关Meltdown的前置知识。</p>
<hr>
<h2 id="meltdown-attack">Meltdown Attack
</h2><p>接下来让我们回到Meltdown。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">8192</span><span class="p">]</span>       <span class="c1">// L1
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// the Flush of Flush+Reload
</span></span></span><span class="line"><span class="cl"><span class="n">clflush</span> <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">clflush</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4096</span><span class="p">]</span>    <span class="c1">// L5
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="n">some</span> <span class="n">expensive</span> <span class="n">instruction</span> <span class="n">like</span> <span class="n">divide</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">r1</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">kernel</span> <span class="n">virtual</span> <span class="n">address</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">r2</span> <span class="o">=</span> <span class="o">*</span><span class="n">r1</span>             <span class="c1">// L10
</span></span></span><span class="line"><span class="cl"><span class="n">r2</span> <span class="o">=</span> <span class="n">r2</span> <span class="o">&amp;</span> <span class="mi">1</span>          <span class="c1">// speculated
</span></span></span><span class="line"><span class="cl"><span class="n">r2</span> <span class="o">=</span> <span class="n">r2</span> <span class="o">*</span> <span class="mi">4096</span>       <span class="c1">// speculated
</span></span></span><span class="line"><span class="cl"><span class="n">r3</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="n">r2</span><span class="p">]</span>         <span class="c1">// speculated
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="n">handle</span> <span class="n">the</span> <span class="n">page</span> <span class="n">fault</span> <span class="n">from</span> <span class="s">&#34;r2 = *r1&#34;</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// the Reload of Flush+Reload
</span></span></span><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="n">rdtsc</span>            <span class="c1">// L18
</span></span></span><span class="line"><span class="cl"><span class="n">r0</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span> <span class="o">=</span> <span class="n">rdtsc</span>
</span></span><span class="line"><span class="cl"><span class="n">r1</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4096</span><span class="p">]</span>       <span class="c1">// L21
</span></span></span><span class="line"><span class="cl"><span class="n">c</span> <span class="o">=</span> <span class="n">rdtsc</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="n">b</span><span class="o">-</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-</span><span class="nl">b</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">low</span> <span class="n">bit</span> <span class="n">was</span> <span class="n">probably</span> <span class="n">a</span> <span class="mi">1</span>   <span class="c1">// L24
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这段代码比22.1里面的代码更加完整，这里是一个更完整的Meltdown攻击代码，这里我们增加了Flush and Reload代码。</p>
<p>首先我们声明了一个buffer，现在我们只需要从内核中窃取1个bit的数据，我们会将这个bit乘以4096，所以我们希望下面的Flush and Reload要么看到buffer[0]在cache中，要么看到buffer[4096]在cache中。</p>
<p>为什么要有这么的大的间隔？是因为硬件有预获取。如果你从内存加载一个数据，硬件极有可能会从内存中再加载相邻的几个数据到cache中。</p>
<p>所以我们不能使用两个非常接近的内存地址，然后再来执行Flush and Reload，我们需要它们足够的远，这样即使有硬件的预获取，也不会造成困扰。所以这里我们将两个地址放到了两个内存Page中（注，一个内存Page 4096）。</p>
<p>现在的Flush部分直接调用了clflush指令（代码第4第5行），来确保我们buffer中相关部分并没有在cache中。</p>
<p>代码第7行或许并不必要，这里我们会创造时间差。我们将会在第10行执行load指令，它会load一个内核内存地址，所以它会产生Page Fault。但是我们期望能够在第10行指令Retired之前，也就是实际的产生Page Fault并取消这些指令效果之前，再预测执行（Speculative execution）几条指令。</p>
<p>如果代码第10行在下面位置Retired，那么对我们来说就太早了。实际中我们需要代码第13行被预测执行，这样才能完成攻击。</p>
<p>所以我们希望代码第10行的load指令尽可能晚的Retired，这样才能推迟Page Fault的产生和推迟取消预测执行指令的效果。因为我们知道一个指令只可能在它之前的所有指令都Retired之后，才有可能Retired。</p>
<p>所以在代码第7行，我们可以假设存在一些非常费时的指令，它们需要很长时间才能完成。或许要从RAM加载一些数据，这会花费几百个CPU cycle；或许执行了除法，或者平方根等。</p>
<p>这些指令花费了很多时间，并且很长时间都不会Retired，因此也导致代码第10行的load很长时间也不会Retired，并给第11到13行的代码时间来完成预测执行。</p>
<p>现在假设我们已经有了内核的一个虚拟内存地址，并且要执行代码第10行。我们知道它会生成一个Page Fault，但是它只会在Retired的时候才会真正的生成Page Fault。我们设置好了使得它要过一会才Retired。</p>
<p>因为代码第10行还没有Retired，并且在Intel CPU上，即使你没有内存地址的权限，数据也会在预测执行的指令中被返回。这样在第11行，CPU可以预测执行，并获取内核数据的第0个bit。第12行将其乘以4096。第13行是另一个load指令，load的内存地址是buffer加上r2寄存器的内容。</p>
<p>我们知道这些指令的效果会被取消，因为第10行会产生Page Fault，所以对于r3寄存器的修改会被取消。但是尽管寄存器都不会受影响，代码第13行会导致来自于buffer的部分数据被加载到cache中。取决于内核数据的第0bit是0还是1，第13行会导致要么是buffer[0]，要么是buffer[4096]被加载到cache中。</p>
<p>之后，尽管r2和r3的修改都被取消了，cache中的变化不会被取消，因为这涉及到Micro-Architectural，所以cache会被更新。</p>
<p>第15行表示最终Page Fault还是会发生，并且我们需要从Page Fault中恢复。用户进程可以注册一个Page Fault Handler（注，详见Lec17），并且在Page Fault之后重新获得控制。论文还讨论了一些其他的方法使得发生Page Fault之后可以继续执行程序。</p>
<p>现在我们需要做的就是弄清楚，是buffer[0]还是buffer[4096]被加载到了cache中。现在我们可以完成Flush and Reload中的Reload部分了。第18行获取当前的CPU时间，第19行load buffer[0]，第20行再次读取当前CPU时间，第21行load buffer[4096]，第22行再次读取当前CPU时间，第23行对比两个时间差。</p>
<p>哪个时间差更短，就可以说明内核数据的bit0是0还是1。如果我们重复几百万次，我们可以扫描出所有的内核内存。</p>
<blockquote>
<p>学生提问：在这里例子中，如果b-a&lt;c-b，是不是意味着buffer[0]在cache中？</p>
<p>Robert教授：是的，你是对的。</p>
<p>学生提问：在第9行之前，我们需要if语句吗？</p>
<p>Robert教授：并不需要，22.2中的if语句是帮助我展示Speculative execution的合理理由：尽管CPU不知道if分支是否命中，它还是会继续执行。</p>
<p>但是在这里，预测执行的核心是我们并不知道第10行的load会造成Page Fault，所以CPU会在第10行load之后继续预测执行。理论上，尽管这里的load可能会花费比较长的时间（例如数百个CPU cycle），但是它现在不会产生Page Fault，所以CPU会预测执行load之后的指令。如果load最终产生了Page Fault，CPU会回撤所有预测执行的效果。</p>
<p>预测执行会在任何长时间执行的指令，且不论这个指令是否能成功时触发。例如除法，我们不知道是否除以0。一旦触发预测执行，所有之后的指令就会开始被预测执行。不管怎样，真正核心的预测执行从第10行开始，但是为了让攻击更有可能成功，我们需要确保预测执行从第7行开始。</p>
<p>学生提问：在这个例子中，我们只读了一个bit，有没有一些其他的修改使得我们可以读取一整个寄存器的数据？</p>
<p>Robert教授：有的，将这里的代码运行64次，每次获取1个bit。</p>
<p>学生提问：为什么不能一次读取64bit呢？</p>
<p>Robert教授：如果这样的话，buffer需要是2^64再乘以4096，我们可能没有足够的内存来一次读64bit。或许你可以一次读8个bit，然后buffer大小是256*4096。</p>
<p>论文中有相关的，因为这里主要的时间在第17行到第24行，也就是Flush and Reload的Reload部分。如果一次读取一个字节，那么找出这个字节的所有bit，需要256次Reload，每次针对一个字节的可能值。</p>
<p>如果一次只读取一个bit，那么每个bit只需要2次Reload。所以一次读取一个bit，那么读取一个字节只需要16次Reload，一次读取一个字节，那么需要256次Reload。所以论文中说一次只读取一个bit会更快，这看起来有点反直觉，但是又好像是对的。</p>
<p>学生提问：这里的代码会运行在哪？会运行在特定的位置吗？</p>
<p>Robert教授：这取决于你对于机器有什么样的权限，并且你想要窃取的数据在哪了。</p>
<p>举个例子，你登录进了Athena（注，MIT的共享计算机系统），机器上还有几百个其他用户 ，然后你想要窃取某人的密码，并且你很有耐心。</p>
<p>在几年前Athena运行的Linux版本会将内核内存映射到每一个用户进程的地址空间。那么你就可以使用Meltdown来一个bit一个bit的读取内核数据，其中包括了I/O buffer和network buffer。如果某人在输入密码，且你足够幸运和有耐心，你可以在内核内存中看见这个密码。</p>
<p>实际中，内核可能会映射所有的物理内存，比如XV6就是这么做的，这意味着你或许可以使用Meltdown在一个分时共享的机器上，读取所有的物理内存，其中包括了所有其他进程的内存。</p>
<p>这样我就可以看到其他人在文本编辑器的内容，或者任何我喜欢的内容。这是你可以在一个分时共享的机器上使用Meltdown的方法。其他的场景会不太一样。</p>
<p>分时共享的机器并没有那么流行了，但是这里的杀手场景是云计算。如果你使用了云服务商，比如AWS，它会在同一个计算机上运行多个用户的业务，取决于AWS如何设置它的VMM或者容器系统，如果你购买了AWS的业务，那么你或许就可以窥探其他运行在同一个AWS机器上的用户软件的内存。我认为这是人们使用Meltdown攻击的方式。</p>
<p>另一个可能有用的场景是，当你的浏览器在访问web时，你的浏览器其实运行了很多不被信任的代码，这些代码是各种网站提供的，或许是以插件的形式提供，或许是以javascript的形式提供。</p>
<p>这些代码会被加载到浏览器，然后被编译并被运行。有可能当你在浏览网页的时候，你运行在浏览器中的代码会发起Meltdown攻击，而你丝毫不知道有一个网站在窃取你笔记本上的内容，但是我并不知道这里的细节。</p>
<p>学生提问：有人演示过通过javascript或者WebAssembly发起攻击吗？</p>
<p>Robert教授：我不知道。人们肯定担心过WebAssembly，但是我不知道通过它发起攻击是否可行。对于javascript我知道难点在于时间的测量，你不能向上面一样获取到纳秒级别的时间，所以你并不能使用Flush and Reload。或许一些更聪明的人可以想明白怎么做，但是我不知道。</p>
</blockquote>
<p>实际中Meltdown Attack并不总是能生效，具体的原因我认为论文作者并没有解释或者只是猜测了一下。如果你查看论文的最后一页，</p>
<p>你可以看到Meltdown Attack从机器的内核中读取了一些数据，这些数据里面有一些XXXX，这些是没能获取任何数据的位置，也就是Meltdown Attack失败的位置。</p>
<p>论文中的Meltdown Attack重试了很多很多次，因为在论文6.2还讨论了性能，说了在某些场景下，获取数据的速率只有10字节每秒，这意味着代码在那不停的尝试了数千次，最后终于获取到了数据，也就是说Flush and Reload表明了两个内存地址只有一个在Cache中。</p>
<p>所以有一些无法解释的事情使得Meltdown会失败，从上图看，Meltdown Attack获取了一些数据，同时也有一些数据无法获得。</p>
<p>据我所知，人们并不真的知道所有的成功条件和失败条件，最简单的可能是如果内核数据在L1 cache中，Meltdown能成功，如果内核数据不在L1 Cache中，Meltdown不能成功。如果内核数据不在L1 cache中，在预测执行时要涉及很多机制，很容易可以想到如果CPU还不确定是否需要这个数据，并不一定会完成所有的工作来将数据从RAM中加载过来。</p>
<p>你可以发现实际中并没有这么简单，因为论文说到，有时候当重试很多次之后，最终还是能成功。所以这里有一些复杂的情况，或许在CPU内有抢占使得即使内核数据并不在Cache中，这里的攻击偶尔还是可以工作。</p>
<p>论文的最后也值得阅读，因为它解释了一个真实的场景，比如说我们想要通过Meltdown窃取Firefox的密码管理器中的密码，你该怎么找出内存地址，以及一个攻击的完整流程，我的意思是由学院派而不是实际的黑客完成的一次完整的攻击流程。尽管如此，这里也包含了很多实用的细节。</p>
<hr>
<h2 id="meltdown-fix">Meltdown Fix
</h2><p>我最后想讨论的是Meltdown的修复，你们实际已经接触了一些了。当<a class="link" href="https://pdos.csail.mit.edu/6.828/2020/readings/meltdown.pdf"  target="_blank" rel="noopener"
    >论文</a>

发表的时候，它获取了很多的关注。实际中还有另一篇论文，也是由这篇论文的部分作者参与完成，另一篇论文讨论了一种使用了CPU内一种叫做Spectre的不同的预测执行的不同攻击方法。这一对论文的同时出现让人非常兴奋。</p>
<p>所以人们现在发现危害太大了，因为现在我们讨论的是操作系统的隔离性被破坏了。这里的技术破坏了Page Table的保护，这是我们用来实现用户和内核间隔离的技术，所以这是一个非常基础的攻击，或者至少以一种非常通用的方式破坏了安全性非常重要的一个部分。所以人们非常非常迫切的想要修复Meltdown。</p>
<p>很多操作系统在这篇论文发表之后数周内就推出的一个快速修复，这是一个叫做KAISER，现在在Linux中被称为KPTI的技术（Kernel page-table isolation）。</p>
<p>这里的想法很简单，也就是不将内核内存映射到用户的Page Table中，相应的就像XV6一样，在系统调用时切换Page Table。所以在用户空间时，Page Table只有用户内存地址的映射，如果执行了系统调用，会有类似于XV6中trampoline的机制，切换到拥有内核内存映射的另一个Page Table中，这样才能执行内核代码。</p>
<p>这会导致Meltdown不能工作，因为现在你会切换Page Table，本来代表内核虚拟内存地址的r1寄存器不仅是没有权限，并且也没有意义了，因为现在的用户Page Table并没有包含对它的翻译，所以CPU并不知道该如何处理这个内存地址。</p>
<p>现在这个虚拟内存地址不会存在于cache中，甚至都不会出现在TLB中。所以当在用户空间发起Meltdown Attack时，也就没有办法知道对应这个虚拟内存地址的数据是什么。这个虚拟内存地址并不是非法的，只是在用户空间没有意义了，这样会导致Meltdown Attack不能工作。</p>
<p>KAISER的缺点是，系统调用的代价更高了，因为如果不做任何事情的话，切换Page Table会导致TLB被清空，因为现在TLB中的映射关系都是前一个Page Table的。同时也会导致L1 cache被清空，因为其中对应的虚拟内存地址对于新的Page Table也没有意义了。在一些机器上，切换Page Table会使得系统调用明显变慢。</p>
<p>最近的CPU拥有叫做PCID（process-context identifiers）的技术，它可以帮助你在切换Page Table时避免清空Cache，尽管它还是要花费一些时间。</p>
<p>如果你上网看的话，当时人们有很多顾虑，当时人们认为这种两个Page Table的方案是不可接受的慢。但是实际中这并不是一个严重的问题，你上网看的话就可以发现人们有对于工作负载的整体影响的评估，因为毕竟程序也不是一直在进出内核，这里的影响大概是5%，所以这并不是一个坏的主意。</p>
<p>人们非常快的采用了这种方案，实际上在论文发表时，已经有内核采用了这种方案来抵御其他的攻击。</p>
<p>除此之外，还有一个合理的硬件修复。我相信Intel在最近的处理器上已经添加了这个修复，AMD之前就已经有这个修复。</p>
<p><img src="D:%5cUsers%5cnote%5cXV6%5cp67.png"
	
	
	
	loading="lazy"
	
		alt="p67"
	
	
></p>
<p>这是Cache的结构，当指令从L1 cache中加载某个数据时，比如说我们想要窃取的内核数据，人们认为数据的权限标志位就在L1 cache中，所以CPU完全可以在获取数据的时候检查权限标志位。</p>
<p>实际中，AMD CPU和最近的Intel CPU会在很早的时候检查权限标志位。如果检查不能通过，CPU不会返回数据到CPU核中。所以没有一个预测执行指令可以看到不该看到的数据。</p>
<blockquote>
<p>学生提问：为什么你觉得Intel会做这个呢？对我来说这里像是个讨论，我们应该为预测执行指令检查权限标志位吗？Intel的回答是不，为什么要检查呢？</p>
<p>Robert教授：是的，为什么要检查呢？反正用户也看不到对应的数据。如果更早的做权限检查，会在CPU核和L1 cache之间增加几个数字电路门，而CPU核和L1 cache之间路径的性能对于机器来说重要的，如果你能在这节省一些数字电路门的话，这可以使得你的CPU节省几个cycle来从L1 cache获取数据，进而更快的运行程序。</p>
<p>所以很容易可以想到如果过早的检查权限，会在电路上增加几个晶体管。因为毕竟所有的预测执行指令都会Retired，并不是说过早的检查权限就可以节省一些后续的工作，在指令Retired的时候还是要触发Page Fault。我这里只是猜测，这里做一些权限检测并不能带来什么优势。</p>
<p>学生提问：既然Intel已经从CPU上修复了这个问题，有没有哪个内核计划取消KAISER来提升性能？</p>
<p>Robert教授：我知道在很多内核上，这个是可选项，但是我并不完全清楚Intel修复的具体内容。我很确定他们有一些修复，但是具体内容我并不知道。</p>
<p>Frans教授：我认为Linux中你可以查询哪些硬件修复已经存在，并根据返回要求Linux修改从软件对于硬件问题的规避。你可以在你的笔记本上运行一个Linux命令来查看它包含了哪些问题的修复，哪些问题已经在硬件中规避了。</p>
<p>Robert教授：你是说如果CPU包含了修复的话，Linux实际会使用combined Page Table（注，也就是将内核内存映射到用户Page Table中）？</p>
<p>Frans教授：是的，我99%相信是这样的，虽然我最近没有再看过了，但是我认为还是这样的。</p>
<p>学生提问：人们是在干什么的时候发现这个的？</p>
<p>Robert教授：当人们尝试入侵一个计算机的时候。谁知道人们真正想要干什么呢？论文是由学院派写的，或许他们在研究的时候发现了一些安全问题。</p>
<p>Frans教授：我认为很长时间他们的一个驱动力是，他们想破解Address Space Layout Randomization，他们有一些更早的论文，看起来在这个领域有一些研究者。我认为最开始的时候，人们来自不同的领域。 就像Robert说过的，人们在这个领域工作了几十年来找到可以理解和攻击的Bug。</p>
<p>学生提问：有多大的可能还存在另一种Meltdown？</p>
<p>Robert教授：非常有可能。CPU制造商在几十年间向CPU增加了非常非常多酷炫的技术，以使得CPU运行的可以更快一些。人们之前并没有太担忧或者没有觉得这会是一个严重的安全问题。</p>
<p>现在人们非常清楚这可能会是非常严重的安全问题，但是我们现在使用的CPU已经包含了30年的聪明思想，实际上在论文发表之前，已经存在很多基于Micro-Architectural的这一类攻击。我认为还需要一段时间才能把这一类问题完全消除。</p>
<p>Frans教授：如果你查看过去两年的安全相关的会议，每个会议基本都有一个session是有关探索预测执行属性，来看看能不能发起一次攻击。</p>
<p>Robert教授：或许这是一个更大的问题，是不是我们解决了有限的问题就没事了，又或者是上层设计方法出现问题了。这可能太过悲观了，但是你知道的，人们对于操作系统的隔离寄托了太多期望，可以非常合理的认为隔离可以工作。</p>
<p>并且我们会在这种假设下设计类似于云计算，在浏览器中运行Javascript等等场景。但是现在这种假设实际并不成立，曾经人们认为操作系统的隔离性足够接近成立，但是这一整套基于Micro-Architectural的攻击使得这里的故事不再让人信服。</p>
<p>学生提问：CPU设计者可以做到什么程度使得不使用Micro-Architectural又能保持高性能，同时也有很好的安全性？</p>
<p>Robert教授：有些内容明显是可以修复的，比如这节课介绍的Meltdown Attack是可以被修复的，并且不会牺牲任何性能。对于一些其他的攻击，并不十分确定你可以在不损伤性能的前提下修复它们。</p>
<p>有些问题隐藏的非常非常的深，现在有很多共享的场景，例如分时共享的计算机，云计算。假设在你的云主机上有一个磁盘驱动和一个网卡驱动，你或许可以仅仅通过监测别人的流量是怎么影响你的流量的，这里的流量包括了网络流量和磁盘流量，来获取同一个主机上的其他用户信息。</p>
<p>我不知道这是否可行，但是对于很多东西，人们都能发现可以攻击的点。</p>
<p>所以很多这里的Micro-Architectural带来的问题可以在不损伤性能的前提下清除掉，但是也或许不能。</p>
</blockquote>

</section>


    <footer class="article-footer">
    

    <section class="article-lastmod">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <span>
            最后更新于 Sep 03, 2025 22:10 &#43;0800
        </span>
    </section></footer>




    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI&#43;WdtXRGWt2kTvGFasHpSy3SV"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG&#43;vnGctmUb0ZY0l8"crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05"crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.body, {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>
    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="has-image">
    <a href="/p/mit6s08123rcu/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08123rcu/bg.91a08bf3fe0a8ca435e8fbc902291fd5_hu_b6ef8ea2c8ceedc0.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：23RCU"
                        
                        data-hash="md5-kaCL8/4KjKQ16PvJAikf1Q==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：23RCU</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/mit6s08121networking/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08121networking/bg.68c4376fd87b0b35da07319dd155c90d_hu_702cc6dbf23ff4b6.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：21Networking"
                        
                        data-hash="md5-aMQ3b9h7CzXaBzGd0VXJDQ==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：21Networking</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/mit6s08120kernels-and-hll/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08120kernels-and-hll/bg.4175e6a2793e0fc340e5aced2529e40b_hu_900f2fcc83e9e964.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：20Kernels and HLL"
                        
                        data-hash="md5-QXXmonk&#43;D8NA5aztJSnkCw==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：20Kernels and HLL</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/mit6s08119virtual-machines/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08119virtual-machines/bg.b02a7ba1d946705c0cf2809bcf960db8_hu_3d3ad0ec0320c7b4.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：19Virtual Machines  "
                        
                        data-hash="md5-sCp7odlGcFwM8oCbz5YNuA==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：19Virtual Machines  </h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/mit6s08118os-organization/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08118os-organization/bg.6254618fb3eb08f3bf5d7cd89d4cd672_hu_646dc659ecd15a3f.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：18OS organization"
                        
                        data-hash="md5-YlRhj7PrCPO/XXzYnUzWcg==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：18OS organization</h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    

    <footer class="site-footer">

    <section class="copyright">
        &copy; 
        
            2024 - 
        
        2025 echudet
    </section>
    
    <section class="powerby">
        


        <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>

        <script language="javascript"> 
            var now = new Date();
            function createtime(){
                now.setTime(now.getTime()+250);
                var grt= new Date("2024/11/10 00:00:00"); 
                days = (now - grt ) / 1000 / 60 / 60 / 24;
                dnum = Math.floor(days);
                hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
                hnum = Math.floor(hours);
                if(String(hnum).length ==1 ){hnum = "0" + hnum;}
                minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
                mnum = Math.floor(minutes);
                if(String(mnum).length ==1 ){mnum = "0" + mnum;}
                seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
                snum = Math.round(seconds);
                if(String(snum).length ==1 ){snum = "0" + snum;}

                document.getElementById("timeDate").innerHTML = "本站已稳定运行"+dnum+" 天 ";
                document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒<br>"
            }
            setInterval("createtime()",250); 
        </script> 

        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        
    
        
         
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
        

        共 745148 字 , 39 篇文章<br>使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.29.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>

</footer>



    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>


    </body>
</html>
