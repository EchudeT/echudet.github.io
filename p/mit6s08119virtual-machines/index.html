<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="VMM提供了对于操作系统的一种不同视角。在操作系统的架构中，内核之上提供的封装单元是我们熟悉的进程，内核管理的是多个用户进程。而在VMM的架构中，VMM之上提供的封装单元是对计算机的模拟。VMM的架构使得我们可以从另一个角度重新审视我们讨论过的内容，例如内存分配，线程调度等等，这或许可以给我们一些新的思路并带回到传统的操作系统内核中。">
<title>MIT6S081：19Virtual Machines  </title>

<link rel='canonical' href='https://echudet.github.io/p/mit6s08119virtual-machines/'>

<link rel="stylesheet" href="/scss/style.min.86fc5e5efb829fb1bdd7a2d2275017fb3ae01ba7fcf491e347d76495ae5e3ae2.css"><meta property='og:title' content="MIT6S081：19Virtual Machines  ">
<meta property='og:description' content="VMM提供了对于操作系统的一种不同视角。在操作系统的架构中，内核之上提供的封装单元是我们熟悉的进程，内核管理的是多个用户进程。而在VMM的架构中，VMM之上提供的封装单元是对计算机的模拟。VMM的架构使得我们可以从另一个角度重新审视我们讨论过的内容，例如内存分配，线程调度等等，这或许可以给我们一些新的思路并带回到传统的操作系统内核中。">
<meta property='og:url' content='https://echudet.github.io/p/mit6s08119virtual-machines/'>
<meta property='og:site_name' content='echudet'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2024-10-04T22:02:50&#43;08:00'/><meta property='article:modified_time' content='2024-11-12T23:05:03&#43;08:00'/><meta property='og:image' content='https://echudet.github.io/p/mit6s08119virtual-machines/bg.jpg' />
<meta name="twitter:title" content="MIT6S081：19Virtual Machines  ">
<meta name="twitter:description" content="VMM提供了对于操作系统的一种不同视角。在操作系统的架构中，内核之上提供的封装单元是我们熟悉的进程，内核管理的是多个用户进程。而在VMM的架构中，VMM之上提供的封装单元是对计算机的模拟。VMM的架构使得我们可以从另一个角度重新审视我们讨论过的内容，例如内存分配，线程调度等等，这或许可以给我们一些新的思路并带回到传统的操作系统内核中。"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://echudet.github.io/p/mit6s08119virtual-machines/bg.jpg' />
    <link rel="shortcut icon" href="/timer.ico" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu11199958555974308744.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">⌨️</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">echudet</a></h1>
            <h2 class="site-description">探索编程的学生一枚</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/EchudeT'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://twitter.com'
                        target="_blank"
                        title="Twitter"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>档案</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>Links</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#课前预习">课前预习</a></li>
    <li><a href="#论文速览">论文速览</a></li>
    <li><a href="#虚拟化硬件">虚拟化硬件</a></li>
    <li><a href="#特权硬件">特权硬件</a></li>
    <li><a href="#dune和传统虚拟机管理程序vmm的差异">Dune和传统虚拟机管理程序（VMM）的差异</a></li>
    <li><a href="#dune-技术"><strong>Dune 技术</strong></a></li>
    <li><a href="#dune的系统调用拦截"><strong>Dune的系统调用拦截</strong></a></li>
    <li><a href="#dune用户态执行指令"><strong>Dune用户态执行指令</strong></a></li>
    <li><a href="#dune模式和页表">Dune模式和页表</a></li>
    <li><a href="#ept-format-incompatibility问题">EPT format incompatibility问题</a></li>
    <li><a href="#ept-fault是vm-exit">EPT Fault是VM Exit</a></li>
    <li><a href="#tsc时间戳计数器">TSC（时间戳计数器）</a></li>
    <li><a href="#dune处理信号signals">Dune处理信号（signals）</a></li>
    <li><a href="#vpid的实现与工作原理">VPID的实现与工作原理</a></li>
    <li><a href="#vmcall与syscall">VMCALL与SYSCALL</a></li>
    <li><a href="#进程切换到dune模式的启动流程">进程切换到Dune模式的启动流程</a></li>
    <li><a href="#sandbox防御elf-header-攻击">sandbox防御ELF header 攻击</a></li>
    <li><a href="#machine-abstraction">Machine Abstraction</a></li>
    <li><a href="#虚拟化硬件可以被配置成避免为虚拟机保存和恢复某些硬件状态">虚拟化硬件可以被配置成避免为虚拟机保存和恢复某些硬件状态</a></li>
    <li><a href="#vmm">VMM</a></li>
    <li><a href="#vm-entry和vm-exit"><strong>VM entry</strong>和<strong>VM exit</strong></a></li>
    <li><a href="#vm-exit将控制权交还给内核">VM Exit，将控制权交还给内核</a></li>
    <li><a href="#权限分离privilege-separation">权限分离（Privilege Separation）</a></li>
    <li><a href="#sthread-回收时的脏位">sthread 回收时的脏位</a></li>
    <li><a href="#影子页表shadow-page-table">影子页表（Shadow Page Table）</a></li>
    <li><a href="#正课部分">正课部分</a></li>
    <li><a href="#why-virtual-machine">Why Virtual Machine</a></li>
    <li><a href="#trap-and-emulate-----trap">Trap-and-Emulate &mdash; Trap</a></li>
    <li><a href="#trap-and-emulate-----emulate">Trap-and-Emulate &mdash; Emulate</a></li>
    <li><a href="#trap-and-emulate-----page-table">Trap-and-Emulate &mdash; Page Table</a></li>
    <li><a href="#trap-and-emulate-----devices">Trap-and-Emulate &mdash; Devices</a></li>
    <li><a href="#硬件对虚拟机的支持">硬件对虚拟机的支持</a></li>
    <li><a href="#dune-safe-user-level-access-to-privileged-cpu-features">Dune: Safe User-level Access to Privileged CPU Features</a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/mit6s08119virtual-machines/">
                <img src="/p/mit6s08119virtual-machines/bg_hu6414150680270374491.jpg"
                        srcset="/p/mit6s08119virtual-machines/bg_hu6414150680270374491.jpg 800w, /p/mit6s08119virtual-machines/bg_hu108375851198926742.jpg 1600w"
                        width="800" 
                        height="529" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：19Virtual Machines  " />
                
            </a>
        </div>
    

    <div class="article-details">


    
    <header class="article-category">
        
            <a href="/categories/mit6s081/" >
                Mit6s081
            </a>
        
            <a href="/categories/os/" >
                Os
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/mit6s08119virtual-machines/">MIT6S081：19Virtual Machines  </a>
        </h2>
    
        
        <h3 class="article-subtitle">
            VMM提供了对于操作系统的一种不同视角。在操作系统的架构中，内核之上提供的封装单元是我们熟悉的进程，内核管理的是多个用户进程。而在VMM的架构中，VMM之上提供的封装单元是对计算机的模拟。VMM的架构使得我们可以从另一个角度重新审视我们讨论过的内容，例如内存分配，线程调度等等，这或许可以给我们一些新的思路并带回到传统的操作系统内核中。
        </h3>
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2024-10-04</time>
            </div>
        

        
            <div>
                <?xml version="1.0" encoding="iso-8859-1"?>
<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="792px" height="792px" viewBox="0 0 792 792" style="enable-background:new 0 0 792 792;" xml:space="preserve">
<g>
	<g id="_x31_0_19_">
		<g>
			<path d="M643.5,742.5H594V569.25C594,473.566,516.434,396,420.75,396C516.434,396,594,318.434,594,222.75V49.5h49.5
				c13.662,0,24.75-11.088,24.75-24.75S657.162,0,643.5,0h-495c-13.662,0-24.75,11.088-24.75,24.75S134.838,49.5,148.5,49.5H198
				v173.25C198,318.434,275.566,396,371.25,396C275.566,396,198,473.566,198,569.25V742.5h-49.5c-13.662,0-24.75,11.088-24.75,24.75
				S134.838,792,148.5,792h495c13.662,0,24.75-11.088,24.75-24.75S657.162,742.5,643.5,742.5z M247.5,222.75
				c0-43.387,0-173.25,0-173.25h297c0,0,0,133.427,0,173.25c0,68.335-58.188,123.75-129.938,123.75h-37.125
				C305.687,346.5,247.5,291.085,247.5,222.75z M544.5,742.5h-297c0,0,0-129.888,0-173.25c0-68.335,58.187-123.75,129.938-123.75
				h37.125c71.75,0,129.938,55.415,129.938,123.75C544.5,609.072,544.5,742.5,544.5,742.5z"/>
		</g>
	</g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
</svg>

                <time class="article-time--reading">
                    阅读时长: 122 分钟
                </time>
            </div>
        

         
        <div>
            <?xml version="1.0" encoding="iso-8859-1"?>
<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="79.536px" height="79.536px" viewBox="0 0 79.536 79.536" style="enable-background:new 0 0 79.536 79.536;"
	 xml:space="preserve">
<g>
	<path style="fill:#010002;" d="M40.162,17.906C37.415,15.275,21.614,6.141,0,15.451c0,0.138,0,2.722,0,6.654v44.418h32.747
		c1.126,0.968,3.798,1.651,6.926,1.651c3.119,0,5.802-0.684,6.931-1.651h32.933V22.105c0-3.933,0-6.517,0-6.654
		C58.813,6.314,42.257,15.982,40.162,17.906z M37.229,63.349c0-1.75-15.372-11.981-33.125-0.818V19.216
		c3.516-2.014,8.246-3.249,13.463-3.249c10.864,0,19.662,3.562,19.662,10.175V63.349z M75.684,62.53
		c-17.751-11.163-33.108-0.932-33.108,0.818V26.146c0-6.612,8.792-10.175,19.646-10.175c5.22,0,9.952,1.235,13.463,3.249V62.53z"/>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
</svg>

            <time class="article-words">
                文章字数：60981字
            </time>
        </div>
        <div class="article-lastmod">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time>
                    Nov 12, 2024 23:05 &#43;0800
                </time>
            </div></footer>
    

    




    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="lecture-19-virtual-machines">Lecture 19 Virtual Machines
</h1><h2 id="课前预习">课前预习
</h2><h2 id="论文速览">论文速览
</h2><p>这篇论文《Dune: Safe User-level Access to Privileged CPU Features》通过以下几个部分展开。</p>
<p>在摘要 (Abstract)部分，提到Dune系统为应用程序提供安全、直接的硬件特权访问（如页表、特权模式等），并展示了其在64位x86 Linux系统上的实现。文中介绍了Dune在沙盒、权限分离以及垃圾回收器中的应用，展示了其性能优势。</p>
<p>在引言 (Introduction)部分，介绍了许多应用程序需要访问“内核级”硬件功能的原因，但这些功能通常限制在内核空间。传统的解决方法（如修改内核或使用虚拟机）存在种种弊端，而Dune通过虚拟化硬件为用户程序提供了安全访问硬件功能的新方式。</p>
<p>在虚拟化和硬件支持 (Virtualization and Hardware)部分，详细描述了Intel的VT-x扩展如何支持虚拟化，包括VMX root和VMX non-root模式。Dune利用这些硬件特性为用户程序提供对特权硬件（如异常处理、虚拟内存、特权模式等）的访问。</p>
<p>在Dune的内核支持 (Kernel Support for Dune)部分，讨论了Dune核心模块的架构、威胁模型及其与传统虚拟机管理程序（VMM）的区别。Dune通过一个轻量级内核模块来管理虚拟化硬件，并使用EPT（扩展页表）来确保内存隔离，同时提供对内存管理、硬件访问及系统调用的支持。</p>
<p>在用户模式环境 (User-mode Environment)部分，介绍了Dune提供的用户模式库libDune，帮助用户程序管理特权硬件功能，包括页表管理、异常处理等。讨论了如何从普通进程过渡到Dune模式，及其对现有Linux程序的影响。</p>
<p>在应用 (Applications)部分，提到Dune的三个应用场景：沙盒、权限分离、垃圾回收器。在每个场景下，Dune简化了实现并提供了显著的性能提升。例如，在沙盒应用中，Dune能够有效隔离不可信代码，同时保证较低的性能开销。</p>
<p>在 评估 (Evaluation)部分，通过对系统调用、页错误处理、页表访问等操作的基准测试，量化了Dune的性能开销。并对其在不同应用场景中的加速效果进行了分析，显示了Dune在内存密集型应用中的优势。</p>
<p>在对硬件的反思 (Reflections on Hardware)部分，讨论了在开发Dune过程中遇到的硬件限制，提出了一些硬件改进建议，尤其是在EPT和VMX过渡开销方面。这部分对硬件开发者更有意义。</p>
<p>在 相关工作 (Related Work)部分，介绍了Dune与其它操作系统设计（如Exokernel、SPIN、Wedge等）的关系，并探讨了Dune相较于其他虚拟化和安全系统的独特优势。</p>
<p>在结论 (Conclusion)部分，总结了Dune为用户程序提供访问特权硬件的新方法，提升了性能并简化了实现。作者还提出Dune的潜在扩展方向，如在不同硬件架构上的应用。</p>
<p><strong>阅读重点</strong>：</p>
<ul>
<li><strong>摘要</strong>部分可以快速了解论文的整体内容。</li>
<li><strong>引言</strong>和<strong>虚拟化和硬件支持</strong>部分能够帮助理解Dune的核心设计动机和硬件背景，适合第一次接触Dune的读者。</li>
<li>对于实际应用和性能评估，<strong>应用</strong>和<strong>评估</strong>部分是阅读的重点，尤其是对系统性能和应用场景感兴趣的读者。</li>
</ul>
<hr>
<h2 id="虚拟化硬件">虚拟化硬件
</h2><p>虚拟化硬件是一种通过硬件支持实现系统虚拟化的技术，它允许多个操作系统或用户进程共享同一台物理机器的硬件资源，同时确保每个操作系统或进程的独立性和安全性。这种技术通常通过 CPU 和内存的扩展来支持虚拟化操作，从而使虚拟机（Virtual Machine, VM）可以像独立物理机器一样运行。英特尔的 VT-x 和 AMD 的 SVM（Secure Virtual Machine）是两种主流的虚拟化硬件技术。</p>
<p>虚拟化的早期实现主要通过软件来模拟硬件（如仿真 CPU 指令和内存访问），这种方式的性能开销较大。现代 CPU 引入了硬件虚拟化支持，例如 Intel 的 VT-x 和 AMD 的 SVM，使虚拟化操作更加高效。虚拟化硬件使得大部分虚拟机的操作能够直接在硬件上执行，从而减少了虚拟机管理程序（VMM）或操作系统内核的干预，这提高了虚拟化的性能并降低了开销。</p>
<p>虚拟化硬件（如 Intel VT-x）通过将 CPU 划分为两种模式：</p>
<ol>
<li><strong>VMX Root 模式</strong>：通常用于运行虚拟机管理程序（VMM），类似于操作系统内核的特权模式。</li>
<li><strong>VMX Non-root 模式</strong>：限制了 CPU 的操作权限，主要用于运行虚拟机中的客体操作系统（Guest OS）。</li>
</ol>
<p>硬件通过 VM entry 和 VM exit 来管理不同模式的切换。例如，当 VMM 发出 <code>VMLAUNCH</code> 指令时，CPU 进入 VMX Non-root 模式，运行虚拟机。当虚拟机需要 VMM 处理一些操作（如系统调用或页表管理），硬件会触发 VM exit，将控制权返回给 VMM。这种机制使得虚拟机可以高效地执行大部分指令，而无需 VMM 的干预。</p>
<p>在论文《Dune: Safe User-level Access to Privileged CPU Features》中，Dune 系统利用虚拟化硬件（Intel VT-x）为用户进程提供对特权硬件功能（如页表、异常处理、特权模式等）的访问。Dune 中的用户进程运行在 VMX Non-root 模式下，这使得它们可以直接访问 CPU 的特权级操作，而不需要内核直接参与。这种机制不仅提高了系统性能，还保持了安全隔离。</p>
<p>基于 xv6 和 Linux 的示例：</p>
<ol>
<li><strong>在 xv6 中</strong>：xv6 是一个简单的教学操作系统，所有用户进程运行在用户模式下，只有内核才能运行在特权模式（ring 0）下。如果要通过虚拟化硬件将特权模式的一些功能暴露给用户程序，xv6 将需要借助类似 VT-x 这样的虚拟化技术。通过将用户进程放入 VMX Non-root 模式，xv6 可以在不破坏其进程隔离模型的前提下，让用户进程访问页表或执行硬件异常处理。</li>
<li><strong>在 Linux 中</strong>：Linux 的设计更加复杂，虚拟化硬件可以通过虚拟机（如 KVM）让多个 Linux 内核在同一台物理机上运行。虚拟机使用硬件虚拟化技术，通过 VMM 来管理内存和 CPU 资源。在 Dune 的设计中，它直接通过虚拟化硬件将某些内核特权功能（如页表管理、系统调用拦截）暴露给用户进程，从而避免了复杂的内核修改。这对于高性能应用（如垃圾回收、权限隔离等）具有极大的好处。</li>
</ol>
<p>虚拟化本身并不是新技术，最早可追溯到 1960 年代的 IBM 大型机。然而，现代硬件虚拟化（如 Intel VT-x 和 AMD SVM）是 2000 年代后期发展起来的技术，专为提高虚拟机性能而设计。</p>
<p><strong>虚拟化硬件技术</strong>是指虚拟机的指令大部分直接在真实硬件上执行，但在受控的环境中，不能直接影响到主机系统的资源和数据。这种技术通过使用<strong>虚拟化硬件（如 Intel VT-x）</strong>，将虚拟机的执行限制在隔离的虚拟机监控程序（VMM）内，保证虚拟机对主机系统的干扰最小化。</p>
<p>虚拟化硬件通过多种机制保证安全性，防止虚拟机中的恶意代码（如病毒）攻击主机系统的真实数据：</p>
<ol>
<li><strong>隔离机制</strong>：虚拟化硬件通过扩展页表（Extended Page Table, EPT）等技术，确保虚拟机只能访问被分配给它的内存区域，而不能直接访问主机系统的物理内存。即使在虚拟机中执行恶意指令，硬件会通过 EPT 确保这些指令不能访问到不属于虚拟机的地址空间。</li>
<li><strong>VM Exit</strong>：虚拟机运行时，如果尝试执行某些特权操作（如系统调用），CPU 会触发 <strong>VM Exit</strong>，将控制权转交给虚拟机监控程序（VMM）。这样，VMM 可以拦截并检查这些特权操作，确保安全性。</li>
<li><strong>硬件虚拟化的防护</strong>：Intel 的 VT-x 和 AMD 的 SVM（Secure Virtual Machine）都提供了特定的硬件支持，确保虚拟机与物理机之间的安全隔离。任何尝试逃逸虚拟机环境的操作都会被硬件机制检测并阻止。</li>
<li><strong>扩展页表（EPT）和地址空间隔离</strong>：虚拟化硬件通过 EPT 使虚拟机的物理地址与真实物理地址隔离。即便是恶意软件试图操作内存，也只能操作虚拟机自己的地址空间，而不能访问主机系统的数据。</li>
</ol>
<p>因此，主机系统的内存数据是“锁定”的，虚拟机无法直接接触到。如果有恶意代码试图窃取数据或发起攻击，硬件将中止操作并返回给 VMM。</p>
<p>QEMU 是一种广泛使用的开源虚拟机仿真器和虚拟化工具，它支持多种虚拟化方式，包括<strong>全系统仿真（full system emulation）**和**硬件辅助虚拟化（hardware-assisted virtualization）</strong>。当 QEMU 与 KVM（Kernel-based Virtual Machine）结合使用时，虚拟机的执行速度大幅提升，因为 KVM 可以利用硬件虚拟化特性（如 Intel VT-x 或 AMD SVM）将虚拟机的指令直接运行在物理 CPU 上。</p>
<p>在 MIT 6.828 课程中使用的 <code>xv6</code> 操作系统是在 QEMU 中运行的。QEMU 在这个环境中既可以作为一个<strong>纯仿真器</strong>（即不依赖硬件虚拟化），也可以在支持的主机上与 KVM 一起工作，利用硬件虚拟化功能。这取决于你如何配置 QEMU。通常在课程中的 <code>xv6</code> 是在纯软件仿真环境中运行的，但如果启用了 KVM，则 QEMU 会利用硬件虚拟化功能加速虚拟机的运行。</p>
<p>的确，安全攻击一直是虚拟化技术的一个潜在问题，特别是通过虚拟机逃逸（VM Escape）攻击主机系统的风险。虚拟化硬件通过严格的权限管理和隔离机制防止这种攻击。尽管硬件虚拟化技术在设计上已经考虑了安全问题，但历史上也出现过一些硬件漏洞（如 Intel 的 Meltdown 和 Spectre），这使得虚拟化系统需要通过额外的软件补丁和配置来增强安全性。</p>
<p>总结：</p>
<ul>
<li>虚拟化硬件通过页表隔离和硬件中断等机制确保虚拟机不能干涉主机系统的真实数据。</li>
<li>QEMU 支持硬件虚拟化，可以利用 KVM 加速虚拟机的执行。</li>
<li>虽然硬件虚拟化设计上保证了安全性，但历史上也出现过一些需要防范的硬件漏洞。</li>
</ul>
<hr>
<h2 id="特权硬件">特权硬件
</h2><p>在 Dune 系统中，特权硬件功能是指那些通常只有操作系统内核才有权限访问和控制的 CPU 功能。这些功能包括：</p>
<ol>
<li><strong>异常处理（Exceptions）</strong>：处理 CPU 中断和异常（如页面错误、除零等）。</li>
<li><strong>虚拟内存（Virtual Memory）</strong>：直接访问和管理页表，控制虚拟地址到物理地址的映射。</li>
<li><strong>权限模式（Privilege Modes）</strong>：包括 CPU 中的权限环（如 ring 0 和 ring 3），用于区分内核态和用户态的操作权限。</li>
<li><strong>其他硬件功能</strong>：如控制寄存器、TLB（转换后备缓冲区）等，用于内存管理和性能优化。</li>
</ol>
<p>与特权硬件功能不同，不特权的硬件功能是用户程序可以直接访问的 CPU 功能。这些功能通常限于普通计算操作和基本的内存访问，例如：</p>
<ul>
<li><strong>算术运算</strong>：加减乘除等 CPU 指令。</li>
<li><strong>基本内存访问</strong>：访问分配给该进程的用户空间内存。</li>
<li><strong>I/O 操作</strong>：通过操作系统的系统调用接口进行文件读写和网络操作等。</li>
</ul>
<p>这些功能是受限的，用户态程序无法直接访问内核态所需的特权硬件资源，如页表管理和系统调用向量。</p>
<p>Dune 系统的设计初衷是通过虚拟化硬件技术（Intel VT-x）为用户进程提供对特权硬件功能的直接访问，目的是让用户程序能够更高效地进行某些操作，而不需要频繁地切换到内核态。这带来了几个显著的好处：</p>
<ol>
<li><strong>提高性能</strong>：用户程序可以直接处理诸如页面错误等异常，减少了传统的系统调用和上下文切换的开销。例如，Dune 能够将页面错误的处理速度提升四倍以上。</li>
<li><strong>灵活的内存管理</strong>：Dune 允许用户程序直接操作页表，控制地址翻译和访问权限。这对于实现自定义的垃圾回收、数据压缩等内存密集型操作非常有用。</li>
<li><strong>权限分离和沙盒</strong>：通过暴露权限模式（如 ring 0 和 ring 3），Dune 可以有效地隔离不可信代码，提供类似操作系统内核的安全防护机制，但不需要进行复杂的内核修改【5†source】。</li>
</ol>
<p>直接将特权交给用户进程会带来巨大的安全风险，比如：</p>
<ul>
<li><strong>攻击面扩大</strong>：恶意程序可能会利用这些特权功能执行恶意操作，例如篡改内核数据或干扰其他进程。</li>
<li><strong>系统不稳定</strong>：一旦用户进程获得了特权功能，可能会误用，导致系统崩溃或不稳定。</li>
</ul>
<p>Dune 的设计是通过<strong>虚拟化硬件</strong>（Intel VT-x）提供了一种受控的方式，让用户进程能够<strong>安全访问特权硬件</strong>，同时避免直接干预到主机系统。这种机制主要通过以下几个方面确保安全：</p>
<ol>
<li><strong>隔离机制</strong>：通过虚拟化模式，用户进程运行在 VMX non-root 模式下，主机操作系统运行在 VMX root 模式。即使用户进程具有特权硬件访问权，它们依旧在一个受限制的虚拟化环境中，无法直接访问主机系统的资源。</li>
<li><strong>VM Exit 机制</strong>：每当用户进程尝试进行高风险的操作（如访问特定的硬件资源），硬件会触发 VM Exit，返回控制权给虚拟机管理程序（VMM），确保操作的合法性。</li>
</ol>
<hr>
<h2 id="dune和传统虚拟机管理程序vmm的差异">Dune和传统虚拟机管理程序（VMM）的差异
</h2><p>VMM和Dune的主要不同点：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th></th>
          <th>VMM</th>
          <th>Dune</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>环境模拟</td>
          <td>传统的虚拟机管理程序模拟一个完整的机器环境，支持运行一个完整的客操作系统。这种模拟需要支持各种物理硬件接口，并且通常通过复杂的方法来提供虚拟硬件，通过这种方式，可以运行未修改过的操作系统。</td>
          <td>Dune暴露的是进程环境，而非机器环境。因此，Dune不能支持一个完整的客操作系统，但由于只需处理进程环境，Dune更加轻量和灵活。</td>
      </tr>
      <tr>
          <td>Hypercalls</td>
          <td>Hypercalls用于支持半虚拟化技术，这种技术要求对客操作系统进行修改，以便使用一些更有效率且更容易虚拟化的接口。例如，VMM可能提供一个hypercall来注册虚拟网络设备的中断处理程序。</td>
          <td>Hypercalls机制调用的是正常的Linux系统调用。例如，Dune中的hypercall允许通过调用标准的操作系统服务，例如在TCP socket上进行读取操作。</td>
      </tr>
      <tr>
          <td>硬件接口的模拟</td>
          <td>为了支持未修改的客操作系统，VMM需要模拟各种物理硬件接口（例如虚拟显卡）。</td>
          <td>只提供可以直接访问的硬件功能，不能直接访问的情况下，会退回到操作系统上。例如，对于显卡接口，Dune直接使用正常的操作系统显示服务。</td>
      </tr>
      <tr>
          <td>状态保存与恢复</td>
          <td>必须保存和恢复所有必要的状态以支持一个完整的客操作系统。</td>
          <td>由于暴露的只是进程级别的硬件接口，Dune限制了客体与主机状态之间的差异，从而减少了执行VM entries和VM exits的开销。</td>
      </tr>
      <tr>
          <td>地址空间</td>
          <td>为每个虚拟机提供一个独立的地址空间，模拟平面的物理内存。</td>
          <td>EPT（扩展页表）反映的是进程地址空间，这样内存布局可以是稀疏的，而且当两个进程映射同一个内存段时，内存可以一致地共享。</td>
      </tr>
      <tr>
          <td>Hypercalls</td>
          <td>hypercalls的目的是让客操作系统调用虚拟机管理程序，以获取某些特定的虚拟化服务</td>
          <td>hypercalls直接调用Linux系统调用，这大大简化了虚拟化层的设计，因为它不需要提供专门的虚拟化服务接口，直接利用操作系统已有的服务即可</td>
      </tr>
      <tr>
          <td>状态保存</td>
          <td>VMM需要保存和恢复完整的机器状态，以便可以中断和重新启动操作系统及其运行的应用程序。</td>
          <td>Dune不需要保存大量的状态，是因为它只是提供一个进程环境，而该进程环境和主机操作系统的环境非常接近。Dune进程始终在主机操作系统中运行，其状态保存和恢复主要由操作系统本身管理，而不是由虚拟化层管理。</td>
      </tr>
      <tr>
          <td>硬件模拟</td>
          <td>VMM必须模拟完整的硬件层，以支持未修改的客操作系统，这包括CPU、内存、设备等。</td>
          <td>Dune只模拟了硬件和操作系统之间的那一层，对于那些无法直接访问的硬件功能，直接调用主机操作系统的服务即可。</td>
      </tr>
  </tbody>
</table></div>
<p>关于Hypercalls：</p>
<blockquote>
<p>大多数VMM采用Hypercall来支持半虚拟化。在这种情况下，客操作系统被修改以通过Hypercall与VMM通信。这些Hypercall是专门的虚拟化接口，通常由VMM来处理，处理时往往涉及复杂的步骤，因为VMM需要模拟硬件。
假设我们有一个虚拟网络设备。客操作系统需要注册一个中断处理程序来处理虚拟设备的中断。在传统VMM中，客操作系统通过Hypercall告诉VMM：“我需要注册一个中断处理程序。” VMM接收到这个Hypercall后，会更新其内部的数据结构，并确保当虚拟设备产生中断时，中断处理程序将由客操作系统正确处理。</p>
<p>在Dune中，Hypercall直接调用主机操作系统（比如Linux）的系统调用。这意味着Dune不需要维护复杂的虚拟化接口，借助操作系统已有的机制即可实现功能。
同样是虚拟网络设备，在Dune中，进程不直接与Dune层通信以注册中断处理程序，而是通过标准的Linux系统调用来完成该操作。例如，进程可能使用<code>read</code>系统调用从一个TCP socket读取数据。实际上，这种调用通过Hypercall直接由Linux内核来处理，而不需要Dune进行复杂的虚拟化处理。</p>
</blockquote>
<p>关于状态保存：</p>
<blockquote>
<p>在传统的VMM中，每个虚拟机（包括其运行的客操作系统和应用程序）都有独立的计算状态，这包括CPU寄存器、内存状态、I/O设备状态等。当发生VM entry（进入虚拟机）或VM exit（退出虚拟机）时，VMM必须保存和恢复所有这些状态，以确保虚拟机的运行不受干扰。这是一项复杂且耗时的任务，因为状态信息非常多。
假设虚拟机正在执行某个操作，中途发生了VM exit（可能是由于某个中断）。在这种情况下，VMM必须保存一些寄存器、内存和I/O设备的状态，以便下一次虚拟机恢复运行时，能够无缝地继续之前的操作。</p>
<p>Dune不需要保存和恢复大量状态，部分原因是它处理的是进程层面而非机器层面的状态。进程的状态由操作系统（比如Linux）管理，包括上下文切换等操作。因为：</p>
<ul>
<li>Dune进程是主机操作系统的一部分，从操作系统的角度来看，它是一个普通进程。</li>
<li>当发生切换时，Linux已经处理了大部分的状态保存和恢复工作，Dune只需极少的额外处理。</li>
</ul>
<p>假设一个Dune进程需要执行IO操作。当进程被调度时，Linux内核会自动保存当前进程的状态（如寄存器、内存页表等），并恢复下一个进程的状态。这与标准的进程上下文切换相同，不需要Dune进行额外的状态管理。</p>
</blockquote>
<p>关于硬件模拟：</p>
<blockquote>
<p>传统的VMM需要完整地模拟物理硬件层，以支持未修改的客操作系统。这意味着VMM必须提供虚拟CPU、虚拟内存管理单元、虚拟设备（如网络、显卡等）等。</p>
<p>对于虚拟显卡，VMM需要模拟显卡的各种寄存器和状态，让客操作系统认为它在与一个真实的显卡打交道。这涉及到高复杂性的模拟和处理。</p>
<p>Dune暴露的是硬件和操作系统之间的一层接口。它不完全模拟硬件，只是提供直接访问一些硬件功能的接口，而对于无法直接访问的功能，依赖于主机操作系统。</p>
<p>在图形显示方面，Dune不会提供虚拟显卡，而是让进程使用操作系统的显示服务（例如通过Unix域套接字和共享内存访问X服务器）。这样，图形显示的复杂性被主机操作系统处理，Dune不需要额外的处理。</p>
</blockquote>
<p>总结来说，Dune尝试通过暴露进程级的虚拟环境来简化虚拟化的复杂性，这样做不仅使其更加轻量和灵活，而且能够充分利用主机操作系统已提供的服务来实现功能。</p>
<hr>
<h2 id="dune-技术"><strong>Dune 技术</strong>
</h2><p><strong>Dune</strong>技术确实不同于传统虚拟机的虚拟化，它提供的不是完整的虚拟机，而是一种更轻量级的、针对<strong>线程级别的虚拟化</strong>，但是它仍然利用了<strong>虚拟化硬件的能力</strong>，这就是为什么你在论文中看到虚拟机相关的术语，如“VM entry”和“VM exit”。</p>
<p>Dune的核心思想是利用硬件虚拟化技术（如Intel VT-x）为<strong>用户态的进程或线程</strong>提供对底层硬件资源（如内存、CPU寄存器等）的更直接访问，而无需引入完整的虚拟机（即没有必要模拟整个操作系统）。它让用户态的程序在某种程度上获得与内核态程序类似的硬件访问权限，同时通过虚拟化技术保持对系统安全的控制。</p>
<p>简单来说，Dune并没有像传统的虚拟机那样完全模拟一台机器，而是借助硬件虚拟化特性，让用户进程可以更高效地访问一些低级的硬件功能，通常只需一部分特权。<strong>因此，Dune更像是线程级别的虚拟化，但使用了虚拟机技术来实现这些特权访问。虚拟机与线程的区别</strong>:</p>
<ul>
<li><strong>虚拟机（VM）</strong>：通常模拟的是整个物理机器，包括CPU、内存、存储、网络接口等完整的硬件设备。虚拟机运行的是一个完整的操作系统，并且这个操作系统可以管理多个线程或进程。因此，虚拟机不仅仅是一个线程，它包含了一个完整的执行环境。</li>
<li><strong>线程</strong>：线程是操作系统中更轻量级的执行单位，它是进程的一部分，多个线程共享同一个进程的内存空间。每个线程只表示一个执行路径，而没有独立的硬件环境。Dune技术关注的是如何给线程提供某些底层硬件的直接访问权限。</li>
</ul>
<p>Dune并不创建完整的虚拟机，但它使用了虚拟化硬件中的一些概念，比如：</p>
<ul>
<li><strong>VMX Root 和 Non-Root模式</strong>：这些概念本质上属于硬件虚拟化管理，用来控制哪些操作系统级别的操作可以被虚拟化进程访问。Dune利用这套机制，让用户态进程进入一种“受控”的环境，能够直接访问某些硬件资源（比如页表操作），但同时保持一定的隔离。</li>
<li><strong>VM entry/exit</strong>：尽管Dune不是传统虚拟机，但它通过类似虚拟机的方式进行状态切换。当用户态线程需要使用特权操作时，可能会触发类似“VM exit”的动作，切换到内核态或者让VMM（虚拟机监控器）进行处理。</li>
</ul>
<p><strong>在Dune的上下文中，虚拟机不是指一个完整的虚拟操作系统环境</strong>，而是指Dune利用虚拟化硬件为线程创建的一种“受控环境”，让用户态进程可以安全地使用某些特权指令。</p>
<p>在传统的虚拟机系统中，**虚拟机（VM）**不是单一的线程，而是一个独立的计算环境，通常运行在虚拟机监控器（VMM）之上，它可以包含多个线程和进程。但是在Dune这样的技术中，虚拟机的概念被简化了，它更像是给某个用户线程提供了一种增强的硬件访问权限。<strong>从这个角度看，虚拟机可以被视为一个特权线程的运行环境</strong>，但它仍然与完整的虚拟机概念不同。</p>
<p>总而言之</p>
<ul>
<li>Dune提供的虚拟化是<strong>线程级别的</strong>，让用户态线程能够利用硬件虚拟化访问底层资源。</li>
<li>虽然Dune使用了虚拟化硬件的概念（如VMX模式和VM exit等），但<strong>它并不创建完整的虚拟机</strong>，而是通过类似虚拟机的机制来管理线程对硬件的访问。</li>
<li><strong>虚拟机和线程的区别</strong>在于虚拟机模拟的是完整的操作系统环境，而线程只是单一的执行路径。在Dune中，虚拟机的作用类似于为用户态线程提供特权硬件访问的受控环境。</li>
</ul>
<hr>
<h2 id="dune的系统调用拦截"><strong>Dune的系统调用拦截</strong>
</h2><p>在Dune系统中，用户进程执行系统调用的方式确实与传统操作系统有所不同。这种设计主要是为了提供灵活性和安全性，特别是为了实现系统调用插装（interposition）和防止不可信代码直接访问内核。对于这一点，Dune系统采取了一些特殊的机制来处理系统调用。</p>
<p>在传统的操作系统中，系统调用是通过陷入内核（trap to the kernel）来执行的。也就是说，当用户进程执行系统调用时，它会从用户态切换到内核态，并由内核处理这个系统调用。然而，在Dune系统中，系统调用会通过一个特殊的机制——<strong>系统调用插装（interposition）</strong>——来处理，这使得系统调用可以在用户空间被拦截和处理。</p>
<p>Dune系统利用了虚拟化技术，使用户态代码能够有更多的控制权，但同时确保系统安全性。具体来说，当用户进程执行系统调用时，可以采取以下几个步骤：</p>
<ol>
<li><strong>系统调用捕获</strong>：
当一个Dune用户进程执行系统调用时，这个调用会被虚拟化系统（如虚拟机监控器或Dune层）捕获。这并不是直接陷入内核，而是通过Dune层进行拦截。</li>
<li><strong>自定义处理</strong>：
Dune层会检查该系统调用，并执行自定义处理逻辑。这个处理逻辑是用户定义的，可以用来：
<ul>
<li><strong>审计和记录</strong>系统调用行为。</li>
<li><strong>替换或修改</strong>系统调用的功能。</li>
<li><strong>防止不可信代码</strong>执行某些潜在危险的系统调用。</li>
</ul>
</li>
<li><strong>条件性传递到内核</strong>：
根据自定义处理的结果，Dune层可以决定是否将系统调用传递给内核。如果需要，系统调用会以传统方式传给内核处理。如果不需要，Dune层可以直接返回结果，阻止系统调用到达内核。</li>
</ol>
<p>用户进程在Dune系统中并不会直接包括内核的系统调用代码，但是它会通过Dune层的拦截机制进行处理。以下是其中几个可能的机制：</p>
<ul>
<li><strong>基于虚拟化的拦截</strong>：
Dune利用虚拟化硬件（如Intel VT-x）实现系统调用的拦截和处理。这样即使在用户态，进程也能执行一些类似于内核态的操作，但这些操作是在受控的环境下完成的。</li>
<li><strong>共享地址空间</strong>：
为了实现更好的性能和灵活性，Dune可能会在用户态与内核态之间共享某些数据结构（例如页表）。这样，Dune可以避免频繁的上下文切换。</li>
<li><strong>中间层代码</strong>：
Dune可能包括一些用户态的库或运行时（runtime），这些库或运行时会拦截系统调用并将其传递给Dune层进行处理。Dune层为这些库提供了一套API，用户态进程通过这些API与Dune进行交互。</li>
</ul>
<p>总而言之</p>
<ul>
<li><strong>Dune系统中的用户进程并不会直接包含内核的系统调用代码</strong>。相反，当用户进程执行系统调用时，系统调用会被Dune层捕获和处理。</li>
<li><strong>系统调用捕获</strong>机制允许Dune进行系统调用插装、修改或阻止，从而增加系统的安全性和灵活性。</li>
<li><strong>系统调用最终的处理</strong>可以通过自定义逻辑决定是否传递给内核，提供了对系统调用行为的细粒度控制。</li>
</ul>
<p>总的来说，Dune系统通过虚拟化技术提供了一种新颖的、灵活的系统调用捕获和处理机制，使得用户进程可以在不陷入内核的情况下高效且安全地执行系统调用。这大大扩展了用户进程在用户态下的能力，同时通过严格的控制防止了安全问题。</p>
<hr>
<h2 id="dune用户态执行指令"><strong>Dune用户态执行指令</strong>
</h2><p>Dune确实可以被视为一种增强的缓存和拦截机制，它允许某些特定类型的指令或系统调用在用户态下直接执行，而无需陷入内核。这种机制通过虚拟化技术赋予用户态进程额外的权限，从而实现更高效的操作。</p>
<ol>
<li>
<p><strong>Dune如何在用户态执行指令</strong>。Dune系统依赖于硬件虚拟化技术（如Intel VT-x）以及一层特殊的中间层，这层中间层给予用户态一些改进后能够安全执行的权限。以下是Dune系统如何在用户态执行指令的几个核心机制：</p>
<ol>
<li>
<p><strong>虚拟化技术的使用</strong>。Dune利用虚拟化技术，在用户态程序和底层硬件之间插入一层，用来管理和控制特权指令的执行。在Intel VT-x的支持下，Dune可以使用户态程序进入一种称为**VMX非根模式（VMX Non-Root Mode）**的状态，这种状态下可以执行原本需要内核态权限的特权操作。</p>
</li>
<li>
<p><strong>特权指令的捕获和处理</strong>。当用户态进程执行特权指令时，例如修改页表或执行特权系统调用，Dune层会通过虚拟机控制结构（VMCS）进行捕获。具体步骤如下：</p>
<ul>
<li>
<p><strong>指令捕获</strong>：Dune会预先配置哪些指令或事件需要捕获（如页表访问、某些特殊的CPU指令等）。</p>
</li>
<li>
<p><strong>检查与执行</strong>：捕获后，Dune会检查这些指令，如果可以在用户态执行就直接执行，否则会传递给内核进行处理。</p>
</li>
<li>
<p><strong>回传结果</strong>：执行结果或状态更新会通过Dune层传回给用户进程。</p>
</li>
</ul>
</li>
<li>
<p><strong>安全性和隔离措施</strong>。尽管Dune赋予了用户态进程更多的权限，但它也采取了一些安全措施来确保系统的整体安全性：</p>
</li>
</ol>
<ul>
<li>
<p><strong>内存隔离</strong>：通过虚拟化技术，如扩展页表（EPT），Dune确保进程只能访问它被授权的内存区域。</p>
</li>
<li>
<p><strong>特权管理</strong>：利用硬件虚拟化特性，Dune限制了用户态程序对内核态资源的直接访问，防止其对系统造成不安全影响。</p>
</li>
</ul>
</li>
<li>
<p><strong>Dune赋予的权限</strong></p>
<ol>
<li>
<p><strong>增强的用户态权限</strong>。通常情况下，用户态的权限是非常有限的，但通过Dune，用户态进程能够访问和管理一些本来只有内核态才能使用的资源和指令。这是通过虚拟化技术，使得用户态进程可以在安全的前提下执行部分特权操作。</p>
</li>
<li>
<p><strong>特权模式运行</strong>。在Dune环境下，用户态进程运行在一种特定模式下，这种模式被称作<strong>VMX非根模式</strong>，它允许：</p>
<ul>
<li>
<p><strong>页面表管理</strong>：用户态进程可以直接修改页表，管理自己的虚拟地址空间，而无需每次都陷入内核。</p>
</li>
<li>
<p><strong>特权指令执行</strong>：某些以前需要切换到内核才能执行的指令可以直接在用户态执行，例如某种寄存器操作。</p>
</li>
<li>
<p><strong>执行优化</strong>：通过减少内核和用户态之间的上下文切换，Dune能够显著提高系统调用的性能。</p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p><strong>总结</strong></p>
<ul>
<li>
<p><strong>Dune的设计</strong>目的是增强用户态程序的执行权限，但同时保持系统的安全性和隔离性。</p>
</li>
<li>
<p><strong>通过虚拟化技术（如Intel VT-x）</strong>，Dune让用户态进程在一种受控的环境下运行，有些特权指令可以直接在用户态执行，而不用陷入内核。</p>
</li>
<li>
<p><strong>特权管理和隔离</strong>确保即使赋予用户态更多权限，系统仍然是安全的，不会因为用户进程的错误或恶意操作而受到破坏。</p>
</li>
</ul>
</li>
</ol>
<p>总的来说，Dune的关键在于利用虚拟化硬件提供的一种隔离机制，使用户态进程能够安全、高效地执行一些原本需要内核态处理的操作，从而提高系统的整体性能。</p>
<hr>
<h2 id="dune模式和页表">Dune模式和页表
</h2><p>当用户进程进入Dune模式时，它确实会涉及到某些与页表相关的操作，但这些操作与传统的用户态到内核态的切换有所不同。以下是详细的解释：</p>
<ol>
<li>
<p>用户进程进入Dune模式和页表相关的操作</p>
<ol>
<li>
<p>进入Dune模式。当用户进程进入Dune模式，它并不会像传统的系统调用那样完全切换到内核态，而是进入一种特定的虚拟化模式（VMX Non-Root Mode）。在这种模式下，用户进程仍然运行在用户态，但它有更多的权限可以直接访问某些硬件资源和执行特权操作。</p>
</li>
<li>
<p>页表管理</p>
<ul>
<li>
<p><strong>EPT（扩展页表）</strong>：Dune模式下的存储管理通常依赖于扩展页表（Extended Page Table，EPT）。EPT是硬件虚拟化的一部分，它允许虚拟机监控器（VMM）管理内存映射，而不需要操作系统频繁切换页表。通过EPT，Dune可以为用户进程提供一种“伪内核态”的权限，让其直接管理和访问自己的内存空间，而不必每次都陷入内核。</p>
</li>
<li>
<p><strong>直接页表修改</strong>：Dune模式下，用户进程可以直接修改自己的页表，这是通过虚拟化硬件的支持实现的。在这种模式下，用户进程可以安全地进行页表操作，而不需要每次都进行上下文切换。</p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>用户进程进入内核态的页表切换</p>
<ol>
<li>
<p>用户态到内核态的切换。在传统的操作系统架构中，当用户进程需要进入内核态（例如执行系统调用），通常会涉及到一些上下文切换，这包括页表的切换。</p>
<ul>
<li>
<p><strong>页表切换</strong>：当用户进程进入内核态时，操作系统可能会切换到一个不同的页表。这是因为内核态和用户态可能有不同的地址空间，需要通过不同的页表来管理。</p>
</li>
<li>
<p><strong>上下文切换</strong>：这包括保存当前用户态的CPU寄存器状态、切换到内核态的寄存器状态、更新栈指针等。然后内核会根据系统调用的参数和当前状态执行相应的内核逻辑。</p>
</li>
</ul>
</li>
<li>
<p>为什么需要页表切换</p>
<ul>
<li>
<p><strong>地址空间隔离</strong>：用户态进程和内核态拥有不同的地址空间，使用不同的页表会提供更好的隔离和安全性，防止用户进程直接访问内核内存区域。</p>
</li>
<li>
<p><strong>权限管理</strong>：内核态需要访问所有系统资源，而用户态的访问权限较为有限。通过页表切换，内核可以获得全面的内存访问权限。</p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>Dune与传统内核态的区别</p>
<ol>
<li>
<p>权限管理</p>
<ul>
<li>
<p><strong>传统内核态</strong>：权限管理严格，用户态和内核态通过页表进行严格隔离，任何特权操作都需要通过陷入内核完成。</p>
</li>
<li>
<p><strong>Dune模式</strong>：通过硬件支持的虚拟化技术，Dune在提供类似内核态权限的同时减少了上下文切换的开销，提升了操作效率。</p>
</li>
</ul>
</li>
<li>
<p>虚拟化硬件支持</p>
<ul>
<li>
<p><strong>传统内核态</strong>：依赖于操作系统和CPU架构的基本特性进行上下文切换和权限隔离。</p>
</li>
<li>
<p><strong>Dune模式</strong>：使用虚拟化硬件（如Intel VT-x）的高级特性，通过扩展页表（EPT）等机制实现更高效的权限管理和访问控制。</p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>总结</p>
<ul>
<li>
<p><strong>用户进程进入Dune模式</strong>时，虽然会涉及到一些与页表相关的操作，但这些操作通过虚拟化硬件进行管理，使得切换过程更加高效。</p>
</li>
<li>
<p><strong>传统的用户态到内核态的切换</strong>通常需要页表切换和上下文切换，以保证地址空间的隔离和权限管理。</p>
</li>
<li>
<p><strong>Dune模式</strong>通过虚拟化硬件提供了一种高效的替代方案，使用户进程在保留安全性的同时能够直接执行某些特权指令，减少了上下文切换的开销。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="ept-format-incompatibility问题">EPT format incompatibility问题
</h2><p>Dune 解决 EPT（扩展页表）和标准 x86 页表格式不兼容的问题的方式如下。以下是详细步骤、每步的主题和执行地点：</p>
<ol>
<li>
<p><strong>初始化空的 EPT（扩展页表）</strong></p>
<ul>
<li><strong>主题</strong>：EPT 初始配置</li>
<li><strong>执行地点</strong>：Dune 模块初始化阶段</li>
</ul>
<p>在 Dune 中，首先创建一个空的 EPT，表示此时并没有任何地址转换信息可用。这是因为 EPT 的格式与标准的 x86 页表格式不同，不能直接用于内核页表。</p>
</li>
<li>
<p><strong>在访问缺失的 EPT 条目时触发 EPT Fault</strong></p>
<ul>
<li><strong>主题</strong>：VM exit 处理</li>
<li><strong>执行地点</strong>：EPT Fault 处理程序</li>
</ul>
<p>每当访问缺失的 EPT 条目时，会触发一个 EPT Fault（这是一种 VM exit）。此时处理程序会捕获这个 Fault。</p>
</li>
<li>
<p><strong>向内核查询进程内存映射</strong></p>
<ul>
<li><strong>主题</strong>：查询内存映射</li>
<li><strong>执行地点</strong>：EPT Fault 处理程序内部</li>
</ul>
<p>当 EPT Fault 发生时，Dune 的处理程序会查询 Linux 内核，获取当前被访问的虚拟地址的内存映射和权限信息。此时需要向内核页面故障处理程序查询该地址的地址转换和权限。</p>
</li>
<li>
<p><strong>手动更新 EPT 以反映内核页表的映射</strong></p>
<ul>
<li><strong>主题</strong>：更新 EPT</li>
<li><strong>执行地点</strong>：EPT Fault 处理程序内部</li>
</ul>
<p>根据从内核查询到的地址转换信息，Dune 的处理程序会手动创建一个新的 EPT 条目。这个新条目反映了目标地址的正确物理地址和权限。该条目随后会**入到 EPT 中，以便处理故障的内存访问请求。</p>
</li>
<li>
<p><strong>处理地址区间的卸载（unmap）</strong></p>
<ul>
<li><strong>主题</strong>：地址区间管理</li>
<li><strong>执行地点</strong>：MMU 通知链中的处理程序</li>
</ul>
<p>系统运行过程中，有些地址区间可能会被卸载（unmap）。Dune 通过挂接到 MMU 通知链（这与 KVM 的做法类似）来处理这些事件。</p>
<ul>
<li>
<p><strong>当某个地址被卸载（unmapped）时</strong>，Dune 接收到一个事件通知。</p>
</li>
<li>
<p>Dune 然后会逐出（evict）受影响的 EPT 条目，并且在适当的 Linux 页面结构中设置脏位（dirty bits）。</p>
</li>
</ul>
</li>
<li>
<p><strong>支持页面访问信息和脏状态</strong></p>
<ul>
<li><strong>主题</strong>：页面状态维护</li>
<li><strong>执行地点</strong>：Dune 模块中的 MMU 通知链处理程序中</li>
</ul>
<p>为了支持内核的换页（swapping）和写回磁盘操作，内核需要页面的访问信息和脏状态。Dune 通过在 MMU 通知链中获取这些信息并适时地更新 EPT 及相应的页表条目来实现这一点。例如，当发现一个页面需要写回磁盘时，会将其在内核页表中的脏位标记为已设置。</p>
</li>
</ol>
<p><strong>整体流程总结</strong></p>
<ol>
<li><strong>初始化</strong>：创建空的 EPT。</li>
<li><strong>EPT Fault 处理</strong>：捕获 EPT Fault。</li>
<li><strong>查询内核映射</strong>：向内核查询当前地址的映射关系。</li>
<li><strong>更新 EPT</strong>：根据内核信息手动更新 EPT 条目。</li>
<li><strong>处理 Unmap</strong>：使用 MMU 通知链处理地址区间的卸载。</li>
<li><strong>页面状态维护</strong>：通过 MMU 通知链确保页面访问和脏状态信息的正确性。</li>
</ol>
<p>这些步骤确保了 Dune 能够在不直接共享页表的情况下，尽可能反映进程在标准 Linux 操作系统下的地址空间。这一过程克服了 EPT 和标准 x86 页表格式不兼容的问题，并且在处理地址转换和权限时保持高效和灵活。</p>
<hr>
<h2 id="ept-fault是vm-exit">EPT Fault是VM Exit
</h2><p>VM Exit 是指从虚拟机模式退出到虚拟机管理程序（VMM）或主机操作系统的过程。当虚拟机遇到某些特定的事件或情况时，处理无法继续在虚拟机模式下进行，需要切换到VMM模式来处理，这时候会发生VM Exit。</p>
<p>EPT（扩展页表）Fault 是由于虚拟机访问一个未被映射到物理内存的虚拟地址时发生的。当这样的情况发生时，虚拟机不能自行处理这个访问请求，需要主机的VMM处理，比如更新页表、加载数据等。这就需要退出到VMM模式，即触发一个VM Exit。</p>
<p>为了更详细地理解过程，我们可以假设有一个运行在Dune环境下的进程，该进程尝试访问一个尚未映射的虚拟地址。假设前提为：</p>
<ol>
<li>Dune进程在使用虚拟地址<code>0xCAFEBABE</code>进行读操作。</li>
<li>内核页表中关于此地址的信息尚未被加载到EPT中。</li>
</ol>
<p><strong>具体步骤</strong></p>
<ol>
<li><strong>初始化空的EPT</strong>
<ul>
<li><strong>主题</strong>：EPT初始配置</li>
<li><strong>地点</strong>：Dune模块初始化阶段</li>
<li><strong>操作</strong>：Dune开始时创建一个空的EPT，表示尚无地址转换信息可用。</li>
</ul>
</li>
<li><strong>触发一个EPT Fault和VM Exit</strong>
<ul>
<li><strong>主题</strong>：VM exit处理</li>
<li><strong>地点</strong>：EPT Fault处理程序</li>
<li><strong>操作</strong>：Dune进程尝试访问地址<code>0xCAFEBABE</code>。由于EPT中没有此地址的映射，发生了EPT Fault，导致一个VM Exit。</li>
</ul>
</li>
<li><strong>查询内核映射</strong>
<ul>
<li><strong>主题</strong>：查询内存映射</li>
<li><strong>地点</strong>：EPT Fault处理程序内部</li>
<li><strong>操作</strong>：VM Exit引发Dune的Fault处理程序通过页表查询内核，找到<code>0xCAFEBABE</code>对应的物理地址和权限。假设内核返回此地址映射到物理地址<code>0x12345000</code>，并且权限为读（R），写（W），执行（X）。</li>
</ul>
</li>
<li><strong>手动更新EPT</strong>
<ul>
<li><strong>主题</strong>：更新EPT</li>
<li><strong>地点</strong>：EPT Fault处理程序内部</li>
<li><strong>操作</strong>：根据内核信息，Dune在EPT中创建一个新的条目，将虚拟地址<code>0xCAFEBABE</code>映射到物理地址<code>0x12345000</code>，并设置适当的权限（RWX）。</li>
</ul>
</li>
<li><strong>Dune进程继续执行</strong>
<ul>
<li><strong>主题</strong>：继续进程执行</li>
<li><strong>地点</strong>：Dune进程</li>
<li><strong>操作</strong>：EPT更新后，Dune进程能够继续执行对地址<code>0xCAFEBABE</code>的访问请求，且这次不会触发VM Exit。</li>
</ul>
</li>
</ol>
<p><strong>处理地址区间的卸载</strong></p>
<p>假设后来某些原因导致地址区间<code>0xCAFEBABE</code>需要被卸载：</p>
<ol>
<li><strong>地址区间unmap事件</strong>
<ul>
<li><strong>主题</strong>：地址区间管理</li>
<li><strong>地点</strong>：MMU通知链的处理程序</li>
<li><strong>操作</strong>：Dune挂接到内核的MMU通知链，接收到地址<code>0xCAFEBABE</code>被unmap的通知。</li>
</ul>
</li>
<li><strong>清除EPT条目并更新内核页表</strong>
<ul>
<li><strong>主题</strong>：页面状态维护</li>
<li><strong>地点</strong>：Dune模块中的MMU通知链处理程序中</li>
<li><strong>操作</strong>：Dune清除受影响的EPT条目，并在Linux页表中相应设置脏位（如果需要）。</li>
</ul>
</li>
</ol>
<p>Dune通过捕获VM Exit和EPT Fault来处理内存映射，并在必要时更新EPT条目。相对于传统的VMM，它并不完整模拟硬件环境，而是利用内核提供的接口和通知机制（例如MMU通知链）来实现内存管理。这使得Dune更加轻量和高效，能够在尽可能少的开销下提供虚拟化支持。</p>
<hr>
<h2 id="tsc时间戳计数器">TSC（时间戳计数器）
</h2><p>TSC（Time Stamp Counter）是在CPU上的一个64位寄存器，用于记录自处理器重启以来经过的时钟周期数。程序可以使用rdtsc指令读取TSC的值来进行高精度的时间测量。由于TSC是与处理器的实际运行时钟直接相关的计数器，读取它不会引入额外的延时，因此非常适合性能分析等场景。然而，在虚拟化环境中，如果VMM对时间进行干预，TSC值可能会变得不太可靠，这就是为什么大多数VMM选择虚拟化TSC，以确保客操作系统获得一致的时间读数。</p>
<p>例如，在高性能计算或需要精确时间测量的应用环境中，直接访问TSC可以提供非常高的时间测量精度。然而，在虚拟化环境中，如果VMM对TSC时间进行干预，时间测量的精度和一致性可能会受到影响。</p>
<hr>
<h2 id="dune处理信号signals">Dune处理信号（signals）
</h2><p>Dune在处理信号（signals）时，使用了一种与传统方法不同的机制。</p>
<ul>
<li>对于硬件页面故障（page faults），Dune完全利用硬件机制，基本上取代了软件信号（如SIGSEGV）的角色。</li>
<li>而对于其他类型的信号（如SIGINT），Dune模块通过向进程注入伪硬件中断（fake hardware interrupts）来处理这些信号。这种机制不仅高效，而且在处理特权模式时也能正确组合。</li>
</ul>
<p>Dune在处理信号（signals）的具体解释：</p>
<ol>
<li><strong>硬件页面故障和SIGSEGV</strong>
<ul>
<li><strong>硬件页面故障</strong>：当进程访问没有映射的内存页时，硬件会产生一个页面故障。这种机制本身已经可以处理很多情况，比如尝试访问未授权内存、非法内存访问等。</li>
<li><strong>SIGSEGV替代</strong>：Dune利用硬件页面故障来处理SIGSEGV（Segmentation Fault，段错误）的情况，不再需要额外的软件信号处理，因为硬件页面故障已经涵盖了这些角色。</li>
</ul>
</li>
<li><strong>其他信号（如SIGINT）的处理</strong>
<ul>
<li><strong>注入伪硬件中断</strong>：对于其他类型的信号（如SIGINT），Dune会通过向进程内注入伪硬件中断来处理。当进程收到SIGINT信号时，Dune模块不直接处理信号，而是伪造一个硬件中断，这样进程在下次执行时会被中断处理器打断。</li>
<li><strong>高效性</strong>：这种方式高效，因为硬件中断的处理机制通常比软件信号处理更直接，并且利用现有的硬件支持。</li>
</ul>
</li>
<li><strong>特权模式的正确组合</strong>
<ul>
<li><strong>特权模式</strong>：特权模式指的是处理器的运行级别，通常包括用户态（ring 3）和内核态（ring 0）。</li>
<li><strong>自动切换特权模式</strong>：例如，一个用户进程在运行某些不可信的代码时，可以被置于更低的特权级别（ring 3）。当发生硬件中断时，处理器会自动从ring 3切换到ring 0，确保中断处理和信号处理的安全性。</li>
<li><strong>安全性的增强</strong>：这种机制确保即使在处理不可信代码时，硬件会自动进行特权级别的切换，从而保障系统的整体安全性。</li>
</ul>
</li>
</ol>
<p>假设一个用户进程正在运行，并且某些部分的代码由于不可信而在特权级别ring 3运行。在运行过程中：</p>
<ol>
<li>进程访问了一个未映射的内存地址，产生了页面故障。Dune利用硬件页面故障来处理这个访问，并不触发SIGSEGV软件信号。</li>
<li>用户按下Ctrl+C，发送SIGINT信号以中断进程。Dune模块接收到这个信号后，注入一个伪硬件中断到进程中。</li>
<li>由于硬件中断，处理器会自动从ring 3切换到ring 0安全地处理这个中断，并确保系统的安全性。</li>
</ol>
<p>这种方法不仅高效，而且在不同特权级别之间正确切换，增强了系统的安全性。</p>
<hr>
<h2 id="vpid的实现与工作原理">VPID的实现与工作原理
</h2><p>虚拟处理器标识符（VPIDs）提高了系统效率，特别是减少了TLB（翻译后备缓冲区）失效的开销。通过为每个Dune进程分配一个唯一的TLB标签，VPIDs使得在进行hypercalls和上下文切换时，不再需要频繁地刷新TLB。</p>
<p>TLB是一个高速缓存，用于存储虚拟地址到物理地址的映射。它的主要作用是加速虚拟内存的地址转换。如果TLB中的条目发生变化（例如由于上下文切换到另一个进程），则需要进行TLB失效操作，以确保地址转换正确。</p>
<p>每次TLB失效都意味着需要重新加载虚拟地址到物理地址的映射，这会带来显著的性能开销。尤其是当上下文切换频繁时，TLB失效会对系统性能产生较大影响。</p>
<p>VPID（Virtual Processor Identifier）是在处理器虚拟化扩展中引入的一项技术，用于减少或消除TLB失效操作。</p>
<ol>
<li><strong>为每个Dune进程分配唯一的TLB标签</strong>：
<ul>
<li><strong>传统做法</strong>：没有VPID时，每次上下文切换必须使TLB失效，以确保新进程不会使用旧进程的地址映射。</li>
<li><strong>VPID做法</strong>：有了VPID，每个Dune进程都有一个唯一的标识符，这个标识符也存在于TLB条目中。</li>
</ul>
</li>
<li><strong>TLB条目的标签</strong>：
<ul>
<li><strong>TLB条目</strong>：每个TLB条目不仅包含虚拟地址和物理地址的映射，还会包含对应的VPID。</li>
<li><strong>有效性检查</strong>：在上下文切换时，处理器可以根据VPID快速判断当前TLB条目是否对新进程仍然有效。如果VPID与当前进程的标识符不匹配，说明该条目属于其他进程，应忽略。</li>
</ul>
</li>
</ol>
<p>如何具体实现VPID呢？</p>
<ol>
<li><strong>分配VPID</strong>：
<ul>
<li><strong>初始化</strong>：每个Dune进程启动时，Dune模块会从处理器的VPID池中分配一个唯一的VPID。</li>
</ul>
</li>
<li><strong>使用VPID</strong>：
<ul>
<li><strong>TLB条目包含VPID</strong>：当一个Dune进程运行时，处理器在生成TLB条目时会包含该进程的VPID。</li>
<li><strong>上下文切换</strong>：上下文切换到另一个进程时，系统切换VPID而不必立即失效所有的TLB条目。</li>
</ul>
</li>
<li><strong>判断有效性</strong>：
<ul>
<li><strong>TLB查找</strong>：在进行地址转换时，处理器不仅检查虚拟地址，还会检查条目中的VPID是否与当前进程的VPID匹配。</li>
<li><strong>有效TLB命中</strong>：如果匹配，说明当前TLB条目有效，可以直接使用，避免了重新加载地址映射。</li>
</ul>
</li>
</ol>
<p>假设有两个Dune进程A和B，分别分配了VPID 1和VPID 2。</p>
<ol>
<li>进程A运行
<ul>
<li>处理器在TLB中存储了若干条目，VPID为1，这些条目映射A进程的地址。</li>
</ul>
</li>
<li>切换到进程B
<ul>
<li>处理器收到上下文切换请求，将当前的VPID设置为2，但不失效TLB条目。</li>
</ul>
</li>
<li>TLB操作
<ul>
<li>处理器在进行地址转换时，如果发现TLB条目中的VPID不等于2，则忽略这些条目。</li>
<li>只有VPID等于2的条目（即进程B的映射）才会被使用。</li>
</ul>
</li>
</ol>
<p>通过这种方式，Dune在进行hypercalls和上下文切换时，不再需要频繁地使TLB失效，从而大大提高了系统的效率。VPID的使用确保了每个进程的TLB条目是独立的，进程间互不干扰。</p>
<hr>
<h2 id="vmcall与syscall">VMCALL与SYSCALL
</h2><p>SYSCALL是x86架构中的一个指令，用于从用户态快速切换到内核态执行系统调用。它的主要用途是调用操作系统提供的服务，例如文件操作、进程管理等。这种切换通常伴随着上下文切换和权限级别的变化。</p>
<p>VMCALL是虚拟化扩展中的一条指令，用于从虚拟机内部向虚拟机管理程序（VMM）发出请求。这种请求通常用于管理虚拟机资源或者操作VMM提供的虚拟化服务。</p>
<p>为什么VMCALL比SYSCALL更快？在解释用VMCALL代替SYSCALL时，涉及一些虚拟化机制的细节：</p>
<ol>
<li><strong>拦截处理与开销</strong>：
<ul>
<li><strong>SYSCALL</strong>：传统的SYSCALL指令需要从用户态切到内核态，这涉及到特权级别的转换和上下文保存，可能会带来一定的开销。</li>
<li><strong>VMCALL</strong>：在虚拟化环境中，VMCALL用于虚拟机和虚拟机管理程序之间的通信。Dune可以利用这个机制来快速处理特权操作，而不需要进行多余的特权级别转换。</li>
</ul>
</li>
<li><strong>直接操作与简化路径</strong>：
<ul>
<li><strong>SYSCALL路径</strong>：SYSCALL路径可能涉及到复杂的系统调用处理逻辑，以及潜在的上下文切换和寄存器保存/恢复操作。</li>
<li><strong>VMCALL路径</strong>：VMCALL路径可以更直接，因为它已经被设计用于虚拟环境中的高效通讯，大部分情况下不需要进行复杂的操作。</li>
</ul>
</li>
<li><strong>Dune的特殊优化</strong>：
<ul>
<li><strong>Dune环境</strong>：在Dune中，用户进程可以直接使用一些特权硬件功能（通过Dune提供的接口），利用VMCALL可以避免SYSCALL路径的复杂性。</li>
<li><strong>libDune中的优化</strong>：修改后的libc通过VMCALL指令直接与Dune进行交互，可以减少系统调用的开销，从而获得性能提升。</li>
</ul>
</li>
</ol>
<p>假设有一个用户程序需要调用一个系统服务，比如获取当前时间：</p>
<ol>
<li><strong>传统的SYSCALL路径</strong>：
<ul>
<li>用户程序发出SYSCALL指令。</li>
<li>处理器切换到内核态，保存当前用户态上下文。</li>
<li>内核处理系统调用并返回结果。</li>
<li>处理器切换回用户态，恢复上下文。</li>
</ul>
</li>
<li><strong>改用VMCALL路径（在Dune中）</strong>：
<ul>
<li>用户程序发出VMCALL指令。</li>
<li>处理器直接交由Dune处理，可能跳过一些特权级别转换和复杂的系统调用路径逻辑。</li>
<li>Dune通过已经设置好的接口直接处理请求，提高执行效率。</li>
</ul>
</li>
</ol>
<p>正是由于这些优化，使得在虚拟化环境中，使用VMCALL指令相比于传统的SYSCALL指令，可以获得轻微的性能提升。这样，Dune可以更加高效地实现其特权操作，充分利用虚拟化环境下的硬件性能。</p>
<hr>
<h2 id="进程切换到dune模式的启动流程">进程切换到Dune模式的启动流程
</h2><p>将一个进程切换到Dune模式的启动流程。这类似于启动一个操作系统（OS）。具体步骤如下：</p>
<ol>
<li><strong>创建有效的页表</strong>
<ul>
<li><strong>要求</strong>：在切换到Dune模式之前，必须提供一个有效的页表。</li>
<li><strong>原因</strong>：简单的身份映射（identity mapping，虚拟地址直接映射到相同的物理地址）是不够的，因为需要考虑到EPT（扩展页表）的压缩布局。这个压缩布局意味着虚拟地址空间在EPT中的表现方式可能有所不同，需要一个特定的页表来匹配这种布局。</li>
</ul>
</li>
<li><strong>调用Dune入口ioctl</strong>
<ul>
<li><strong>过程</strong>：一旦页表创建完成，通过传递页表根（page table root）作为参数来调用Dune entry ioctl。这个系统调用是用来通知Dune模块开始切换模式。</li>
<li><strong>操作</strong>：Dune模块接收到ioctl调用后，会切换进程到Dune模式，并开始执行代码，使用提供的页表根作为初始的%CR3寄存器值。</li>
</ul>
</li>
<li><strong>libDune进一步配置环境</strong>
<ul>
<li><strong>配置特权寄存器</strong>：libDune会配置一些特权寄存器来建立一个合理的操作环境。</li>
<li><strong>加载GDT</strong>：全局描述符表（GDT）被加载，用于提供基本的平面分段。</li>
<li><strong>加载IDT</strong>：中断描述符表（IDT）被加载，用于捕获硬件异常。</li>
<li><strong>设置TSS中的独立栈</strong>：任务状态段（TSS）中设置了一个独立的栈，用于处理双重故障（double faults）。</li>
<li><strong>配置GS段基址</strong>：配置GS段的基址，以便轻松访问每个线程的数据。</li>
</ul>
</li>
</ol>
<p>为什么不能直接映射页表？简单的身份映射无法满足Dune需求的原因有以下几点：</p>
<ol>
<li><strong>EPT的压缩布局</strong>：
<ul>
<li>在Dune环境中，EPT所使用的物理内存布局可能不同于传统的直接映射。这种压缩布局允许Dune更高效地管理内存，但也意味着需要特定的页表来正确映射这些地址。</li>
</ul>
</li>
<li><strong>地址空间一致性</strong>：
<ul>
<li>尽管目标是让进程在转换前后的地址保持一致，但需要确保这些地址能够在EPT的压缩布局中有效映射。直接身份映射可能无法在压缩布局中找到合适的位置。</li>
</ul>
</li>
</ol>
<p>在切换到Dune模式和配置操作环境期间，以下寄存器会发生变化：</p>
<ol>
<li><strong>%CR3寄存器</strong>：
<ul>
<li>这个寄存器包含页表根地址，切换到Dune模式后，%CR3会被设置为提供的页表根。</li>
</ul>
</li>
<li><strong>特权寄存器</strong>：
<ul>
<li><strong>GDT（全局描述符表基址寄存器）</strong>：加载一个新的GDT来提供基本平面分段。</li>
<li><strong>IDT（中断描述符表基址寄存器）</strong>：加载一个新的IDT来捕获硬件异常。</li>
</ul>
</li>
<li><strong>TSS（任务状态段）</strong>：
<ul>
<li>设置一个独立的栈用于处理双重故障。如果发生双重故障，处理器会使用TSS中的栈。</li>
</ul>
</li>
<li><strong>段寄存器</strong>：
<ul>
<li><strong>GS段寄存器</strong>：配置GS段的基址，以便访问线程本地存储（TLS）数据。这个访问是为了让每个线程能够拥有独立的数据区，减少线程之间的干扰。</li>
</ul>
</li>
</ol>
<p>将进程切入Dune模式需要考虑到许多细节，以确保环境的正确性和高效性。从提供合适的页表到配置各种特权寄存器，每一步都至关重要。这种复杂的启动过程确保了Dune能够提供一个强大且高效的虚拟化环境。</p>
<blockquote>
<p>传递页表根（page table root）作为参数在将进程切换到Dune模式中的作用非常重要，这是因为页表根决定了整个虚拟地址空间的映射方式。以下是更详细的解释：</p>
<p>页表根通常指页表的顶层指针，它在 x86 架构中存储在 %CR3 寄存器中。这个指针指向一个多级页表的起点，页表用于管理虚拟内存地址到物理内存地址的映射。页表根的主要作用为：</p>
<ol>
<li><strong>初始化内存映射环境</strong>：</li>
</ol>
<ul>
<li><strong>作用</strong>：页表根指向了多级页表的起点，通过这些页表，系统可以将虚拟地址转换为物理地址。这是虚拟内存管理的核心。</li>
<li><strong>重要性</strong>：在切换到Dune模式时，传递页表根作为参数可以确保虚拟地址能够正确映射到物理地址，从而使进程能够继续无缝运行。</li>
</ul>
<ol start="2">
<li><strong>保证地址空间一致性</strong>：
<ul>
<li><strong>作用</strong>：传递页表根使得Dune可以使用调用方提供的内存映射，从而保证进程在切换到Dune模式前后的地址空间保持一致。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>重要性</strong>：地址空间的一致性对于进程的正常运行至关重要。否则，进程可能会在切换后找不到所需的内存，导致崩溃或异常行为。</li>
</ul>
<ol start="3">
<li><strong>支持EPT压缩布局</strong>：
<ul>
<li><strong>作用</strong>：Dune利用EPT（扩展页表）对内存进行管理，这可能涉及到内存的压缩布局。传递特定的页表根可以确保内存映射符合Dune的需求。</li>
<li><strong>重要性</strong>：简单身份映射无法适应EPT的压缩布局，必须使用特定的页表根来匹配这些布局，以确保虚拟地址在物理内存中的合理分布。</li>
</ul>
</li>
</ol>
<p>具体过程</p>
<ol>
<li><strong>创建页表</strong>：
<ul>
<li>在将进程切换到Dune模式之前，系统或libDune会生成并设置一个新的页表，这个页表按照Dune环境的需求进行映射和配置。</li>
</ul>
</li>
<li><strong>传递页表根</strong>：</li>
</ol>
<ul>
<li>当调用Dune entry ioctl时，新创建的页表根作为参数传递给Dune模块。</li>
</ul>
<ol start="3">
<li><strong>更新%CR3寄存器</strong>：</li>
</ol>
<ul>
<li>Dune模块接收到页表根后，会将其设置为%CR3寄存器的值。这样，处理器在进行地址转换时，就会根据这个新的页表来进行虚拟地址到物理地址的映射。</li>
</ul>
<ol start="4">
<li><strong>环境配置</strong>：
<ul>
<li>之后，libDune会继续配置其他特权寄存器和必要的系统资源，例如加载GDT、IDT，设置TSS栈和GS段基址等，以完成虚拟化环境的初始化。</li>
</ul>
</li>
</ol>
<p>假设我们有一个进程，其虚拟内存地址需要映射到特定的物理地址：</p>
<ul>
<li><strong>原始页表</strong>：原来的页表根指向某个起始地址<code>P</code>，包含对虚拟地址<code>V1</code>到物理地址<code>P1</code>的映射，以及<code>V2</code>到<code>P2</code>的映射。</li>
<li><strong>新页表</strong>：在切换到Dune模式之前，生成一个新页表根指向地址<code>Q</code>，这个新页表符合Dune的EPT布局，并且依然包含对<code>V1</code>到<code>P1</code>，<code>V2</code>到<code>P2</code>的映射。</li>
</ul>
<p>当进程切换到Dune模式并传递新页表根之后：</p>
<ul>
<li>%CR3寄存器会被更新为新页表根<code>Q</code>。</li>
<li>处理器将使用新页表来进行地址转换，确保虚拟地址<code>V1</code>和<code>V2</code>依然能够正确地映射到<code>P1</code>和<code>P2</code>，从而确保进程的正常运行。</li>
</ul>
<p>传递页表根作为参数在切换到Dune模式中至关重要，因为它确保了虚拟地址到物理地址的正确映射，保证地址空间一致性，并适应Dune的EPT布局需求。这个步骤有效地初始化了内存管理环境，使得系统能够顺利过渡到虚拟化状态。</p>
<blockquote>
<p>为什么直接使用旧的页表根并不可行，以及为什么在Dune模式下需要新页表根。关键差异和原因：</p>
<ol>
<li>
<p>EPT和标准页表的格式差异</p>
<ul>
<li>
<p><strong>标准页表</strong>：这是操作系统使用的页表，用于管理虚拟地址到物理地址的映射。</p>
</li>
<li>
<p><strong>EPT（扩展页表）</strong>：这是硬件虚拟化中的一个关键组件，尤其在Intel VT-x技术中使用。EPT具有不同的格式和特点，不完全兼容常规的页表格式。</p>
</li>
</ul>
</li>
<li>
<p>EPT压缩布局</p>
<ul>
<li>
<p><strong>地址空间压缩</strong>：Dune模式可能对某些虚拟地址进行压缩布局，以适应硬件虚拟化需求。如果直接使用旧的页表根，无法利用这些压缩布局的优化，可能会导致内存映射无效或效率低下。</p>
</li>
<li>
<p><strong>专用页表结构</strong>：为了支持这些优化，Dune需要一个特别设计的页表结构，这些结构与常规页表可能完全不同。</p>
</li>
</ul>
</li>
<li>
<p>内存保护和隔离</p>
<ul>
<li>
<p><strong>安全性</strong>：Dune需要确保进程在虚拟化和非虚拟化模式之间的切换过程中，内存保护和隔离的一致性。采用新页表根可以防止在转换过程中出现安全漏洞或内存访问违规。</p>
</li>
<li>
<p><strong>特权寄存器设置</strong>：不同模式下，特权寄存器的配置方式不同，直接使用旧页表根可能无法正确初始化这些寄存器。</p>
</li>
</ul>
</li>
</ol>
<p>通过实际操作的解析，理解为什么需要新页表根会更为直观。</p>
<ol>
<li><strong>初始化新页表根</strong>：</li>
</ol>
<ul>
<li>
<p><strong>生成新页表</strong>：在进入Dune模式之前，系统会生成一个符合Dune需求的页表，它考虑到EPT的特殊布局和格式。</p>
</li>
<li>
<p><strong>设置映射</strong>：根据旧页表的信息，将必要的虚拟地址到物理地址的映射配置到新页表中，但格式和布局可能不同。</p>
</li>
</ul>
<ol start="2">
<li><strong>调用初始化IOCTL</strong>：</li>
</ol>
<ul>
<li>
<p><strong>传递新页表根</strong>：通过IOCTL调用，把新页表根传递给Dune模块。</p>
</li>
<li>
<p><strong>更新%CR3寄存器</strong>：Dune模块将新页表根设置为%CR3寄存器的值，使处理器在进入Dune模式后使用新页表进行地址转换。</p>
</li>
</ul>
<ol start="3">
<li><strong>配置其他特权资源</strong>：</li>
</ol>
<ul>
<li>
<p><strong>加载GDT、IDT</strong>：在初始化过程中，libDune会加载全局描述符表（GDT）和中断描述符表（IDT），这些操作依赖于新页表的正确配置。</p>
</li>
<li>
<p><strong>设置TSS栈和GS段基址</strong>：这些配置同样需要依赖新的页表布局，以确保处理器可以正确访问所需的内存区域。</p>
</li>
</ul>
<p>假设我们有以下内存布局需求：</p>
<ul>
<li><strong>虚拟地址V1</strong>映射到<strong>物理地址P1</strong>。</li>
<li><strong>虚拟地址V2</strong>映射到<strong>物理地址P2</strong>。</li>
</ul>
<p>原始页表的情形：</p>
<ul>
<li><strong>页表根P</strong>：指向的页表中，V1 -&gt; P1，V2 -&gt; P2。</li>
</ul>
<p>新页表的情形（Dune的需求下）：</p>
<ul>
<li>
<p>页表根Q：由于EPT的格式和压缩布局要求，这个新页表的结构可能如下：</p>
</li>
<li>
<p>新的页表具有压缩特性，在同样完成V1 -&gt; P1，V2 -&gt; P2映射的同时，其方式更加优化和特定化，适应Dune环境。</p>
</li>
</ul>
<p>尽管旧页表和新页表在内容上可能看起来相似（例如映射相同的虚拟地址到物理地址），但它们的格式、结构和布局可能存在显著差异，这些差异对于支持Dune模式下的高效虚拟化至关重要。直接使用旧的页表根无法满足这些需求，因此必须提供一个新的页表根来确保Dune模式下的正确性和性能。</p>
</blockquote>
</blockquote>
<hr>
<h2 id="sandbox防御elf-header-攻击">sandbox防御ELF header 攻击
</h2><p>ELF文件是Linux系统的常见可执行文件格式，包含了程序的头部（header），该头部定义了二进制文件的各种结构和加载方式。不良设计或恶意构造的ELF头部可能会试图利用ELF加载器中的漏洞，从而实现代码注入或其他攻击。</p>
<p>为了防御ELF头部攻击，Dune的沙箱采用了双重ELF加载器策略：</p>
<ol>
<li><strong>初始ELF加载器（Minimal ELF Loader）</strong>：
<ul>
<li><strong>角色</strong>：负责加载沙箱运行时环境。</li>
<li><strong>实现</strong>：这个加载器是libDune的一部分，只支持静态二进制文件的加载。</li>
<li><strong>安全性</strong>：由于只支持静态二进制文件，其复杂度和攻击面都较小，减少了被恶意ELF头部利用的风险。</li>
</ul>
</li>
<li><strong>二次ELF加载器（ld-linux.so）</strong>：
<ul>
<li><strong>角色</strong>：在沙箱内加载不可信的二进制文件。</li>
<li><strong>实现</strong>：使用Linux中的<code>ld-linux.so</code>，它是一个经过广泛使用和信任的ELF加载器。</li>
<li><strong>安全性</strong>：<code>ld-linux.so</code>已经是Linux系统中不可或缺且受到信任的组件，经过严格的安全审查和优化。</li>
</ul>
</li>
</ol>
<p>双重ELF加载器策略防御的详细流程如下</p>
<ol>
<li><strong>加载沙箱运行时环境</strong>：
<ul>
<li><strong>步骤</strong>：内核启动沙箱进程，并通过libDune中的初始ELF加载器载入一个独立的、最小化的沙箱运行时环境。</li>
<li><strong>复杂度</strong>：因为这个加载器只支持静态二进制文件，功能简单，减少了被攻击的可能性。</li>
</ul>
</li>
<li><strong>加载二次ELF加载器</strong>：
<ul>
<li><strong>步骤</strong>：沙箱运行时环境使用初始ELF加载器，把<code>ld-linux.so</code>（作为二次ELF加载器的一部分）加载到一个不可信的环境中。</li>
<li><strong>信任</strong>：使用<code>ld-linux.so</code>是因为它是Linux系统的一部分，经过广泛使用和安全验证。</li>
</ul>
</li>
<li><strong>加载不可信二进制文件</strong>：
<ul>
<li><strong>步骤</strong>：<code>ld-linux.so</code>运行在沙箱内的用户态中，从不可信的环境中加载和执行不可信的二进制文件。</li>
<li><strong>防御</strong>：因为<code>ld-linux.so</code>在用户态（ring 3）运行，即使不可信的二进制文件包含恶意的ELF头部，其攻击范围也仅限于用户态，无法直接影响内核或沙箱的运行时环境。这限制了其破坏力。</li>
</ul>
</li>
</ol>
<p>Dune沙箱通过采用双重ELF加载器机制，有效地将潜在的ELF头部攻击风险最小化。初始ELF加载器简单且只有有限的功能，使其难以成为攻击目标。而二次ELF加载器<code>ld-linux.so</code>在用户态加载不可信二进制文件，即使有攻击发生，也局限在用户态范围内，避免影响沙箱的核心安全性。</p>
<blockquote>
<p>ELF头部攻击的实现和原理</p>
<p>ELF（Executable and Linkable Format）文件是Linux和其他类Unix操作系统中常见的可执行文件格式。ELF头部包含了关于文件布局和加载信息的元数据，例如程序头表、节头表、入口点地址等。恶意构造的ELF头部可以尝试利用ELF加载器中的漏洞，从而实现代码注入或其他攻击。</p>
<p>ELF头部攻击通常利用以下几个方面：</p>
<ol>
<li><strong>格式解析漏洞</strong>：</li>
</ol>
<ul>
<li><strong>描述</strong>：ELF加载器在解析头部信息时出现的漏洞。例如，缓冲区溢出、整数溢出、未做边界检查等。</li>
<li><strong>影响</strong>：攻击者可以通过构造特别的头部数据，使加载器在解析时发生溢出或崩溃，从而执行任意代码或读取不应访问的内存区域。</li>
</ul>
<ol start="2">
<li><strong>高级加载器功能滥用</strong>：
<ul>
<li><strong>描述</strong>：ELF格式支持复杂的加载和链接功能，如动态链接、内存映射、重定位等。攻击者可以利用这些功能，通过精心设计的头部信息，实现加载器预期之外的行为。</li>
<li><strong>影响</strong>：例如，构造特定的段表和节表，使加载器跳到恶意代码的地址处执行。</li>
</ul>
</li>
</ol>
<p>以下是几个可能的ELF头部攻击实现方法：</p>
<ol>
<li><strong>缓冲区溢出</strong>：</li>
</ol>
<ul>
<li><strong>原理</strong>：通过构造异常长的字段值，诱使加载器在处理这些字段时发生缓冲区溢出。常见的目标字段包括节名字、节表项、程序头表项等。</li>
<li><strong>示例</strong>：将段表或节表的大小字段设置得超大，加载器试图读取或处理超大数据量时发生溢出，导致恶意代码被执行。</li>
</ul>
<ol start="2">
<li><strong>整数溢出</strong>：
<ul>
<li><strong>原理</strong>：利用加载器在处理ELF头部时的整数溢出漏洞。通过设置特定的字段值，诱使加载器在计算内存位置或大小时发生溢出，从而覆盖关键数据。</li>
<li><strong>示例</strong>：将某个偏移字段设置为接近整数上限，使加载器在加法操作时发生溢出，导致访问不该访问的内存地址。</li>
</ul>
</li>
<li><strong>段表和节表操控</strong>：
<ul>
<li><strong>原理</strong>：通过操纵段表和节表中的条目，使加载器加载和执行恶意代码段。</li>
<li><strong>示例</strong>：将PT_LOAD段的虚拟地址设为指向恶意代码的位置，加载器在加载段时会将恶意代码映射到进程地址空间并执行。</li>
</ul>
</li>
<li><strong>重定位表攻击</strong>：
<ul>
<li><strong>原理</strong>：ELF文件中包含重定位表，用于动态重定位符号地址。攻击者可以构造恶意重定位条目，导致加载器跳转到恶意代码。</li>
<li><strong>示例</strong>：在重定位表中添加条目，使特定的符号地址被重定向到攻击者控制的内存区域。</li>
</ul>
</li>
</ol>
<p>为了防止上述攻击，常见的防御措施包括：</p>
<ol>
<li><strong>硬化加载器</strong>：</li>
</ol>
<ul>
<li><strong>边界检查</strong>：认真检查每个字段的边界，不允许超出预期范围。</li>
<li><strong>格式验证</strong>：严格遵循ELF规范，验证每个部分的格式和一致性。</li>
</ul>
<ol start="2">
<li><strong>运行时防护</strong>：
<ul>
<li><strong>地址空间布局随机化（ASLR）</strong>：随机化内存地址布局，使攻击者难以预测内存位置。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>栈保护（Stack Canaries）</strong>：在栈变量前后添加特定的哨兵值，防止栈溢出攻击。</li>
</ul>
<ol start="3">
<li><strong>最小化加载器功能</strong>：
<ul>
<li><strong>静态二进制支持</strong>：如Dune中的初始ELF加载器，仅支持静态二进制文件，减少复杂功能的使用。</li>
<li><strong>双层加载策略</strong>：分离初始加载器和高级加载器，减少初始加载器的攻击面，并在不可信环境中运行高级加载器，如ld-linux.so。</li>
</ul>
</li>
</ol>
<p>以下是一个简单的ELF头部溢出攻击示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">ccodepreviewrun</span><span class="c1">// 伪代码示例，实际情况可能更复杂
</span></span></span><span class="line"><span class="cl"><span class="c1">// 攻击者构造的恶意ELF头部
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="n">elf_header</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 正常的ELF头部
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="kt">char</span> <span class="n">e_ident</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span> <span class="c1">// ELF标识
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint16_t</span> <span class="n">e_type</span><span class="p">;</span>  <span class="c1">// 文件类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="kt">uint16_t</span> <span class="n">e_machine</span><span class="p">;</span> <span class="c1">// 机器类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint32_t</span> <span class="n">e_version</span><span class="p">;</span> <span class="c1">// 版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint64_t</span> <span class="n">e_entry</span><span class="p">;</span>   <span class="c1">// 入口点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint64_t</span> <span class="n">e_phoff</span><span class="p">;</span>   <span class="c1">// 程序头偏移
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint64_t</span> <span class="n">e_shoff</span><span class="p">;</span>   <span class="c1">// 节头偏移
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint32_t</span> <span class="n">e_flags</span><span class="p">;</span>   <span class="c1">// 标志
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint16_t</span> <span class="n">e_ehsize</span><span class="p">;</span>  <span class="c1">// ELF头大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint16_t</span> <span class="n">e_phentsize</span><span class="p">;</span> <span class="c1">// 程序头项大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint16_t</span> <span class="n">e_phnum</span><span class="p">;</span>     <span class="c1">// 程序头项数目
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint16_t</span> <span class="n">e_shentsize</span><span class="p">;</span> <span class="c1">// 节头项大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint16_t</span> <span class="n">e_shnum</span><span class="p">;</span>     <span class="c1">// 节头项数目
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint16_t</span> <span class="n">e_shstrndx</span><span class="p">;</span>  <span class="c1">// 字符串节索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 溢出部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">char</span> <span class="n">overflow</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span> <span class="c1">// 超长字段，企图溢出缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint64_t</span> <span class="n">malicious_code</span><span class="p">;</span> <span class="c1">// 恶意代码地点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>攻击者可以通过修改上述字段，例如设置虚拟地址段为指向<code>malicious_code</code>部分，使加载器在解析阶段受溢出影响，将控制权转移到恶意代码。</p>
<p>ELF头部攻击通过构造恶意头部数据，利用加载器中的漏洞，实现代码注入或其他恶意操作。通过严谨的加载器设计和运行时保护机制，可以有效防御这类攻击。Dune采用双重ELF加载器策略，通过最小化初始加载器功能和使用可信的高级加载器，大大降低了头部攻击的风险。</p>
<blockquote>
<p>分离初始加载器和高级加载器的概念</p>
<p>初始加载器（Minimal ELF Loader）</p>
<ul>
<li><strong>功能有限</strong>：只支持加载静态（static）二进制文件，具有最低限度的功能。</li>
<li><strong>目标</strong>：主要用于加载高级加载器，而不直接加载不可信的二进制文件。</li>
<li><strong>典型例子</strong>：libDune中的最小ELF加载器。</li>
</ul>
<p>高级加载器（Secondary ELF Loader）</p>
<ul>
<li><strong>功能全面</strong>：可以处理动态链接（dynamic linking）、重定位（relocation）等复杂操作。</li>
<li><strong>目标</strong>：在不可信环境中加载和执行不可信的二进制文件。</li>
<li><strong>典型例子</strong>：Linux中常用的<code>ld-linux.so</code>。</li>
</ul>
<p><strong>分离加载策略的流程</strong></p>
<ol>
<li><strong>初始加载器加载沙箱运行时环境</strong>：</li>
</ol>
<ul>
<li>加载并初始化一个非常精简和受信任的沙箱运行时环境，以便在安全和受限的环境中执行后续操作。</li>
</ul>
<ol start="2">
<li><strong>初始加载器加载高级加载器</strong>：</li>
</ol>
<ul>
<li>使用初始加载器将高级加载器（如<code>ld-linux.so</code>）加载到沙箱的用户态环境中。此时，初始加载器的责任就完成了。</li>
</ul>
<ol start="3">
<li><strong>高级加载器加载不可信的二进制文件</strong>：</li>
</ol>
<ul>
<li>
<p>在沙箱的用户态环境中，高级加载器开始加载和执行不可信的二进制文件。</p>
</li>
<li>
<p>即使不可信的二进制文件包含恶意头部，高级加载器运行在用户态，攻击面较小，只能影响沙箱内部而不影响整个系统。</p>
</li>
</ul>
<p>设想以下场景：一个不可信的二进制文件<code>untrusted_app</code>需要在Dune沙箱中运行。</p>
<ol>
<li>初始化和配置</li>
</ol>
<ul>
<li>
<p><strong>创建沙箱</strong>：内核启动一个新的进程，进入Dune模式，创建一个隔离的沙箱运行时环境。</p>
</li>
<li>
<p><strong>初始加载器</strong>：libDune的最小ELF加载器被加载到沙箱中。</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// 初始加载器的简化伪代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">initial_loader</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">secondary_loader_path</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 加载静态二进制文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">load_static_binary</span><span class="p">(</span><span class="s">&#34;/path/to/sandbox_runtime&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 加载二级加载器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">load_static_binary</span><span class="p">(</span><span class="n">secondary_loader_path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 跳转执行二级加载器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">jump_to_entry_point</span><span class="p">(</span><span class="n">secondary_loader_path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>初始加载器加载高级加载器</li>
</ol>
<ul>
<li>
<p><strong>路径</strong>：假设高级加载器的路径是<code>/lib64/ld-linux-x86-64.so.2</code>。</p>
</li>
<li>
<p><strong>加载操作</strong>：初始加载器将<code>ld-linux.so</code>加载到沙箱中，并跳转到它的入口点。</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// 继续初始加载器的伪代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">initial_loader</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">secondary_loader_path</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 加载静态二进制文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">load_static_binary</span><span class="p">(</span><span class="s">&#34;/path/to/sandbox_runtime&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 加载二级加载器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">load_static_binary</span><span class="p">(</span><span class="n">secondary_loader_path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 跳转执行二级加载器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">jump_to_entry_point</span><span class="p">(</span><span class="n">secondary_loader_path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">initial_loader</span><span class="p">(</span><span class="s">&#34;/lib64/ld-linux-x86-64.so.2&#34;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>高级加载器加载不可信二进制文件</li>
</ol>
<ul>
<li>
<p><strong>启动路径</strong>：在<code>ld-linux.so</code>加载并初始化后，它开始处理不可信的二进制文件<code>untrusted_app</code>。</p>
</li>
<li>
<p><strong>内存映射</strong>：<code>ld-linux.so</code>处理ELF头部，并映射不可信二进制文件中的各个段。</p>
</li>
<li>
<p><strong>执行</strong>：完成加载后，<code>ld-linux.so</code>将控制权转交给<code>untrusted_app</code>的入口点，开始执行不可信代码。</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp"># 使用ld-linux.so加载并执行不可信二进制文件
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">ld</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">x86</span><span class="o">-</span><span class="mf">64.</span><span class="n">so</span><span class="mf">.2</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">untrusted_app</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="4">
<li>安全保障</li>
</ol>
<ul>
<li>
<p><strong>用户态执行</strong>：整个加载和执行过程在沙箱的用户态（ring 3）进行，限制了不可信代码的权限和影响范围。</p>
</li>
<li>
<p><strong>高级加载器的安全性</strong>：由于<code>ld-linux.so</code>是经过大量使用和安全审查的组件，其安全性较高，减少了被恶意头部利用的可能。</p>
</li>
</ul>
<p>总结</p>
<p>通过分离初始加载器和高级加载器的加载过程，Dune能够有效地抵御ELF头部攻击：</p>
<ul>
<li><strong>初始加载器</strong>功能有限，只负责加载高级加载器，并且设计简单，减少攻击面。</li>
<li><strong>高级加载器</strong>运行在用户态，并且经过充分验证和使用，在加载不可信二进制文件时，能最大限度地减少安全风险。</li>
</ul>
<p>这种分离策略不仅提高了加载过程的安全性，还确保了即使不可信代码包含恶意头部，攻击的范围和影响也被限制在沙箱环境内。</p>
</blockquote>
</blockquote>
<blockquote>
<p>初始加载器确实在限定和设置高级加载器的运行环境方面起到了关键作用。如果没有初始加载器，直接加载高级加载器可能会带来一系列问题和安全隐患。让我们详细探讨这种分离策略的设计理由和必要性。</p>
<p><strong>初始加载器的主要作用</strong></p>
<ol>
<li><strong>环境初始化</strong>：</li>
</ol>
<ul>
<li><strong>安全的执行环境</strong>：初始加载器负责创建一个受限制的、安全的执行环境，确保不可信代码在隔离的沙箱中运行。加载高级加载器之前，初始化必要的安全机制。</li>
<li><strong>基础设施设置</strong>：例如，配置页表、加载全局描述符表（GDT）、中断描述符表（IDT），以及设置任务状态段（TSS）中的栈等。这些操作需要在特权模式下（ring 0）完成，是高级加载器无法直接处理的。</li>
</ul>
<ol start="2">
<li><strong>功能简化，减少攻击面</strong>：</li>
</ol>
<ul>
<li><strong>只加载静态二进制</strong>：初始加载器只支持加载功能受限的静态二进制文件，功能简单，减少了潜在漏洞的数量和复杂度。</li>
<li><strong>有限的攻击面</strong>：由于功能的简化，初始加载器的代码攻击面相对较小，不容易被恶意利用。</li>
</ul>
<ol start="3">
<li><strong>上下文切换和执行控制</strong>：</li>
</ol>
<ul>
<li><strong>受控地启动高级加载器</strong>：初始加载器负责安全地加载和启动高级加载器，在确保环境安全的前提下，转移执行控制权。</li>
<li><strong>配置用户态环境</strong>：在加载高级加载器之前，初始加载器可以设置用户态的特定配置，确保高级加载器在一个预期和受控的环境中运行。</li>
</ul>
<p><strong>如果没有初始加载器的后果</strong></p>
<ol>
<li><strong>缺乏安全保障</strong>：</li>
</ol>
<ul>
<li><strong>直接暴露高级加载器</strong>：如果直接加载高级加载器（如<code>ld-linux.so</code>），任何环境初始化和安全配置都无法保证，加载过程可能会暴露在潜在的安全威胁中。</li>
<li><strong>特权操作</strong>：高级加载器一般在用户态运行，缺乏执行特权操作的能力，如设置页表和配置特权寄存器，这些操作对于创建安全的执行环境至关重要。</li>
</ul>
<ol start="2">
<li><strong>复杂度增加</strong>：</li>
</ol>
<ul>
<li><strong>处理复杂性</strong>：直接暴露高级加载器需要它处理非常复杂的环境初始化和安全设置，增加了代码复杂性，也增加了潜在漏洞的数量。</li>
<li><strong>安全审计难度</strong>：代码复杂性和多样化功能使得对加载器进行全面安全审计变得更加困难，增加了被攻击的风险。</li>
</ul>
<ol start="3">
<li><strong>加载路径不受控制</strong>：</li>
</ol>
<ul>
<li><strong>潜在恶意干扰</strong>：未经初始加载器预先配置和限制的加载路径可能被恶意代码干扰，导致加载不可信的或未签名的代码片段。</li>
</ul>
<p>通过对加载流程的具体示例，我们可以更好地理解初始加载器的作用：</p>
<p>步骤1：内核启动并加载初始加载器</p>
<ul>
<li><strong>进入Dune模式</strong>：内核启动一个新的进程，并将其切入Dune模式，初始化隔离环境。</li>
<li><strong>加载最小ELF加载器</strong>：内核通过libDune加载一个功能受限的、只支持静态二进制的初始加载器。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// 伪代码示例：内核启动的部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">kernel_startup</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 切换到Dune模式，初始化安全环境
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">enter_dune_mode</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 加载并执行初始加载器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">load_initial_loader</span><span class="p">(</span><span class="s">&#34;/path/to/minimal_loader&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>步骤2：初始加载器加载和设置高级加载器</p>
<ul>
<li><strong>加载高级加载器</strong>：初始化基本环境后，初始加载器将<code>ld-linux.so</code>加载到受限的用户态环境中。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// 初始加载器的伪代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">initial_loader</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">secondary_loader_path</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 设置基本的安全环境，如页表、GDT、IDT、TSS等
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">setup_basic_environment</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 加载高级加载器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">load_static_binary</span><span class="p">(</span><span class="n">secondary_loader_path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 转移控制权到高级加载器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">jump_to_entry_point</span><span class="p">(</span><span class="n">secondary_loader_path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nf">initial_loader</span><span class="p">(</span><span class="s">&#34;/lib64/ld-linux-x86-64.so.2&#34;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>步骤3：高级加载器加载不可信二进制文件</p>
<ul>
<li><strong>用户态执行</strong>：在安全的用户态环境中，高级加载器<code>ld-linux.so</code>负责加载不可信的二进制文件，并执行它们。</li>
<li><strong>防御机制生效</strong>：即使不可信二进制文件包含恶意ELF头部，攻击面仅限于用户态，无法影响内核或特权环境。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp"># 使用高级加载器加载并执行不可信二进制文件
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">ld</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">x86</span><span class="o">-</span><span class="mf">64.</span><span class="n">so</span><span class="mf">.2</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">untrusted_app</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过以上解释和示例可以看到，初始加载器在设置和限制高级加载器的运行环境方面起到了关键作用。没有初始加载器的附加保护，高级加载器的环境将无法控制，容易受到恶意代码的攻击和干扰。初始加载器确保了安全的环境初始化和基本配置，从而为高级加载器提供了一个安全和受控的执行环境。这种分离策略不仅提高了加载过程的安全性，还限制了恶意代码的攻击范围，确保整个系统的稳定和安全。</p>
</blockquote>
<hr>
<h2 id="machine-abstraction">Machine Abstraction
</h2><p>“使用虚拟化硬件提供进程抽象，而不是机器抽象”，实际上在描述虚拟化技术的不同层次和方式。为了更好地理解其中的概念，我们需要先弄清楚“进程抽象（process abstraction）”和“机器抽象（machine abstraction）”的含义。</p>
<ol>
<li>
<p><strong>Machine Abstraction（机器抽象）</strong></p>
<p>“机器抽象”指的是通过虚拟化技术，将一台物理计算机抽象成多个虚拟机，每个虚拟机看起来像是一台独立的物理计算机。这种虚拟化是以“机器”为核心的，每个虚拟机都有独立的硬件资源（如CPU、内存、存储等），并运行一个完整的操作系统。用户或应用程序看到的是一个完整的虚拟机器。</p>
<p>这种虚拟化技术的典型例子是<strong>虚拟机管理程序（Hypervisor）</strong>，比如VMware、Xen或者KVM。每个虚拟机都有自己的操作系统，并且能运行不同的应用程序，就像使用一台真实的物理机器一样。</p>
</li>
<li>
<p><strong>Process Abstraction（进程抽象）</strong></p>
<p>“进程抽象”则不同，它更关注虚拟化的粒度。在这种情况下，虚拟化提供的是进程级别的隔离，而不是虚拟一整台机器。它不再是模拟出一整台虚拟的计算机，而是提供一个隔离的、用于运行单个进程或应用的环境。这种进程级别的虚拟化通常比机器抽象更加轻量。</p>
<p>**容器（Containers）**就是一种常见的进程级别的虚拟化方式，比如Docker、Kubernetes等。与虚拟机不同，容器不需要一个完整的操作系统实例，而是共享主机的内核资源，同时每个容器运行自己的应用程序或进程。这样可以大大提高资源利用率，并减少开销，因为不需要为每个应用程序运行一个完整的操作系统。</p>
</li>
<li>
<p><strong>解释</strong></p>
<p>这句话的意思是，文章所指的虚拟化技术是以“进程抽象”为核心，而不是传统的“机器抽象”。也就是说，虚拟化硬件并不是为每个应用创建一个独立的虚拟机，而是为每个应用或进程提供一个隔离的、虚拟化的运行环境。这样的虚拟化方式更加轻量化，更接近容器化技术，比如Docker或其他类似的技术。</p>
</li>
</ol>
<p>总结来说，<strong>虚拟机技术（machine abstraction）模拟的是一整台虚拟机器</strong>，而<strong>进程级别的虚拟化（process abstraction）则是在操作系统的级别进行隔离，为单个应用提供环境</strong>。</p>
<hr>
<h2 id="虚拟化硬件可以被配置成避免为虚拟机保存和恢复某些硬件状态">虚拟化硬件可以被配置成避免为虚拟机保存和恢复某些硬件状态
</h2><p>当你运行一个虚拟机时，底层硬件（CPU、内存、I/O设备等）必须模拟或管理整个虚拟机的运行状态。这些状态包括：</p>
<ul>
<li><strong>CPU寄存器</strong>：比如通用寄存器、指令指针、栈指针等。</li>
<li><strong>内存状态</strong>：虚拟机当前使用的内存页面。</li>
<li><strong>I/O设备状态</strong>：磁盘、网络接口等外设的状态。</li>
<li><strong>其他硬件资源的状态</strong>：如中断控制器状态等。</li>
</ul>
<p>每当虚拟机从一个任务切换到另一个任务时，或者从“主机”系统切换到“客户”虚拟机时，虚拟化系统必须保存这些硬件状态，并在需要时进行恢复。这被称为<strong>上下文切换（context switch）</strong>，这是非常重要且资源密集的工作，尤其在处理虚拟机时，因为虚拟机模拟了整台计算机的硬件，所以每次切换时要保存和恢复的状态较多。</p>
<p>保存和恢复完整的硬件状态代价很高。每次切换虚拟机时，虚拟化管理程序（如Hypervisor）都需要保存虚拟机的所有硬件状态，并在切换回来时重新恢复。这会导致以下几个问题：</p>
<ul>
<li><strong>性能开销大</strong>：保存和恢复所有的硬件状态需要大量的时间和计算资源，尤其是在虚拟机数量较多时，频繁的上下文切换会导致系统性能下降。</li>
<li><strong>复杂性增加</strong>：完整的硬件状态管理非常复杂，特别是在涉及多个硬件设备和资源时。</li>
</ul>
<p>因此，避免或减少这种状态保存和恢复可以显著提高虚拟化的效率，特别是在处理较轻量级的虚拟化工作负载时，比如容器化进程（process abstraction），它们并不需要管理完整的硬件状态。</p>
<p>要避免保存和恢复虚拟机所需的多个硬件状态，虚拟化硬件和管理程序可以通过以下方式进行优化：</p>
<ul>
<li><strong>更轻量的虚拟化层次</strong>：像容器这样的进程级虚拟化不需要模拟整个操作系统和硬件，而是直接使用主机操作系统的内核，因此不需要保存和恢复大量的硬件状态。相比虚拟机，容器技术只需要隔离进程和网络等基本资源，从而减少了硬件状态的依赖。</li>
<li><strong>硬件辅助虚拟化</strong>：现代CPU架构（如Intel的VT-x和AMD的AMD-V）提供了硬件辅助虚拟化技术，允许某些硬件状态直接在CPU层面管理，减少了虚拟化管理程序需要手动保存和恢复的状态。这样做可以减少上下文切换的负担，提升性能。</li>
<li><strong>减少硬件仿真</strong>：通过简化虚拟化环境中的硬件仿真（如只提供虚拟机必要的部分硬件接口），虚拟化软件可以避免保存不必要的硬件状态，专注于管理核心资源（如CPU和内存），避免设备和外设等不常用资源的状态切换。</li>
</ul>
<p>这句话的核心意思是：通过优化虚拟化硬件配置和管理方式，可以减少或避免对某些不必要硬件状态的保存和恢复。这种优化方式尤其适用于较轻量的虚拟化场景，比如容器，而不适用于完整虚拟机的模拟。<strong>通过减少状态保存和恢复的工作量，虚拟化系统可以显著提高性能，尤其是在频繁的上下文切换中。</strong></p>
<hr>
<h2 id="vmm">VMM
</h2><p>这些段落讨论了虚拟化技术中的几个关键概念，特别是VMX（Intel的虚拟机扩展）如何管理虚拟机和虚拟机管理程序（VMM）的交互。让我逐一解释并总结这些概念。</p>
<p>VMM（Virtual Machine Monitor，虚拟机监控器）是虚拟化技术的核心部分，有时也称为<strong>Hypervisor</strong>。它的主要任务是管理虚拟机的执行，确保每个虚拟机能够独立运行，同时控制虚拟机与物理硬件的交互。</p>
<p>VMM的作用：</p>
<ul>
<li><strong>管理虚拟机的生命周期</strong>（创建、运行、暂停、销毁）。</li>
<li><strong>隔离和保护</strong>每个虚拟机的资源，防止它们互相干扰。</li>
<li><strong>控制虚拟机对硬件的访问</strong>，确保虚拟机不会直接操作底层硬件。</li>
</ul>
<p><strong>VMX Root Mode vs VMX Non-Root Mode</strong></p>
<ul>
<li><strong>VMX Root Mode</strong>：这是VMM运行的模式。虚拟化硬件在这个模式下给VMM完全控制权，可以管理虚拟机和底层物理硬件。VMM在VMX root mode下运行，并在需要管理虚拟机时切换到VMX non-root mode。</li>
<li><strong>VMX Non-Root Mode</strong>：这是虚拟机（或Guest）运行的模式。在这个模式下，虚拟机以一种“受控”的方式运行，它并不直接访问硬件，而是通过VMM的控制。虚拟机的一些操作可能会触发<strong>VM exit</strong>，将控制权交还给VMM。</li>
</ul>
<p>因此，VMX Root Mode 是<strong>VMM的运行模式</strong>，而VMX Non-Root Mode 是<strong>虚拟机的运行模式</strong>。</p>
<p><strong>这些模式与进程的关系</strong></p>
<ul>
<li>在虚拟化环境中，虚拟机（或“guest”）其实相当于一个运行在VMM控制下的“操作系统”。这不同于普通的用户进程。普通的用户进程是运行在操作系统上的程序，而<strong>虚拟机则是运行在虚拟机管理程序上的操作系统</strong>。因此，它的虚拟化级别更深，与进程并不是同一个概念。</li>
<li><strong>Guest</strong> 通常指的是<strong>虚拟机</strong>，而不是用户进程。在虚拟化环境中，guest 可能是运行在虚拟机中的一个完整的操作系统或多个进程。</li>
</ul>
<p><strong>VM entry 和 VM exit</strong></p>
<ul>
<li><strong>VM entry</strong>：当VMM执行 <code>VMLAUNCH</code> 或 <code>VMRESUME</code> 指令时，硬件会自动进行<strong>VM entry</strong>，这意味着CPU从VMX root mode切换到VMX non-root mode，开始运行虚拟机（guest）。</li>
<li><strong>VM exit</strong>：当需要VMM采取某种操作时（比如虚拟机执行了某些敏感指令），硬件会触发<strong>VM exit</strong>，将CPU从VMX non-root mode切换回VMX root mode，并跳转到VMM的入口点。</li>
</ul>
<p>在这些切换过程中，硬件自动保存和恢复大部分的<strong>架构状态</strong>，这些状态被存储在内存中的数据结构中，称为<strong>VM控制结构（VMCS）</strong>。</p>
<p><strong>VMCS 和硬件状态</strong></p>
<p>VMCS（Virtual Machine Control Structure）是一个特殊的数据结构，存储了虚拟机和VMM之间上下文切换时的状态信息。它包括：</p>
<ul>
<li>虚拟机的<strong>架构状态</strong>（如CPU寄存器等）。</li>
<li>各种配置参数，这些参数让VMM能够控制虚拟机的执行行为。</li>
</ul>
<p>通过配置VMCS，VMM可以控制哪些硬件暴露给虚拟机。例如，VMM可以配置让虚拟机执行 <code>HLT</code> 指令时触发<strong>VM exit</strong>，也可以允许虚拟机直接暂停CPU。</p>
<p><strong>虚拟内存和EPT（Extended Page Table）</strong></p>
<p>虚拟内存是虚拟化过程中最复杂的硬件特性之一。一个简单的解决方案是让虚拟机直接访问页表根寄存器（%CR3），这会给虚拟机完全的控制权，允许它配置页表来访问任意物理内存地址，甚至包括VMM自身的内存，这显然是不安全的。</p>
<p>为了解决这个问题，<strong>VT-x</strong> 提供了<strong>扩展页表（EPT）<strong>机制，它增加了一个额外的地址翻译层。EPT由VMM管理，能够确保虚拟机在访问虚拟内存时仍然受到内存隔离的约束，防止其访问不该访问的物理内存。<strong>AMD的SVM（Secure Virtual Machine）技术</strong>有类似的机制，叫做</strong>嵌套页表（NPT</strong>。</p>
<p><strong>总结</strong></p>
<ul>
<li><strong>VMM</strong> 是虚拟机监控器，管理虚拟机与物理硬件的交互。</li>
<li><strong>VMX Root Mode</strong> 是VMM运行的模式，<strong>VMX Non-Root Mode</strong> 是虚拟机运行的模式。</li>
<li><strong>VMCS</strong> 是存储虚拟机状态和配置的结构，允许VMM控制虚拟机的执行。</li>
<li><strong>虚拟内存管理</strong> 通过硬件辅助技术（如EPT/NPT）实现，确保虚拟机不能访问不该访问的物理内存。</li>
</ul>
<hr>
<h2 id="vm-entry和vm-exit"><strong>VM entry</strong>和<strong>VM exit</strong>
</h2><p>在Dune系统中，<strong>VM entry</strong>和<strong>VM exit</strong>是两个重要的过程，用来管理用户态进程和虚拟化层之间的权限切换。以下是它们分别在什么情况下执行以及一些具体的示例。</p>
<ol>
<li>
<p><strong>VM Entry：进入Dune模式</strong></p>
<p><strong>VM Entry</strong>是指从传统的用户态或内核态“进入”到Dune提供的虚拟化环境（VMX Non-Root Mode）。在这个过程中，系统会保存当前的状态并切换到Dune模式，使得用户进程可以利用Dune提供的增强权限执行特权操作。</p>
<p>VM Entry通常在用户进程需要利用Dune的增强权限操作时执行。以下是一些典型的例子：</p>
<ol>
<li>
<p><strong>进程启动</strong>：
当一个用户进程启动并被设置为运行在Dune模式下时，Dune系统会执行VM Entry，进入虚拟环境。此时，用户态进程获取到更多的硬件访问权限，如页表管理和特权指令的执行权限。</p>
<p>示例：启动一个需要直接管理内存页面的高性能计算应用，该应用在启动时经过Dune配置可以直接操作页表而无需频繁陷入内核。</p>
</li>
<li>
<p><strong>特定特权操作</strong>：
某些操作需要Dune模式下的权限才能执行，如直接访问硬件寄存器或执行特别的系统调用。此时，需要通过VM Entry进入Dune模式。</p>
<p>示例：一个用户态网络堆栈需要直接访问网络设备的寄存器以实现高效的数据包处理。为了实现这一点，在启动网络堆栈时执行VM Entry。</p>
</li>
</ol>
</li>
<li>
<p><strong>VM Exit：退出Dune模式</strong></p>
<p><strong>VM Exit</strong>是指从Dune模式“退出”到普通用户态或内核态。在这个过程中，虚拟化层会捕获某些特权操作或事件，将控制权交还给Dune的管理层或内核进行处理。</p>
<p>VM Exit通常在用户进程执行了某些特权操作或事件，这些操作不能直接在Dune模式下完成或需要更高权限的内核处理时触发。以下是一些典型的例子：</p>
<ol>
<li>
<p><strong>敏感指令执行</strong>：
当在Dune模式下执行某些受控的特权指令时，这些指令会触发VM Exit，将控制权交还给Dune的管理层或内核。</p>
<p>示例：一个用户进程试图修改某些受保护的寄存器或执行不允许的特权指令时，硬件会触发VM Exit，将控制权交回给Dune管理层处理。</p>
</li>
<li>
<p><strong>系统事件</strong>：
某些系统事件如中断、异常或I/O操作可能无法完全在用户态处理，需要内核介入，此时会触发VM Exit。</p>
<p>示例：处理I/O操作或设备中断时，由于这些操作需要内核的直接参与处理，它们会触发VM Exit，并将控制权交还给内核。</p>
</li>
<li>
<p><strong>请求Dune管理层处理</strong>：
用户进程可以显式请求退出Dune模式并交给Dune管理层处理某些操作。</p>
<p>示例：用户进程通过执行特殊指令（如<code>VMCALL</code>）主动请求退出Dune模式以便执行某些需要完整内核权限的操作。</p>
</li>
</ol>
</li>
</ol>
<p>总结</p>
<ul>
<li><strong>VM Entry</strong>是在用户进程进入Dune模式以利用虚拟化提供的增强特权时执行的，例如进程启动时需要直接操作硬件或管理内存页面。</li>
<li><strong>VM Exit</strong>是在用户进程执行特权操作或系统事件时，Dune模式需要交还控制权给管理层或内核进行处理时执行的，例如敏感指令执行、系统中断或I/O操作。</li>
</ul>
<p>通过这些机制，Dune系统能够在保证安全性的前提下大幅提升用户态进程执行特权操作的效率，同时确保必要时能够安全地退出到内核或进行更多权限的操作。</p>
<hr>
<h2 id="vm-exit将控制权交还给内核">VM Exit，将控制权交还给内核
</h2><p>VM Exit 是指从虚拟化环境（在 Dune 系统里，即 VMX Non-Root Mode）退出，将控制权交还给虚拟机监控器（VMM）或内核。这一过程涉及一系列复杂的状态切换和资源管理操作，以确保系统能正确处理和恢复。以下是这一过程中具体的变化和步骤：</p>
<ol>
<li>
<p><strong>VMX Non-Root Mode 到 VMX Root Mode 的切换</strong></p>
<ol>
<li>
<p>保存虚拟机状态。当触发 VM Exit 时，硬件会自动保存当前虚拟机（Guest）的状态到 VMCS（Virtual Machine Control Structure）。这些状态信息包括：</p>
<ul>
<li>
<p><strong>CPU 寄存器状态</strong>：通用寄存器、程序计数器、栈指针、状态寄存器等。</p>
</li>
<li>
<p><strong>控制寄存器和系统寄存器</strong>：CR0, CR3, CR4, EFER 等。</p>
</li>
<li>
<p><strong>访存相关寄存器</strong>：如 base address 寄存器。</p>
</li>
</ul>
</li>
<li>
<p>恢复 VMM 或内核的状态。随后，硬件会恢复 VM Entry 前的寄存器和状态，包括：</p>
<ul>
<li>
<p><strong>VMM 或内核的 CPU 状态</strong>：恢复至 VM Entry 时保存的状态。</p>
</li>
<li>
<p><strong>指令指针和栈指针</strong>：指向处理 VM Exit 的位置。</p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p><strong>VM Exit 的原因和处理逻辑</strong></p>
<ol>
<li>
<p>识别 VM Exit 原因。硬件会在 VMCS 中记录导致 VM Exit 的具体原因，VMM 或内核可以通过以下信息确定处理逻辑：</p>
<ul>
<li>
<p><strong>退出原因码（Exit Reason Code）</strong>：如 CPUID 指令、执行外部中断、I/O 读写等。</p>
</li>
<li>
<p><strong>退出指令信息</strong>：包括导致 VM Exit 的指令地址、指令执行上下文等。</p>
</li>
</ul>
</li>
<li>
<p>权限管理和安全检查。在恢复 VMM 或内核状态后，VMM 或内核会对 VM Exit 事件做一系列检查和权限管理。确保虚拟机未执行未授权的操作或尝试访问受保护的资源：</p>
<ul>
<li>
<p><strong>系统调用检查</strong>：确认系统调用是否合法。</p>
</li>
<li>
<p><strong>I/O 操作检查</strong>：确保不会扰乱底层硬件或操作系统状态。</p>
</li>
<li>
<p><strong>内存访问控制</strong>：通过 EPT 和页表确保虚拟机只能访问允许的地址空间。</p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p><strong>上下文切换和状态恢复</strong></p>
<ol>
<li>
<p>上下文切换。VMM 或内核需要进行上下文切换，以便处理虚拟机引发的事件。通常包括：</p>
<ul>
<li>
<p><strong>内核栈切换</strong>：切换到内核的栈空间。</p>
</li>
<li>
<p><strong>控制寄存器切换</strong>：切换控制寄存器以适应内核态或VMM的执行环境。</p>
</li>
<li>
<p><strong>内存管理单元（MMU）配置</strong>：恢复内核或 VMM 的页表状态，以便正确管理内存访问。</p>
</li>
</ul>
</li>
<li>
<p>状态恢复。在处理完 VM Exit 事件后，VMM 或内核可能需要重新进入虚拟机，继续其执行。这需要调用 VM Entry 过程：</p>
<ul>
<li>
<p><strong>恢复虚拟机状态</strong>：从 VMCS 恢复虚拟机的寄存器和控制寄存器状态。</p>
</li>
<li>
<p><strong>更新控制寄存器</strong>：CR0, CR3, CR4, EFER 等需要更新为虚拟机状态。</p>
</li>
<li>
<p><strong>重新加载内存页面映射</strong>：确保 EPT 和页表正确映射虚拟机的地址空间。</p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p><strong>事件处理和恢复执行</strong></p>
<ol>
<li>
<p>事件处理。具体的 VM Exit 事件可能涉及各种不同的处理逻辑，以下是一些常见的情况：</p>
<ul>
<li>
<p><strong>外部中断处理</strong>：内核处理硬件中断，可能涉及调度其他任务或更新系统状态。</p>
</li>
<li>
<p><strong>I/O 操作</strong>：VMM 或内核处理与存储、网络、显示等设备的交互。</p>
</li>
<li>
<p><strong>敏感指令执行</strong>：VMM 可能模拟并处理虚拟机不能直接执行的特权指令。</p>
</li>
</ul>
</li>
<li>
<p>恢复执行。完成对 VM Exit 事件的处理后，VMM 或内核可能选择回到虚拟机继续其执行。此时需要重新执行 VM Entry：</p>
<ul>
<li>
<p><strong>恢复虚拟机状态</strong>：重新加载 VMCS 中保存的虚拟机状态。</p>
</li>
<li>
<p><strong>重新进入虚拟机执行</strong>：执行 <code>VMLAUNCH</code> 或 <code>VMRESUME</code> 指令，进入 VMX Non-Root Mode，继续虚拟机程序的执行。</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>在 Dune 系统以及其他基于硬件虚拟化的系统中，<strong>VM Exit</strong> 将控制权交还给内核或 VMM 触发一系列复杂的状态保存和恢复操作。这些操作包括保存虚拟机状态、识别和处理 VM Exit 的原因、上下文切换和权限管理、以及在处理完事件后重新进入虚拟机执行。通过这些机制，Dune 可以在用户态下高效执行特权操作，同时在需要时安全地交还控制权给内核或 VMM，以确保系统的稳定和安全。</p>
<hr>
<h2 id="权限分离privilege-separation">权限分离（Privilege Separation）
</h2><p>权限分离（Privilege Separation）是一种安全技术，通过将应用程序或系统的不同部分分离开来，并为不同部分分配不同的权限，以尽量减少安全漏洞的影响。如果某一部分被攻击或被利用，只会影响该部分，而不会波及整个系统。例如，一个具有高权限的进程可以分离出一个低权限的进程来处理不信任的数据，这样即使低权限的进程被攻破，高权限的进程依然安全。</p>
<p>Sthread 是一种在 Wedge 系统中引入的轻量级进程，设计用于提供类似于操作系统进程的隔离，同时具有类似于线程的高性能。其主要用途包括：</p>
<ol>
<li><strong>隔离风险代码</strong>：将可能存在风险的代码运行在 sthread 中，以减少因漏洞攻击而带来的影响。</li>
<li><strong>用户请求隔离</strong>：在如网络服务器这类应用中，每个用户请求可以在一个单独的 sthread 中运行，保证不同用户间的隔离，防止一个用户的攻击影响其他用户。</li>
</ol>
<p>Sthread 的回收利用确实有点类似于线程池的思想。线程池技术通过预先创建一组线程，并在需要时重复使用这些线程，从而避免频繁创建和销毁线程的开销。Sthread 回收利用的原理是：</p>
<ul>
<li>在第一次创建 sthread 时，进行检查点保存。</li>
<li>当 sthread 完成任务并退出时，将其恢复到初始状态，这样在下次需要创建 sthread 时，可以直接从这个恢复的状态开始，而无需重新分配资源和初始化。
这样做减少了 sthread 创建和销毁的成本提高了系统的整体性能。</li>
</ul>
<hr>
<h2 id="sthread-回收时的脏位">sthread 回收时的脏位
</h2><p>&ldquo;脏位&rdquo;（dirty bit）是一种用于管理内存页面状态的机制，但需要明确的是，脏位本身不会直接进行内存恢复，而是作为一个标记来帮助实现恢复过程。以下是具体的工作原理：</p>
<ol>
<li><strong>脏位的作用</strong>：在内存管理中，脏位用来标识一个内存页面是否被修改过。每当一个页面被写操作修改，硬件会将该页面的脏位设为1，表示该页面已被修改。</li>
<li><strong>ssthread的回收</strong>：在ssthread回收利用过程中，我们需要将ssthread的内存恢复到其初始状态，以便重新利用。这时，脏位的状态可以帮助识别哪些页面在ssthread运行期间被修改过。</li>
<li><strong>如何实现内存恢复</strong>：
<ul>
<li><strong>初始化检查点</strong>：在ssthread第一次创建时，保存其完整的干净状态，包括所有内存页面的内容。</li>
<li><strong>运行期间标记修改</strong>：通过硬件的脏位机制，实时监控哪些页面在ssthread的执行过程中被修改。</li>
<li><strong>恢复过程</strong>：当ssthread完成任务并准备回收时，检查所有被标记为“脏”的页面，然后将这些页面恢复到初始检查点保存的状态。</li>
</ul>
</li>
</ol>
<p>通过这种方法，我们不需要每次都全面检查和恢复所有内存页面，仅需关注那些实际发生修改的页面，从而大大提高了恢复效率。</p>
<p>总结一下，脏位是一个标记，告诉系统哪些页面被修改了。它本身并不会实际“恢复”内存，而是在恢复过程中起到导引作用，使系统知道哪些页面需要恢复，大大优化了内存恢复的操作效率。</p>
<hr>
<h2 id="影子页表shadow-page-table">影子页表（Shadow Page Table）
</h2><p>影子页表（Shadow Page Table）在计算机系统特别是虚拟化环境中扮演了关键角色。它主要应用于虚拟机管理程序（Hypervisor）或者虚拟机监控器（VMM）中，用于有效地管理虚拟机的内存以及确保访客操作系统和主机操作系统之间的内存隔离与映射的效率。其地位：</p>
<ol>
<li><strong>中介角色</strong>：在虚拟化环境中，Shadow Page Table充当虚拟机的虚拟页表和宿主机的物理页表之间的中介。虚拟机运行时，每次访问内存时，都会先查找虚拟页面，然后由影子页表将其映射到宿主机的物理页面。</li>
<li><strong>高效的内存管理</strong>：通过维护影子页表，虚拟机管理程序能够有效管理和隔离不同虚拟机的内存空间，确保各虚拟机互不干扰。</li>
<li><strong>性能优化</strong>：由于影子页表可以批量管理页表更新和TLB刷新，它能显著提高虚拟机内存操作的性能，减少因频繁的页表更新导致的性能开销。</li>
</ol>
<p>影子页表由一系列的数据结构构成，这些数据结构用于保存虚拟内存地址到物理内存地址的映射信息。具体来说，影子页表通常包含以下部分：</p>
<ol>
<li><strong>页目录和页表页</strong>：包含页目录（Page Directory）和页表页（Page Table Entry）结构，用于存储虚拟到物理地址映射。</li>
<li><strong>TLB管理</strong>：涉及管理和刷新TLB（Translation Lookaside Buffer），确保在影子页表更新时，TLB中的缓存条目也能得到及时更新。</li>
<li><strong>访问控制信息</strong>：包含与访问权限和保护策略相关的信息，以确保安全性和内存隔离。</li>
</ol>
<p>假设有一个虚拟化环境，其中运行一个虚拟机，该虚拟机需要访问虚拟内存地址0xABCD1234，这个访问过程涉及以下步骤：</p>
<ol>
<li><strong>虚拟机访问</strong>：虚拟机尝试访问其虚拟地址空间中的地址0xABCD1234。</li>
<li><strong>初步映射</strong>：虚拟机内有自己的页表，假设虚拟机页表指出虚拟地址0xABCD1234映射到虚拟机的“物理”地址0x101234。</li>
<li><strong>影子页表查找</strong>：虚拟机管理程序查找影子页表，假设影子页表指示虚拟机的“物理”地址0x101234实际上映射到宿主机的物理地址0x12345678。</li>
<li><strong>物理访问</strong>：最后，虚拟机管理程序访问宿主机的物理内存地址0x12345678，从而完成虚拟地址到物理地址的转换。</li>
</ol>
<p>在这个过程中，影子页表起到了关键的桥接作用，不仅确保了虚拟机对内存的访问安全和隔离，同时也确保了内存操作的高效性。</p>
<p>影子页表在虚拟内存管理中扮演了重要的角色，提供高效、安全和隔离的内存访问手段。它有效地桥接虚拟地址和物理地址，使得虚拟机能够像访问自己的物理内存一样访问宿主机内存，从而实现无缝的内存虚拟化。</p>
<hr>
<h2 id="正课部分">正课部分
</h2><h2 id="why-virtual-machine">Why Virtual Machine
</h2><p>今天讨论的话题是虚拟机。今天的内容包含三个部分:</p>
<ul>
<li>第一个部分是Trap and Emulate，这部分会介绍如何在RISC-V或者QEMU上构建属于自己的Virtual Machine Monitor（注，有些场合也称为Hypervisor）。</li>
<li>第二部分会描述最近在硬件上对于虚拟化的支持。</li>
<li>最后是讨论一下今天的<a class="link" href="https://pdos.csail.mit.edu/6.828/2020/readings/belay-dune.pdf"  target="_blank" rel="noopener"
    >论文</a>

，它使用了第二部分中硬件上的支持。</li>
</ul>
<p>首先<strong>什么</strong>是虚拟机？你可以认为这是对于计算机的一种模拟，这种模拟足够能运行一个操作系统。</p>
<p>QEMU可以认为是虚拟机的一个例子（注，QEMU应该是属于VMM/Hypervisor）。</p>
<p>在架构的最底层，位于硬件之上存在一个Virtual Machine Monitor（VMM），它取代了标准的操作系统内核。</p>
<p>VMM的工作是模拟多个计算机用来运行Guest操作系统。</p>
<p>VMM往上一层，如果对比一个操作系统的架构应该是用户空间，但是现在是叫做Guest空间。</p>
<p>所以在今天的架构图里面，上面是Guest空间，下面是Host空间（注，也就是上面运行Guest操作系统，下面运行VMM）。</p>
<p>在Guest空间，会有一个或者多个Guest操作系统内核，或许其中一个是Linux kernel。</p>
<p>这里的Linux kernel会觉得自己就是个普通的内核，并在自己之上还运行一堆用户进程，例如VI，C Compiler。</p>
<p>我们或许还有另一个Guest运行了Windows操作系统，同时也包含了Windows用户进程。</p>
<p>所以，在Host空间运行的是VMM，在Guest空间运行的是普通的操作系统。</p>
<p>除此之外，在Guest空间又可以分为Guest Supervisor Mode，也就是Guest操作系统内核运行的模式，和Guest User Mode。</p>
<p><img src="/p/mit6s08119virtual-machines/p45.png"
	width="1146"
	height="725"
	srcset="/p/mit6s08119virtual-machines/p45_hu17269911656025490841.png 480w, /p/mit6s08119virtual-machines/p45_hu12136153197092206098.png 1024w"
	loading="lazy"
	
		alt="p45"
	
	
		class="gallery-image" 
		data-flex-grow="158"
		data-flex-basis="379px"
	
></p>
<p>VMM的主要目的是提供对计算机的模拟，这样你可以不做修改就启动普通的Linux，普通的Windows系统，并运行在虚拟机内，并且不用担心任何奇怪的事情发生。</p>
<p>所以，VMM必须要能够完全按照实际硬件的行为来模拟Guest Supervisor Mode和Guest User Mode，尽管实际上不可能完全一样，我们之后会讨论VMM对于这两种模式的模拟。</p>
<p>那么人们<strong>为什么</strong>会想要使用虚拟机呢？实际中有很多原因使得人们会在一个计算机上运行多个相互独立的操作系统。</p>
<p>在一个大公司里面，你需要大量的服务，例如DNS，Firewall等等，但是每个服务并没有使用太多的资源，所以单独为这些服务购买物理机器有点浪费，但是将这些低强度的服务以虚拟机的形式运行在一个物理机上可以节省时间和资金。</p>
<p>虚拟机在云计算中使用的也非常广泛。</p>
<p>云厂商，例如AWS，不想直接出借物理服务器给用户，因为这很难管理。它们想向用户出借的是可以随意确定不同规格的服务器。</p>
<p>或许有两个用户在一台物理服务器上，但是他们并没有太使用计算机，这样AWS可以继续向同一个物理服务器上加入第三或者第四个用户。</p>
<p>这样可以不使用额外的资金而获得更高的收益。所以，虚拟机提供了额外的灵活性，这里借助的技术是：将操作系统内核从之前的内核空间上移至用户空间，并在操作系统内核之下增加新的一层（注，也就是虚拟机的内核是运行在宿主机的用户空间，虚拟机的内核通过新增加的一层VMM来对接底层硬件）以提供这里的灵活性。</p>
<p>还有一些<strong>其他的原因</strong>会使得人们使用虚拟机。</p>
<p>第一个是开发内核，这就是为什么我们在课程中一直使用QEMU。</p>
<p>能够在虚拟环境而不是一个真实的计算机运行XV6，使得这门课程对于你们和我们来说都要方便的多。</p>
<p>同时对于调试也更容易，因为相比在物理计算机上运行XV6，在QEMU提供的虚拟机环境中运行可以更容易的提供gdb的访问权限。</p>
<p>最后一个人们使用虚拟机的原因是，通过新增的VMM提供的抽象可以实现更多的功能。</p>
<p>例如，你可以为整个操作系统和其中的用户进程做一个快照，并在磁盘中保存下来。</p>
<p>稍后再恢复快照，并将操作系统和其中的用户进程恢复成做快照时的状态。这可以增加运行的可靠性，或者用来调试，或者用来拷贝虚拟机的镜像并运行多次。</p>
<p>除此之外，还可以将一个Guest操作系统迁移到另一个计算机上。</p>
<p>如果你在一个物理计算机上运行了一个Guest操作系统，现在需要关闭并替换该物理计算机，你可以在不干扰虚拟机运行的前提下，将它迁移到另一个物理计算机，这样你就可以安全的关闭第一个物理计算机。</p>
<p>以上就是人们喜欢使用虚拟机的原因。虚拟机实际上应用的非常非常广泛，并且它也有着很长的历史。虚拟机最早出现在1960年代，经过了一段时间的开发才变得非常流行且易用。</p>
<p>对于这们课程来说，我们之所以要学习虚拟机是因为VMM提供了对于操作系统的一种<strong>不同视角</strong>。</p>
<p>在<u>操作系统的架构</u>中，内核之上提供的封装单元（注，视频中说的是container，但是container还有容器的意思，所以这里说成是封装单元）是我们熟悉的进程，内核管理的是多个用户进程。</p>
<p>而在<u>VMM的架构</u>中，VMM之上提供的封装单元是对计算机的模拟。VMM的架构使得我们可以从另一个角度重新审视我们讨论过的内容，例如内存分配，线程调度等等，这或许可以给我们一些新的思路并带回到传统的操作系统内核中。</p>
<p>所以，在虚拟机场景下，大部分的开发设计研究工作，从传统的内核移到了VMM。某种程度上来说，传统操作系统内核的内容下移了一层到了VMM。</p>
<p>今天课程的第一部分我将会讨论如何实现我们自己的虚拟机。</p>
<p>这里假设我们要模拟的是RISC-V，并运行针对RISC-V设计的操作系统，例如XV6。</p>
<p>我们的目的是让运行在Guest中的代码完全不能区分自己是运行在一个虚拟机还是物理机中，因为我们希望能在虚拟机中运行任何操作系统，甚至是你没有听说过的操作系统，这意味着对于任何操作系统的行为包括使用硬件的方式，虚拟机都必须提供提供对于硬件的完全相同的模拟，这样任何在真实硬件上能工作的代码，也同样能在虚拟机中工作。</p>
<p>除了不希望Guest能够发现自己是否运行在虚拟机中，我们也不希望Guest可以从虚拟机中逃逸。很多时候人们使用虚拟机是因为它为不被信任的软件甚至对于不被信任的操作系统提供了严格的隔离。</p>
<p>假设你是Amazon，并且你出售云服务，通常是你的客户提供了运行在虚拟机内的操作系统和应用程序，所以有可能你的客户运行的不是普通的Linux而是一个特殊的修改过的Linux，并且会试图突破虚拟机的限制来访问其他用户的虚拟机或者访问Amazon用来实现虚拟机隔离的VMM。</p>
<p>所以Guest不能从虚拟机中逃逸还挺重要的。Guest可以通过VMM使用内存，但是不能使用不属于自己的内存。类似的，Guest也不应该在没有权限的时候访问存储设备或者网卡。</p>
<p>所以这里我们会想要非常严格的隔离。</p>
<p>虚拟机在很多方面比普通的Linux进程提供了更加严格的隔离。Linux进程经常可以相互交互，它们可以杀掉别的进程，它们可以读写相同的文件，或者通过pipe进行通信。</p>
<p>但是在一个普通的虚拟机中，所有这些都不被允许。运行在同一个计算机上的不同虚拟机，彼此之间是通过VMM完全隔离的。</p>
<p>所以出于安全性考虑人们喜欢使用虚拟机，这是一种可以运行未被信任软件的方式，同时又不用担心bug和恶意攻击。</p>
<p>前面已经指出了虚拟机的目标是提供一种对于物理服务器的完全准确的模拟。但是实际中出于性能的考虑，这个目标很难达到。</p>
<p>你将会看到运行在Guest中的Linux与VMM之间会相互交互，所以实际中Linux可以发现自己是否运行在VMM之上。</p>
<p>出于效率的考虑，在VMM允许的前提下，Linux某些时候知道自己正在与VMM交互，以获得对于设备的高速访问权限。</p>
<p>但这是一种被仔细控制的例外，实现虚拟机的大致策略还是完全准确的模拟物理服务器。</p>
<hr>
<h2 id="trap-and-emulate-----trap">Trap-and-Emulate &mdash; Trap
</h2><p>我们该如何构建我们自己的VMM呢？</p>
<p>一种实现方式是完全通过软件来实现，你可以想象写一个类似QEMU的软件，这个软件读取包含了XV6内核指令的文件，查看每一条指令并模拟RISC-V的状态，这里的状态包括了通过软件模拟32个寄存器。你的软件读取每条指令，确定指令类型，再将指令应用到通过软件模拟的32个寄存器和控制寄存器中。</p>
<p>实际中有的方案就是这么做的，虽然说考虑到细节还需要做很多工作，但是这种方案从概念上来说很简单直观。</p>
<p>但是纯软件解析的虚拟机方案应用的并不广泛，因为它们很慢。</p>
<p>如果你按照这种方式实现虚拟机，那么Guest应用程序的运行速度将远低于运行在硬件上，因为你的VMM在解析每一条Guest指令的时候，都可能要转换成几十条实际的机器指令，所以这个方案中的Guest的运行速度比一个真实的计算机要慢几个数量级。</p>
<p>在云计算中，这种实现方式非常不实用。所以人们并不会通过软件解析来在生产环境中构建虚拟机。</p>
<p>相应的，一种广泛使用的策略是在真实的CPU上运行Guest指令。</p>
<p>所以如果我们要在VMM之上运行XV6，我们需要先将XV6的指令加载到内存中，之后再跳转到XV6的第一条指令，这样你的计算机硬件就能直接运行XV6的指令。当然，这要求你的计算机拥有XV6期望的处理器（注，也就是RISC-V）。</p>
<p>但是实际中你又不能直接这么做，因为当你的Guest操作系统执行了一个privileged指令（注，也就是在普通操作系统中只能在kernel mode中执行的指令，详见3.4）之后，就会出现问题。</p>
<p>现在我们在虚拟机里面运行了操作系统内核，而内核会执行需要privileged权限指令，比如说加载一个新的Page Table到RISC-V的SATP寄存器中，而这时就会出现问题。</p>
<p>前面说过，我们将Guest kernel按照一个Linux中的普通用户进程来运行，所以Guest kernel现在运行在User mode，而在User mode加载SATP寄存器是个非法的操作，这会导致我们的程序（注，也就是虚拟机）crash。</p>
<p>但是如果我们蠢到将Guest kernel运行在宿主机的Supervisor mode（注，也就是kernel mode），那么我们的Guest kernel不仅能够修改真实的Page Table，同时也可以从虚拟机中逃逸，因为它现在可以控制PTE（Page Table Entry）的内容，并且读写任意的内存内容。所以我们不能直接简单的在真实的CPU上运行Guest kernel。</p>
<p>相应的，这里会使用一些技巧。</p>
<p>首先将Guest kernel运行在宿主机的User mode，这是最基本的策略。</p>
<p>这意味着，当我们自己写了一个VMM，然后通过VMM启动了一个XV6系统，VMM会将XV6的kernel指令加载到内存的某处，再设置好合适的Page Table使得XV6看起来自己的内存是从地址0开始向高地址走。</p>
<p>之后VMM会使用trap或者sret指令（注，详见6.8）来跳转到位于User mode的Guest操作系统的第一条指令，这样不论拥有多少条指令，Guest操作系统就可以一直执行下去。</p>
<p>一旦Guest操作系统需要使用privileged指令，因为它当前运行在User mode而不是Supervisor mode，会使得它触发trap并走回到我们的VMM中（注，在一个正常操作系统中，如果在User mode执行privileged指令，会通过trap走到内核，但是现在VMM替代了内核），之后我们就可以获得控制权。</p>
<p>所以当Guest操作系统尝试修改SATP寄存器，RISC-V处理器会通过trap走回到我们的VMM中，之后我们的VMM就可以获得控制权。</p>
<p>并且我们的VMM也可以查看是什么指令引起的trap，并做适当的处理。这里核心的点在于Guest操作系统并没有实际的设置SATP寄存器。</p>
<blockquote>
<p>学生提问：VMM改如何截获Guest操作系统的指令？它应该要设置好一个trap handler对吧，但这不是一个拥有privileged权限的进程才能做的事情吗？而VMM又是个宿主机上的用户程序，是吧？</p>
<p>Robert教授：我这里假设VMM运行在Supervisor mode。所以在这里的图中，VMM就是宿主机的kernel。</p>
<p>这里我们不是启动类似Linux的操作系统，而是启动VMM（注，类似VMware的ESXi）。VMM以privileged权限运行，并拥有硬件的完整控制权限，这样我们就可以在VMM里面设置各种硬件寄存器。有一些VMM就是这么运行的，你在硬件上启动它们，并且只有VMM运行在Supervisor mode。</p>
<p>实际上还有很多很多其他的虚拟机方案，比如说在硬件上启动Linux，之后要么Linux自带一个VMM，要么通过可加载的内核模块将VMM加载至Linux内核中，这样VMM可以在Linux内核中以Supervisor mode运行。今天我们要讨论的论文就是采用后者。</p>
<p>这里主要的点在于，我们自己写的可信赖的VMM运行在Supervisor mode，而我们将不可信赖的Guest kernel运行在User mode，通过一系列的处理使得Guest kernel看起来好像自己是运行在Supervisor mode。</p>
</blockquote>
<p>在RISC-V上，如果在User mode尝试运行任何一个需要Supervisor权限的指令都会触发trap。</p>
<p>这里需要Supervisor权限的指令并不包括与Page Table相关的指令，我们稍后会介绍相关的内容。</p>
<p>所以每当Guest操作系统尝试执行类似于读取SCAUSE寄存器，读写STVEC寄存器，都会触发一个trap，并走到VMM，之后我们就可以获得控制权。</p>
<hr>
<h2 id="trap-and-emulate-----emulate">Trap-and-Emulate &mdash; Emulate
</h2><p>VMM会为每一个Guest维护一套虚拟状态信息。所以VMM里面会维护虚拟的STVEC寄存器，虚拟的SEPC寄存器以及其他所有的privileged寄存器。</p>
<p>当Guest操作系统运行指令需要读取某个privileged寄存器时，首先会通过trap走到VMM，因为在用户空间读取privileged寄存器是非法的。之后VMM会检查这条指令并发现这是一个比如说读取SEPC寄存器的指令，之后VMM会模拟这条指令，并将自己维护的虚拟SEPC寄存器，拷贝到trapframe的用户寄存器中。</p>
<blockquote>
<p>（注，有关trapframe详见Lec06，这里假设Guest操作系统通过类似“sread a0, sepc”的指令想要将spec读取到用户寄存器a0）</p>
</blockquote>
<p>之后，VMM会将trapframe中保存的用户寄存器拷贝回真正的用户寄存器，通过sret指令，使得Guest从trap中返回。</p>
<p>这时，用户寄存器a0里面保存的就是SEPC寄存器的值了，之后Guest操作系统会继续执行指令。最终，Guest读到了VMM替自己保管的虚拟SEPC寄存器。</p>
<blockquote>
<p>学生提问：VMM是怎么区分不同的Guest？</p>
<p>Robert教授：VMM会为每个Guest保存一份虚拟状态信息，然后它就像XV6知道是哪个进程一样，VMM也知道是哪个Guest通过trap走到VMM的。XV6有一个针对每个CPU的变量表明当前运行的是哪个进程，类似的VMM也有一个针对每个CPU的变量表明当前是哪个虚拟机在运行，进而查看对应的虚拟状态信息。</p>
<p>学生提问：VMM可以给一个Guest分配多个CPU核吗？</p>
<p>Robert教授：稍微复杂点的VMM都可以实现。</p>
<p>学生提问：在实际的硬件中会有对应寄存器，那么为什么我们不直接使用硬件中的寄存器，而是使用虚拟的寄存器？</p>
<p>Robert教授：这里的原因是，VMM需要使用真实的寄存器。</p>
<p>举个例子，想象一下SCAUSE寄存器，当Guest操作系统尝试做任何privileged操作时（注，也就是读写privileged寄存器），会发生trap。</p>
<p>硬件会将硬件中真实的SCAUSE寄存器设置成引起trap的原因，这里的原因是因为权限不够。</p>
<p>但是假设Guest操作系统只是从Guest用户进程执行了一个系统调用，Guest操作系统需要看到SCAUSE的值是系统调用。</p>
<p>也就是说Guest操作系统在自己的trap handler中处理来自Guest用户进程的系统调用时，需要SCAUSE的值表明是系统调用。</p>
<p>而实际的SCAUSE寄存器的值却表明是因为指令违反了privilege规则才走到的trap。通常情况下，VMM需要看到真实寄存器的值，而Guest操作系统需要能看到符合自己视角的寄存器的值。</p>
<p>（注，在Guest操作系统中，可能有两种情况会触发trap，一种是Guest用户空间进程的系统调用，也就是正常操作系统中正常的trap流程，另一种是Guest内核空间读取privileged寄存器时，因为Guest内核空间实际上也是在宿主机的用户空间，导致这是个非法操作并触发trap。Robert这边举的例子的流程应该是这样，Guest用户进程执行系统调用，在这一个瞬间SCAUSE寄存器的值是ECALL，也就是8，详见6.6。但是稍后在Guest系统内核的trap handler中需要读取SCAUSE的值，以确定在Guest中引起trap的原因，但是这就触发了第二种trap，SCAUSE的值会变成Illegal Access。我们不能让Guest系统内核看到这个值，所以VMM这里将它变成ECALL并返回。）</p>
</blockquote>
<p>在这种虚拟机的实现中，Guest整个运行在用户空间，任何时候它想要执行需要privilege权限的指令时，会通过trap走到VMM，VMM可以模拟这些指令。</p>
<p>这种实现风格叫做Trap and Emulate。</p>
<p>你可以完全通过软件实现这种VMM，也就是说你可以只通过修改软件就将XV6变成一个可以运行在RISC-V上的VMM，然后再在之上运行XV6虚拟机。当然，与常规的XV6一样，VMM需要运行在Supervisor mode。</p>
<p>所有以S开头的寄存器，也就是所有的Supervisor控制寄存器都必须保存在虚拟状态信息中。</p>
<p>同时还有一些信息并不能直接通过这些控制寄存器体现，但是又必须保存在这个虚拟状态信息中。其中一个信息就是mode。</p>
<p>VMM需要知道虚拟机是运行在Guest user mode还是Guest Supervisor mode。</p>
<p>例如，Guest中的用户代码尝试执行privileged指令，比如读取SCAUSE寄存器，这也会导致trap并走到VMM。但是这种情况下VMM不应该模拟指令并返回，因为这并不是一个User mode中的合法指令。所以VMM需要跟踪Guest当前是运行在User mode还是Supervisor mode，所以在虚拟状态信息里面也会保存mode。</p>
<p>VMM怎么知道Guest当前的mode呢？</p>
<p>当Guest从Supervisor mode返回到User mode时会执行sret指令，而sret指令又是一个privileged指令，所以会通过trap走到VMM，进而VMM可以看到Guest正在执行sret指令，并将自己维护的mode从Supervisor变到User。</p>
<p>虚拟状态信息中保存的另外一个信息是hartid，它代表了CPU核的编号。</p>
<p>即使通过privileged指令，也不能直接获取这个信息，VMM需要跟踪当前模拟的是哪个CPU。</p>
<p>实际中，在不同类型的CPU上实现Trap and Emulate虚拟机会有不同的难度。</p>
<p>不过RISC-V特别适合实现Trap and Emulate虚拟机，因为RISC-V的设计人员在设计指令集的时候就考虑了Trap and Emulate虚拟机的需求。</p>
<p>举个例子，设计人员确保了每个在Supervisor mode下才能执行的privileged指令，如果在User mode执行都会触发trap。你可以通过这种机制来确保VMM针对Guest中的每个privileged指令，都能看到一个trap。</p>
<blockquote>
<p>学生提问：Guest操作系统内核中会实际运行任何东西吗？还是说它总是会通过trap走到VMM？</p>
<p>Robert教授：如果你只是执行一个ADD指令，这条指令会直接在硬件上以硬件速度执行。如果你执行一个普通的函数调用，代码的执行也没有任何特殊的地方。所有User代码中合法的指令，以及内核代码中的non-priviledged指令，都是直接以全速在硬件上执行。</p>
<p>学生提问：在Guest操作系统中是不是也有类似的User mode和Kernel mode？</p>
<p>Robert教授：有的。Guest操作系统就是一个未被修改的普通操作系统，所以我们在Guest中运行的就是Linux内核或者XV6内核。</p>
<p>而XV6内核知道自己运行在Supervisor mode，从代码的角度来说，内核代码会认为自己运行在Supervisor mode，并执行各种privileged指令，并期望这些指令能工作。</p>
<p>当Guest操作系统执行sret指令时，它也知道自己将要进入到User空间。不过在宿主机上，Guest操作系统是运行在User mode，VMM也确保了这里能正常工作。</p>
<p>但是从Guest角度来说，自己的内核看起来像是运行在Supervisor mode，自己的用户程序看起来像是运行在User mode。</p>
</blockquote>
<p>所以，当Guest执行sret指令从Supervisor mode进入到User mode，因为sret是privileged指令，会通过trap进入到VMM。</p>
<p>VMM会更新虚拟状态信息中的mode为User mode，尽管当前的真实mode还是Supervisor mode，因为我们还在执行VMM中的代码。</p>
<p>在VMM从trap中返回之前，VMM会将真实的SEPC寄存器设置成自己保存在虚拟状态信息中的虚拟SEPC寄存器。</p>
<p>因为当VMM使用自己的sret指令返回到Guest时，它需要将真实的程序计数器设置成Guest操作系统想要的程序计数器值（注，因为稍后Guest代码会在硬件上执行，因此依赖硬件上的程序计数器）。</p>
<p>所以在一个非常短的时间内，真实的SEPC寄存器与虚拟的SEPC寄存器值是一样的。</p>
<p>同时，当VMM返回到虚拟机时，还需要切换Page table，这个我们稍后会介绍。</p>
<p>Guest中的用户代码，如果是普通的指令，就直接在硬件上执行。</p>
<p>当Guest中的用户代码需要执行系统调用时，会通过执行ECALL指令（注，详见6.3，6.4）触发trap，而这个trap会走到VMM中（注，因为ECALL也是个privileged指令）。</p>
<p>VMM可以发现当前在虚拟状态信息中记录的mode是User mode，并且发现当前执行的指令是ECALL，之后VMM会更新虚拟状态信息以模拟一个真实的系统调用的trap状态。</p>
<p>比如说，它将设置虚拟的SEPC为ECALL指令所在的程序地址（注，执行sret指令时，会将程序计数器的值设置为SEPC寄存器的值。这样，当Guest执行sret指令时，可以从虚拟的SEPC中读到正确的值）；</p>
<p>将虚拟的mode更新成Supervisor；</p>
<p>将虚拟的SCAUSE设置为系统调用；</p>
<p>将真实的SEPC设置成虚拟的STVEC寄存器；</p>
<blockquote>
<p>注，STVEC保存的是trap函数的地址，将真实的SEPC设置成STVEC这样当VMM执行sret指令返回到Guest时，可以返回到Guest的trap handler。Guest执行系统调用以为自己通过trap走到了Guest内核，但是实际上却走到了VMM，这时VMM需要做一些处理，让Guest以及之后Guest的所有privileged指令都看起来好像是Guest真的走到了Guest内核</p>
</blockquote>
<p>之后调用sret指令跳转到Guest操作系统的trap handler，也就是STVEC指向的地址。</p>
<hr>
<h2 id="trap-and-emulate-----page-table">Trap-and-Emulate &mdash; Page Table
</h2><p>有关Trap and Emulate的实现还有两个重要的部分，一个是Page Table，另一个是外部设备。</p>
<p>Page Table包含了两个部分，第一个部分是Guest操作系统在很多时候会修改SATP寄存器（注，SATP寄存器是物理内存中包含了Page Table的地址，详见4.3），当然这会变成一个trap走到VMM，之后VMM可以接管。</p>
<p>但是我们不想让VMM只是简单的替Guest设置真实的SATP寄存器，因为这样的话Guest就可以访问任意的内存地址，而不只是VMM分配给它的内存地址，所以我们不能让Guest操作系统简单的设置SATP寄存器。</p>
<p>但是我们的确又需要为SATP寄存器做点什么，因为我们需要让Guest操作系统觉得Page Table被更新了。</p>
<p>此外，当Guest上的软件运行了load或者store指令时，或者获取程序指令来执行时，我们需要数据或者指令来自于内存的正确位置，也就是Guest操作系统认为其PTE指向的内存位置。</p>
<p>所以当Guest设置SATP寄存器时，真实的过程是，我们不能直接使用Guest操作系统的Page Table，VMM会生成一个新的Page Table来模拟Guest操作系统想要的Page Table。</p>
<p>所以现在的Page Table翻译过程略微有点不一样，首先是Guest kernel包含了Page Table，但是这里是将Guest中的虚拟内存地址（注，下图中gva）映射到了Guest的物理内存地址（注，下图中gpa）。</p>
<p><img src="/p/mit6s08119virtual-machines/p46.png"
	width="1115"
	height="728"
	srcset="/p/mit6s08119virtual-machines/p46_hu5540572329762936997.png 480w, /p/mit6s08119virtual-machines/p46_hu13058415282507184088.png 1024w"
	loading="lazy"
	
		alt="p46"
	
	
		class="gallery-image" 
		data-flex-grow="153"
		data-flex-basis="367px"
	
></p>
<p>Guest物理地址是VMM分配给Guest的地址空间，例如32GB。并且VMM会告诉Guest这段内存地址从0开始，并一直上涨到32GB。</p>
<p>但是在真实硬件上，这部分内存并不是连续的。所以我们不能直接使用Guest物理地址，因为它们不对应真实的物理内存地址。</p>
<p>相应的，VMM会为每个虚拟机维护一个映射表，将Guest物理内存地址映射到真实的物理内存地址，我们称之为主机物理内存地址（注，上图中的hpa）。</p>
<p>这个映射表与Page Table类似，对于每个VMM分配给Guest的Guest物理内存Page，都有一条记录表明真实的物理内存Page是什么。</p>
<p>当Guest向SATP寄存器写了一个新的Page Table时，在对应的trap handler中，VMM会创建一个Shadow Page Table，Shadow Page Table的地址将会是VMM向真实SATP寄存器写入的值。</p>
<p>Shadow Page Table由上面两个Page Table组合而成，所以它将gva映射到了hpa。Shadow Page Table是这么构建的：</p>
<ul>
<li>从Guest Page Table中取出每一条记录，查看gpa。</li>
<li>使用VMM中的映射关系，将gpa翻译成hpa。</li>
<li>再将gva和hpa存放于Shadow Page Table。</li>
</ul>
<p>在创建完之后，VMM会将Shadow Page Table设置到真实的SATP寄存器中，再返回到Guest内核中。</p>
<blockquote>
<p>注，这样的效果是，Guest里面看到的Page Table就是一个正常的Page Table，而Guest通过SATP寄存器指向的Page Table，将虚拟内存地址翻译得到的又是真实的物理内存地址</p>
</blockquote>
<p>所以，Guest kernel认为自己使用的是一个正常的Page Table，但是实际的硬件使用的是Shadow Page Table。</p>
<p>这种方式可以阻止Guest从被允许使用的内存中逃逸。Shadow Page Table只能包含VMM分配给虚拟机的主机物理内存地址。</p>
<p>Guest不能向Page Table写入任何VMM未分配给Guest的内存地址。这是VMM实现隔离的一个关键部分。</p>
<blockquote>
<p>学生提问：如果Guest操作系统想要为一个进程创建一个新的Page Table，会发生什么呢？</p>
<p>Robert教授：Guest会完全按照Linux或者XV6的行为来执行。首先是格式化Page Table Entries以构造一个Page Table。</p>
<p>之后执行指令将Page Table的地址写入到SATP寄存器，这就是Guest操作系统的行为。</p>
<p>但是它又不能设置实际的SATP寄存器，因为这是一个privileged操作，所以设置SATP寄存器会触发trap并走到VMM。</p>
<p>VMM会查看trap对应的指令，并发现Guest要尝试设置SATP寄存器，之后VMM会创建一个新的Shadow Page Table。</p>
<p>VMM会查看Guest尝试要设置的Page Table的每一条记录，通过gpa-&gt;hpa的映射关系，将gva和hpa的对应关系翻译出来。</p>
<p>如果Guest尝试使用一个不被允许的物理地址，VMM会生成一个真实的Page Fault。之后VMM会将Shadow Page Table设置到真实的SATP寄存器中，并返回到Guest中。</p>
</blockquote>
<p>Shadow Page Table是实现VMM时一个比较麻烦的地方。</p>
<p>除了设置SATP寄存器，Guest操作系统还有另一种方式可以与Page Table进行交互。</p>
<p>XV6有时候会直接修改属于自己的Page Table Entry，或者读取PTE中的dirty bit。如果你读了RISC-V的文档，你可以发现在RISC-V上，如果软件更改了PTE，RISC-V不会做任何事情。</p>
<p>如果你修改了PTE，RISC-V并不承诺可以立即观察到对于PTE的修改，在修改那一瞬间，你完全是不知道PTE被修改了。</p>
<blockquote>
<p>注，这里主要对比的是privileged指令，因为如果在用户空间执行了privileged指令，会立刻触发trap，而这里修改PTE不会有任何的额外的动作</p>
</blockquote>
<p>相应的，文档是这么说的，如果你修改PTE并且希望MMU可以看到这个改动，你需要执行sfence.vma指令，这个指令会使得硬件注意到你对Page Table的修改。</p>
<p>所以如果你要自己写一个VMM，你在RISC-V上的VMM会完全忽略Guest对于PTE的修改，但是你知道Guest在修改完PTE之后将会执行sfence.vma指令，并且这是一个privileged指令，因为它以s开头，所以这条指令会通过trap走到VMM，VMM就可以知道sfence.vma指令被执行了。</p>
<p>之后VMM会重新扫描Guest的当前Page Table，查找更新了的Page Table Entry。</p>
<p>如果修改合法的话，VMM会将修改体现在Shadow Page Table中，并执行真实的sfence.vma指令来使得真实的硬件注意到Shadow Page Table的改动。最后再会返回到Guest操作系统中。</p>
<blockquote>
<p>学生提问：所以MMU只使用了一个Page Table，也就是Shadow Page Table，对吧？这里并没有使用EPT（Extended Page Table），对吧？</p>
<p>Robert教授：这里还没有EPT。</p>
<p>学生提问：所以Guest认为它自己有一个Page Table，也就是gva-&gt;gpa，但是这里并没有做任何的翻译工作。VMM通过两个映射关系构建了属于自己的Page Table。</p>
<p>Robert教授：是的。这里澄清一下，EPT是一种非常不一样的虚拟机实现方式，并且需要硬件的支持。我们这里假设除了对privileged指令触发trap以外，不需要使用任何特殊的硬件支持来构建一个虚拟机。</p>
<p>学生提问：这里会弄乱direct mapping吗？</p>
<p>Robert教授：这里不会有direct map。Guest会认为自己有一个direct mapping，但这只是在虚拟的世界里的一个direct mapping，在真实的机器上这不是direct mapping。但是这没有关系，因为我们这里欺骗了Guest使得看起来像是direct mapping。</p>
<p>学生提问：我们刚刚说过性能的损耗，如果我们使用VMM，对于这里的trap机制看起来也会有大量的性能损耗。</p>
<p>Robert教授：是的。如果你的操作系统执行了大量的privileged指令，那么你也会有大量的trap，这会对性能有大的损耗。</p>
<p>这里的损耗是现代硬件增加对虚拟机支持的动机。今天要讨论的论文使用的就是现在硬件对于虚拟机的支持，Intel和AMD在硬件上支持更加有效的trap，或者说对于虚拟机方案，会有少得多的trap。</p>
<p>所以是的，性能很重要。但是上面介绍的方案，人们也使用了很多年，它能工作并且也很成功，尽管它会慢的多，但是还没有慢到让人们讨厌的程度，人们其实很喜欢这个方案。</p>
</blockquote>
<hr>
<h2 id="trap-and-emulate-----devices">Trap-and-Emulate &mdash; Devices
</h2><p>接下来我们来看Trap and Emulate的最后一个部分，也就是虚拟机的外部设备。</p>
<p>外部设备是指，一个普通的操作系统期望能有一个磁盘用来存储文件系统，或者是期望有一个网卡，甚至对于XV6来说期望有一个UART设备来与console交互，或者期望有一张声卡，一个显卡，键盘鼠标等等各种各样的东西。所以我们我们的虚拟机方案，需要能够至少使得Guest认为所有它需要的外部设备是存在的。</p>
<p>这里人们通常会使用三种策略。</p>
<p>第一种是，模拟一些需要用到的并且使用非常广泛的设备，例如磁盘。</p>
<p>也就是说，Guest并不是拥有一个真正的磁盘设备，只是VMM使得与Guest交互的磁盘看起来好像真的存在一样。</p>
<p>这里的实现方式是，Guest操作系统仍然会像与真实硬件设备交互一样，通过Memory Map控制寄存器与设备进行交互。</p>
<p>通常来说，操作系统会假设硬件已经将自己的控制寄存器映射到了内核地址空间的某个地址上。</p>
<p>在VMM中不会映射这些内存地址对应的Page，相应的会将这些Page设置成无效。这样当Guest操作系统尝试使用UART或者其他硬件时，一访问这些地址就会通过trap走到VMM。</p>
<p>VMM查看指令并发现Guest正在尝试在UART发送字符或者从磁盘中读取数据。VMM中会对磁盘或者串口设备有一些模拟，通过这些模拟，VMM知道如何响应Guest的指令，之后再恢复Guest的执行。</p>
<p>这就是我们之前基于QEMU介绍XV6时，QEMU实现UART的方式。</p>
<p>在之前的介绍中，并没有UART硬件的存在，但是QEMU模拟了一个UART来使得XV6正常工作。</p>
<p>这是一种常见的实现方式，但是这种方式可能会非常的低效，因为每一次Guest与外设硬件的交互，都会触发一个trap。但是对于一些低速场景，这种方式工作的较好。如果你的目标就是能启动操作系统并使得它们完全不知道自己运行在虚拟机上，你只能使用这种策略。</p>
<p>在现代的世界中，操作系统在最底层是知道自己运行在虚拟机之上的。</p>
<p>所以第二种策略是提供虚拟设备，而不是模拟一个真实的设备。</p>
<p>通过在VMM中构建特殊的设备接口，可以使得Guest中的设备驱动与VMM内支持的设备进行高效交互。</p>
<p>现在的Guest设备驱动中可能没有Memory Mapped寄存器了，但是相应的在内存中会有一个命令队列，Guest操作系统将读写设备的命令写到队列中。</p>
<p>在XV6中也使用了一个这种方式的设备驱动，在XV6的virtio_disk.c文件中，你可以看到一个设备驱动尝试与QEMU实现的虚拟磁盘设备交互。</p>
<p>在这个驱动里面要么只使用了很少的，要么没有使用Memory Mapped寄存器，所以它基本不依赖trap，相应的它在内存中格式化了一个命令队列。</p>
<p>之后QEMU会从内存中读取这些命令，但是并不会将它们应用到磁盘中，而是将它们应用到一个文件，对于XV6来说就是fs.image。</p>
<p>这种方式比直接模拟硬件设备性能要更高，因为你可以在VMM中设计设备接口使得并不需要太多的trap。</p>
<p>第三个策略是对于真实设备的pass-through，这里典型的例子就是网卡。</p>
<p>现代的网卡具备硬件的支持，可以与VMM运行的多个Guest操作系统交互。</p>
<p>你可以配置你的网卡，使得它表现的就像多个独立的子网卡，每个Guest操作系统拥有其中一个子网卡。</p>
<p>经过VMM的配置，Guest操作系统可以直接与它在网卡上那一部分子网卡进行交互，并且效率非常的高。所以这是现代的高性能方法。</p>
<p>在这种方式中，Guest操作系统驱动可以知道它们正在与这种特别的网卡交互。</p>
<p>以上就是实现外部设备的各种策略。</p>
<p>我认为在实现一个VMM时，主要的困难就在于构建外部设备和设备驱动，并使得它们能正确的与Guest操作系统配合工作。这里或许是实现VMM的主要工作，尤其是当你使用第一种策略时。</p>
<blockquote>
<p>学生提问：我并没有太理解策略一emulation和策略二virtual device的区别。</p>
<p>Robert教授：它们是类似的。可以这么想，如果你启动了一个完全不知道虚拟机的操作系统，它或许包含了很多磁盘驱动，但是所有的驱动都是为真实硬件提供的。</p>
<p>如果你想要在虚拟机中启动这样一个操作系统，你需要选择其中一种真实的硬件，并且以一种非常准确的方式来模拟该硬件。</p>
<p>这种方式并没有问题，只是大部分情况下硬件接口并没有考虑Trap and Emulate VMM下的性能。所以真实的设备驱动需要你频繁的读写它的控制寄存器，而VMM需要为每一次写控制寄存器都获取控制权，因为它需要模拟真实的硬件。</p>
<p>这意味着每一次写控制寄存器都会触发一次trap走到VMM，并消耗数百个CPU cycles。所以策略一非常的慢且低效。</p>
<p>策略二并没有卑微地模仿真实的设备，某些设计人员提出了一种设备驱动，这种设备驱动并不对接任何真实的硬件设备，而是只对接由VMM实现的虚拟设备。</p>
<p>这种驱动设计的并不需要很多trap，并且这种驱动与对应的虚拟设备是解耦的，并不需要立即的交互。</p>
<p>从功能层面上来说，使用策略一的话，你可以启动任何操作系统，使用策略二的话，如果你想要使用虚拟设备，你只能启动知道虚拟设备的操作系统。</p>
<p>实际中，策略二是一种标准，并且很多虚拟机的实现方案都能提供。虽然我们并没有在除了QEMU以外的其他场景测试过，XV6中的virtio_disk.c稍作修改或许也可以在其他虚拟机方案上运行。</p>
<p>学生提问：所以对于每一种主板，取决于不同的磁盘，编译XV6都需要不同的磁盘驱动，是吗？</p>
<p>Robert教授：是的。我认为或许你可以买到支持virtio_disk驱动的真实硬件，但是大部分的磁盘硬件还不支持这个驱动，这时你需要为真实的硬件实现一种新的驱动。</p>
<blockquote>
<p>策略一：<strong>Emulation（设备模拟）</strong></p>
<p><strong>Emulation</strong> 的核心思想是：<strong>让虚拟机（Guest）以为它正在与一个真实的物理设备交互</strong>，即使实际情况是虚拟机管理器（VMM）在模拟这个设备。</p>
<p>工作原理：</p>
<ul>
<li>Guest 操作系统中的设备驱动程序是为真实硬件编写的，因此它期望设备具备<strong>物理设备的接口</strong>，比如内存映射的寄存器、IO 端口等。</li>
<li>VMM 需要<strong>模拟一个真实的硬件设备</strong>，包括这些设备的寄存器、控制信号、状态信息等。当 Guest 操作系统访问这些设备时，它会使用与真实设备相同的方式（例如读写寄存器、内存映射地址）进行交互。</li>
<li>VMM 拦截这些访问，并通过软件模拟真实设备的行为。比如，Guest 操作系统写入磁盘设备的控制寄存器，VMM 会模拟相应的寄存器操作，并将数据写入一个虚拟磁盘文件。</li>
</ul>
<p>设备交互：</p>
<ul>
<li>由于 VMM 拦截 Guest 操作系统对外部设备的访问，每次交互都会引发<strong>trap</strong>，从而将控制权交还给 VMM，这一过程通常很耗时，因为每个寄存器的读写都需要切换到 VMM 中进行模拟。</li>
</ul>
<p>性能问题：</p>
<ul>
<li>由于每次设备交互都需要 trap 进入 VMM 执行，<strong>trap 和 emulation</strong> 的频率很高，特别是在对设备进行大量小块数据读写时，性能会受到显著影响。这种方式适用于那些<strong>低速</strong>或不常被访问的设备（如 UART），但对于高速设备（如磁盘）效率较低。</li>
</ul>
<p>总结：</p>
<ul>
<li><strong>Emulation</strong> 适用于那些不需要虚拟化支持的操作系统，因为它们完全不需要知道自己运行在虚拟机中。通过模拟一个真实的硬件设备，VMM 可以让任何 Guest 操作系统与设备交互，几乎不需要修改操作系统的设备驱动。</li>
<li><strong>缺点</strong>是每次设备交互都需要频繁 trap，性能较差。</li>
</ul>
<hr>
<p>策略二：<strong>Virtual Devices（虚拟设备）</strong></p>
<p>虚拟设备的关键思想是：<strong>直接为虚拟机提供一组虚拟化的设备接口，而不是模拟真实硬件设备</strong>。操作系统中的设备驱动程序是专门为虚拟设备编写的，而不是为真实硬件设计的。</p>
<p>工作原理：</p>
<ul>
<li>在这种模式下，Guest 操作系统和 VMM 之间的设备交互方式是专门为虚拟环境设计的，跳过了模拟真实硬件的开销。</li>
<li>虚拟设备与 Guest 操作系统之间的交互不再依赖传统的硬件控制寄存器，而是通过<strong>共享内存</strong>或<strong>命令队列</strong>来交换数据。例如，Guest 操作系统将操作命令写入内存中的命令队列，VMM 直接读取该队列并执行相应的操作（如读写虚拟磁盘）。</li>
</ul>
<p>设备交互：</p>
<ul>
<li>由于不再需要模拟真实硬件的寄存器和控制信号，<strong>虚拟设备不依赖 trap</strong>。这种方法允许 Guest 操作系统通过高速、低延迟的方式与 VMM 中的虚拟设备交互。例如，Guest 直接将命令写入共享内存，而 VMM 通过轮询或通知机制来处理这些命令。</li>
<li>VMM 可以设计更高效的交互机制，使 Guest 操作系统与虚拟设备之间的通信更为流畅，减少了频繁 trap 带来的性能开销。</li>
</ul>
<p>性能优势：</p>
<ul>
<li>由于虚拟设备的设计不需要频繁的 trap，交互效率显著提高，尤其是对于需要快速读写的大量数据的设备（如虚拟磁盘、网卡等）。</li>
<li>这种方法通过优化内存交互，减少了 VMM 和 Guest 之间的上下文切换，从而提升了性能。</li>
</ul>
<p>总结：</p>
<ul>
<li><strong>Virtual Devices</strong> 是专为虚拟化环境设计的设备接口，只有知道虚拟化存在的操作系统才能使用它。因为虚拟设备不再试图模拟真实硬件，而是使用完全不同的接口，因此<strong>需要 Guest 操作系统的设备驱动支持这种虚拟设备</strong>。</li>
<li><strong>优点</strong>是性能较好，因为减少了 trap 的频率，交互更加高效。<strong>缺点</strong>是只能在支持虚拟设备的操作系统上运行（比如支持 virtio 的操作系统）。</li>
</ul>
<hr>
<p>策略一与策略二的主要区别</p>
<ol>
<li><strong>交互方式</strong>：
<ul>
<li>策略一模拟真实的硬件设备，Guest 操作系统按照与物理设备相同的方式进行设备交互，通过 trap 触发 VMM 进行处理。</li>
<li>策略二直接提供虚拟设备接口，Guest 操作系统通过优化的方式（如命令队列）与 VMM 进行交互，减少了 trap 频率。</li>
</ul>
</li>
<li><strong>性能</strong>：
<ul>
<li>策略一频繁的 trap 操作导致性能较差，尤其在处理高速设备时效率低下。</li>
<li>策略二通过虚拟设备设计，减少了 trap 的需求，性能显著提高。</li>
</ul>
</li>
<li><strong>操作系统的适配</strong>：
<ul>
<li>策略一对 Guest 操作系统没有特别要求，它可以运行任何不知晓虚拟化存在的操作系统，因为 VMM 模拟了物理设备。</li>
<li>策略二则需要 Guest 操作系统具备与虚拟设备兼容的驱动程序，比如 virtio 驱动。它不能伪装成真实设备，因此只有知道这些虚拟设备的操作系统才能正确与其交互。</li>
</ul>
</li>
</ol>
<p>为什么虚拟设备不能伪装成真实设备？</p>
<p>虚拟设备和真实设备之间的差异在于它们的接口方式。虚拟设备并没有尝试去<strong>完全模拟物理设备的寄存器和操作方式</strong>，而是设计了更加高效的交互机制。如果虚拟设备伪装成真实设备，等于是走回了策略一的老路，需要模拟寄存器、控制信号等，增加了 trap 的频率，导致性能下降。因此，虚拟设备选择不伪装成真实设备，而是要求操作系统通过新的接口与它们交互，从而提升性能。</p>
<hr>
<p>总结：</p>
<ul>
<li><strong>策略一：Emulation</strong> 模拟真实硬件，可以支持不知晓虚拟化的操作系统，但性能较差。</li>
<li><strong>策略二：Virtual Devices</strong> 通过新的接口设计提供更高效的交互，但需要操作系统支持虚拟设备驱动。</li>
</ul>
<blockquote>
<p>策略一：设备模拟（Emulation）</p>
<p>假设你有一个运行在虚拟机上的操作系统，这个操作系统（Guest）认为它有一个<strong>物理磁盘</strong>。Guest 操作系统上的磁盘驱动程序是为传统的硬件磁盘设计的，它会按照与物理磁盘交互的方式来访问磁盘。例如，操作系统会通过访问特定的寄存器来向磁盘发出<strong>读写命令</strong>。寄存器通常是内存映射的，操作系统通过向这些寄存器写入地址或指令来控制磁盘。</p>
<p>在设备模拟模式下（策略一），<strong>VMM</strong> 会模拟一个硬件磁盘的行为。当 Guest 操作系统试图通过这些寄存器向磁盘发出命令时，由于这些寄存器并不实际存在，VMM 会捕获这些访问（触发<strong>trap</strong>），然后通过软件来模拟磁盘设备的行为。VMM 在后台可能将 Guest 系统的读写请求映射到一个<strong>虚拟磁盘文件</strong>中（例如 QEMU 使用的 <code>.qcow2</code> 或 <code>.img</code> 文件）。所以，从 Guest 的角度看，它好像在和一个真实的磁盘设备交互，但实际上是 VMM 模拟了整个交互过程。</p>
<p><strong>例子</strong>：</p>
<ol>
<li>Guest 操作系统向磁盘寄存器写入“读取块 1000”指令。</li>
<li>这个指令触发了一个<strong>trap</strong>，进入 VMM。</li>
<li>VMM 读取了这条指令，模拟磁盘的行为，并从虚拟磁盘文件中提取块 1000 的数据。</li>
<li>VMM 返回数据，并恢复 Guest 的执行。</li>
</ol>
<p>这个过程每次需要访问寄存器都需要经过 VMM，性能较低，因为每次访问都涉及大量的 CPU 上下文切换。</p>
<hr>
<p>策略二：虚拟设备（Virtual Devices）</p>
<p>在策略二中，磁盘设备的交互方式被重新设计，Guest 操作系统并不再使用标准的硬件寄存器来访问磁盘，而是使用<strong>虚拟化的磁盘接口</strong>。最常见的虚拟设备方案是<strong>Virtio</strong>，它是为虚拟机设计的高效设备接口。</p>
<p>使用虚拟设备时，Guest 操作系统需要使用支持 Virtio 的磁盘驱动程序。这种驱动不再通过寄存器控制磁盘，而是通过<strong>共享内存中的命令队列</strong>来传递命令。VMM 和 Guest 共享一个内存区域，Guest 操作系统将所有的磁盘操作指令（例如读、写命令）写入到这个内存队列中，VMM 直接从内存中读取这些命令并处理它们。</p>
<p><strong>例子</strong>：</p>
<ol>
<li>Guest 操作系统通过 Virtio 磁盘驱动向共享内存的命令队列中写入“读取块 1000”指令。</li>
<li>VMM 监控这个队列，发现有新的读取请求。</li>
<li>VMM 直接从虚拟磁盘文件中提取块 1000 的数据，并将数据写回到共享内存中的结果缓冲区。</li>
<li>Guest 操作系统从共享内存中读取数据。</li>
</ol>
<p>由于没有频繁的 trap，VMM 不需要每次都进入内核模式来模拟设备行为，这大幅提升了性能。</p>
<hr>
<p>具体场景中的区别</p>
<p>假设你在虚拟化环境中运行一个高性能数据库服务器，这个服务器频繁地向磁盘读写数据：</p>
<ul>
<li><strong>使用设备模拟（策略一）</strong>：每次数据库服务器向磁盘发起写操作，VMM 都会模拟磁盘寄存器的访问。由于每次都需要 trap，数据库的性能会受到很大影响，尤其是磁盘 IO 操作较为频繁时，频繁的上下文切换会消耗大量 CPU 资源。</li>
<li><strong>使用虚拟设备（策略二）</strong>：Virtio 磁盘驱动通过高效的内存共享方式将读写命令发送给 VMM，VMM 直接从命令队列中读取指令，执行完命令后直接将数据写入内存。这种方式减少了大量的 trap 操作，大大提升了数据库的 IO 性能。</li>
</ul>
</blockquote>
</blockquote>
</blockquote>
<hr>
<h2 id="硬件对虚拟机的支持">硬件对虚拟机的支持
</h2><p>接下来我将讨论硬件对于虚拟机的支持，这里特指的就是Intel的VT-x。为什么Intel和其他的硬件厂商会为虚拟机提供直接的硬件支持呢？</p>
<ul>
<li>
<p>首先虚拟机应用的非常广泛，硬件厂商的大量客户都在使用虚拟机</p>
</li>
<li>
<p>其次，我们刚刚描述的Trap and Emulate虚拟机方案中，经常会涉及到大量高成本的trap，所以这种方案性能并不特别好。</p>
</li>
<li>
<p>第三个原因或许就没那么有趣了。</p>
<p>RISC-V非常适合Trap and Emulate虚拟机方案，但是Intel的x86处理器的一些具体实现使得它可以支持虚拟化，但是又没那么容易。</p>
<p>所以Intel也有动力来修复这里的问题，因为它的很多客户想要在x86上运行VMM。</p>
</li>
</ul>
<p>这里硬件上的支持，是为了让人们能够更容易地构建运行更快的虚拟机。它已经存在了10年左右了，并且现在在构建虚拟机时使用的非常非常广泛。</p>
<p>在Trap and Emulate方案中，VMM会为每个Guest在软件中保存一份虚拟状态信息，而现在，这些虚拟状态信息会保存在硬件中。</p>
<p>这样Guest中的软件可以直接执行privileged指令来修改保存在硬件中的虚拟寄存器，而不是通过trap走到VMM来修改VMM中保存在软件中的虚拟寄存器。</p>
<p>所以这里的目标是Guest可以在不触发trap的前提下，执行privileged指令。</p>
<p>我们还是有一个VMM在内核空间，并且Guest运行在用户空间。</p>
<p>当我们使用这种新的硬件支持的方案时，我们的VMM会使用真实的控制寄存器，而当VMM通知硬件切换到Guest mode时，硬件里还会有一套完全独立，专门为Guest mode下使用的虚拟控制寄存器。</p>
<p>在Guest mode下可以直接读写控制寄存器，但是读写的是寄存器保存在硬件中的拷贝，而不是真实的寄存器。</p>
<p>硬件会对Guest操作系统的行为做一些额外的操作，以确保Guest不会滥用这些寄存器并从虚拟机中逃逸。</p>
<p>在这种硬件支持的虚拟机方案中，存在一些技术术语，至少Intel是这么叫的，Guest mode被称为non-root mode，Host mode中会使用真实的寄存器，被称为root mode。</p>
<p>所以，硬件中保存的寄存器的拷贝，或者叫做虚拟寄存器是为了在non-root mode下使用，真实寄存器是为了在root mode下使用。</p>
<p>现在，当我们运行在Guest kernel时，可以在不触发任何trap的前提下执行任何privileged指令。</p>
<p>比如说如果想读写STVEC寄存器，硬件允许我们直接读写STVEC寄存器的non-root拷贝。</p>
<p>这样，privileged指令可以全速运行，而不用通过trap走到VMM。这对于需要触发大量trap的代码，可以运行的快得多。</p>
<p>现在当VMM想要创建一个新的虚拟机时，VMM需要配置硬件。</p>
<p>在VMM的内存中，通过一个结构体与VT-x硬件进行交互。这个结构体称为VMCS（注，Intel的术语，全称是Virtual Machine Control Structure）。</p>
<p>当VMM要创建一个新的虚拟机时，它会先在内存中创建这样一个结构体，并填入一些配置信息和所有寄存器的初始值，之后VMM会告诉VT-x硬件说我想要运行一个新的虚拟机，并且虚拟机的初始状态存在于VMCS中。</p>
<p>Intel通过一些新增的指令来实现这里的交互。</p>
<ul>
<li>VMLAUNCH，这条指令会创建一个新的虚拟机。你可以将一个VMCS结构体的地址作为参数传给这条指令，再开始运行Guest kernel。</li>
<li>VMRESUME。在某些时候，Guest kernel会通过trap走到VMM，然后需要VMM中需要通过执行VMRESUME指令恢复代码运行至Guest kernel。</li>
<li>VMCALL，这条新指令在non-root模式下使用，它会使得代码从non-root mode中退出，并通过trap走到VMM。</li>
</ul>
<p>通过硬件的支持，Guest现在可以在不触发trap的前提下，直接执行普通的privileged指令。</p>
<p>但是还是有一些原因需要让代码执行从Guest进入到VMM中，其中一个原因是调用VMCALL指令，另一个原因是设备中断，例如定时器中断会使得代码执行从non-root模式通过trap走到VMM。</p>
<p>所以通常情况下设备驱动还是会使得Guest通过trap走回到VMM。这表示着Guest操作系统不能持续占有CPU，每一次触发定时器中断，VMM都会获取控制权。</p>
<p>如果有多个Guest同时运行，它们可以通过定时器中断来分时共享CPU（注，类似于线程通过定时器中断分时共享CPU一样）。</p>
<p>VT-x机制中的另外一大部分是对于Page Table的支持。</p>
<p>当我们在Guest中运行操作系统时，我们仍然需要使用Page Table。</p>
<p>首先Guest kernel还是需要属于自己的Page Table，并且会想要能够加载CR3寄存器，这是Intel中类似于SATP的寄存器。VT-x使得Guest可以加载任何想要的值到CR3寄存器，进而设置Page Table。</p>
<p>而硬件也会执行Guest的这些指令，这很好，因为现在Guest kernel可以在不用通过trap走到VMM再来加载Page Table。</p>
<p>但是我们也不能让Guest任意的修改它的Page Table，因为如果这样的话，Guest就可以读写任意的内存地址。</p>
<p>所以VT-x的方案中，还存在另一个重要的寄存器：EPT（Extended Page Table）。EPT会指向一个Page Table。当VMM启动一个Guest kernel时，VMM会为Guest kernel设置好EPT，并告诉硬件这个EPT是为了即将运行的虚拟机准备的。</p>
<p>之后，当计算机上的MMU在翻译Guest的虚拟内存地址时，它会先根据Guest设置好的Page Table，将Guest虚拟地址（gva）翻译到Guest 物理地址（gha）。</p>
<p>之后再通过EPT，将Guest物理地址（gha）翻译成主机物理地址（hpa）。硬件会为每一个Guest的每一个内存地址都自动完成这里的两次翻译。EPT使得VMM可以控制Guest可以使用哪些内存地址。</p>
<p>Guest可以非常高效的设置任何想要的Page Table，因为它现在可以直接执行privileged指令。但是Guest能够使用的内存地址仍然被EPT所限制，而EPT由VMM所配置，所以Guest只能使用VMM允许其使用的物理内存Page（注，EPT类似于19.4中的Shadow Page Table）。</p>
<blockquote>
<p>学生提问：我对于硬件中保存的虚拟寄存器有问题，如果你有两个CPU核，然后你想要运行两个虚拟机，你会得到多少虚拟寄存器？</p>
<p>Robert教授：每一个CPU核都有一套独立的VT-x硬件。</p>
<p>所以每一个CPU核都有属于自己的32个通用寄存器，属于自己的真实的控制寄存器，属于自己的用在Guest mode下的虚拟控制寄存器，属于自己的EPT，所以你可以在两个CPU核上运行两个不同的虚拟机，它们不会共用任何寄存器，每个CPU核都有属于自己的寄存器。</p>
<p>学生提问：那也需要一个新的VMM吗？</p>
<p>Robert教授：VMM可以像一个普通的操作系统一样。XV6可以支持多个进程，并且为每个进程配备一个proc结构体。</p>
<p>而我们的VMM也会为每个虚拟机配备一个vm结构体，用来跟踪Guest的信息。</p>
<p>并且，如我之前所说的，如果你只有一个CPU核，但是有3个Guest，可以通过定时器中断结合VMM在3个Guest之间切换。</p>
</blockquote>
<hr>
<h2 id="dune-safe-user-level-access-to-privileged-cpu-features">Dune: Safe User-level Access to Privileged CPU Features
</h2><p>今天要讨论的<a class="link" href="https://pdos.csail.mit.edu/6.828/2020/readings/belay-dune.pdf"  target="_blank" rel="noopener"
    >论文</a>

利用了上一节介绍的硬件对于虚拟机的支持，但是却将其用作其他的用途，这是这篇论文的有趣之处，它利用了这种完全是为了虚拟机而设计的硬件，但是却用来做一些与虚拟机完全无关的事情。</p>
<p>从一个全局的视角来看这篇论文的内容，它想要实现的是普通的进程。</p>
<p>所以现在我们的场景是在一个Linux而不是VMM中，但是我们又用到了硬件中的VT-x。</p>
<p>我们将会在Linux中加载Dune可加载模块，所以Dune作为kernel的一部分运行在Supervisor mode（注，又或者叫做kernel mode），除此之外，内核的大部分还是原本的Linux。</p>
<p>因为这里运行的是Linux进程，所以我们期望Dune可以支持进程，以及包括系统调用在内的各种Linux进程可以做的事情。</p>
<p>不过现在我们想要使用VT-x硬件来使得普通的Linux进程可以做一些额外的事情。</p>
<p>Dune会运行一些进程，或者说允许一个进程切换到Dune模式，这意味着，之前的进程只是被Page Table保护和隔离，现在这个进程完全被VT-x机制隔离开了。</p>
<p>现在进程有了一套完整的虚拟控制寄存器，例如CR3寄存器，并且这些进程可以运行在non-root Supervisor mode，所以它可以在VT-x管理的虚拟状态信息上直接执行所有的privileged指令。</p>
<p>基于上面的描述，Dune管理的进程可以通过属于自己的CR3寄存器，设置好属于自己的Page Table。</p>
<p>当然Dune也会控制属于这个进程的EPT，EPT会被设置的只包含这个进程相关的内存Page。</p>
<p>所以进程可以向CR3寄存器写入任意的Page Table地址，但是因为MMU会在翻译完正常的Page Table之后再将地址送到EPT去翻译，所以进程不能从分配给它的内存中逃逸。</p>
<p>所以进程并不能修改其他进程或者kernel的内存，它只是有了一种更灵活的设置自己内存的方式。</p>
<p>Dune管理的进程也可以拥有Guest Supervisor mode和Guest User mode，就像一个小的虚拟机一样，并且可以保护运行在Supervisor mode的代码，不受运行在User mode的代码影响。</p>
<p>论文中提到了可以基于Dune做的两件事情：</p>
<p>首先，Dune能够在硬件层面支持进程同时拥有Guest Supervisor mode和Guest User mode，这样进程可以在自己的User mode中运行未被信任的插件代码。</p>
<p>这里的主进程或许是一个网页浏览器，你可以为浏览器下载并运行各种各样的插件，或许是一个新的视频解码器，一个新的广告拦截插件等等。</p>
<p>但是我们并不能完全信任这个插件，所以我们希望能够在权限受控的前提下运行它。虽然一个普通的Linux也可以达到这个目的，但是会比较麻烦。</p>
<p>通过Dune，我们可以在Guest User mode下运行插件，同时让网页浏览器运行在进程的Guest Supervisor mode下。因为现在可以修改CR3寄存器，所以可以为Guest User mode配置一个不同的Page Table。</p>
<p>这样，即使插件是恶意的，进程也可以安全的运行这里的未被信任的插件代码，因为插件代码现在不能任意的读写主浏览器的内存，只能访问网页浏览器指定的某些内存Page。</p>
<p>进程的Guest User代码可能会执行系统调用，但是这些系统调用会通过trap走到进程的Guest Supervisor mode，而不是Linux内核，所以这里的插件代码或许会认为自己调用了fork/read/write等系统调用，但是实际上这里尝试运行的系统调用通过trap走到了进程对应的网页浏览器，而网页浏览器可以做任意的事情，它可以选择执行或者不执行系统调用。</p>
<p>所以现在网页浏览器对于插件代码有了完全的控制能力。</p>
<p>公平的说，这里提到的隔离效果可以通过Linux中一些非常不一样的技术来实现，但是Dune通过使用VT-x硬件，为你可以提供一个特别优雅且有效的实现方式。</p>
<p>进程可以做的另一个事情是：通过Dune，进程的垃圾回收（Garbage Collect，GC）变得更快了。</p>
<p>在这个场景中，没有了Guest Supervisor mode和Guest User mode。</p>
<p>假设我们在运行任意一种带有GC的编程语言，比如说Java或者Python。</p>
<p>GC可能会很慢，并且本身有着非常非常多的技术可以使得GC变快。许多GC都会扫描并找到位于内存中仍然在使用的对象，扫描会从寄存器中保存的对象指针开始，依次找到所有正在使用对象的所有指针。</p>
<p>如果在扫描之后没能找到某个对象，那说明这个对象不被任何指针引用，那么它就可以被释放了。</p>
<p>许多GC会同时在主程序的一个线程中运行，所以GC会从寄存器中保存的指针开始，根据指针之间的树或者图的关系，扫描一个个的对象。</p>
<p>但是因为GC与程序本身是并行的在运行，所以程序可能会修改GC已经扫描过的对象，这很糟糕，因为这样的话，GC在扫描完成之后确定的要释放和不能释放的对象清单可能就不再正确了。</p>
<p>Dune使用了Page Table Entry中的一个特性来帮助GC检测这样的修改。</p>
<p>Dune管理的进程首先会设置好由VT-x提供的虚拟CR3寄存器，指向属于自己的Page Table，其中的PTE都是有效的。</p>
<p>每一条PTE的dirty位，表明对于对应的Page存在写操作。所以如果程序在GC的过程中修改了某些对象，那么对应PTE的dirty位会被设置为1。</p>
<p>当GC查找完所有的对象之后，它会查看所有PTE中的dirty位，找到包含了可能修改过的对象的内存Page，然后再重新扫描这些对象。</p>
<p>实际中，获取PTE dirty位的过程在普通的Linux中既困难又慢，我甚至都不确定Linux是否支持这个操作，在一些其他操作系统中你可以通过系统调用来查询PTE的dirty位。</p>
<p>但是如果你使用Dune和 VT-x，进程可以很快的使用普通的load和store指令获取PTE，进而获取dirty位。所以这里，Dune使得某些需要频繁触发GC的程序明显变得更快。</p>
<hr>
<blockquote>
<p>学生提问：如果Guest User mode中的插件程序想要运行自己的GC会怎样？</p>
<p>Robert教授：现在我们使用了Dune，并且有一个进程是被Dune管理的。</p>
<p>这个进程通过VT-x实现了Supervisor mode和User mode，我们在User mode运行了一个插件，并且插件也是由带GC的编程语言写的，所以它有属于自己的Page Table，并且其中的PTE也包含了dirty位。</p>
<p>但是刚刚说的GC加速在这不能工作，因为Dune会将插件运行在Guest User mode，而就像普通的User mode一样，Guest User mode不允许使用CR3寄存器。</p>
<p>所以在Guest User mode，我们不能快速的访问PTE的dirty位。只有在Guest Supervisor mode，才能通过CR3寄存器访问Page Table。所以，并不能同时使用以上Dune提供的两种功能。</p>
</blockquote>
<hr>
<blockquote>
<p>学生提问：如果某人基于Dune写了个浏览器，那么对于不支持Dune的计算机来说就很难使用这样的浏览器，对吗？就像很难直接让Chrome使用Dune，因为不是所有的计算机都有这个内核模块。</p>
<p>Robert教授：首先，这里提到的内容需要运行在支持VT-x的计算机上，也就是说底层的计算机必须支持VT-x，所以需要VT-x来运行Dune。</p>
<p>其次Dune需要被加载来运行浏览器以利用前面说到的特性。</p>
<p>所以是的，你需要将所有的东西都设置好。并且Dune是一个研究项目，它的目标是使得人们去思考可以部署在真实世界，并且有足够的价值的一些东西。</p>
<p>就像Linux一样，Linux有成千上万个功能，如果某人决定将Dune添加到Linux中作为一个标准功能，那么我们就可以依赖这个功能，并且Chrome也可以直接用它了。</p>
</blockquote>
<hr>
<blockquote>
<p>学生提问：所以从整体来看，这里就像是创建了一个VM，但是实际上运行的又是一个进程？</p>
<p>Robert教授：你可以这么描述。这里主要是对进程进行抽象，但是这里没有用Page Table硬件来时先进程间的隔离（注，其实也使用了，但是主要不依赖Page Table硬件），这里使用的是CPU上的硬件来支持进程，这里说的CPU上的硬件就是VT-x，它包含了一些额外的功能，例如设置好属于进程的Page Table。</p>
</blockquote>
<hr>
<blockquote>
<p>学生提问：论文里提到了，如果Dune管理的一个进程fork了，那就会变成一个不被Dune管理的进程，这不会是一个安全漏洞吗？</p>
<p>比如说你通过Dune运行了一个进程，并且认为它现在是安全的。但是fork之后的进程因为不被管理所以可能会逃逸。</p>
<p>Robert教授：Dune管理的进程的Guest Supervisor mode中，不存在安全的问题。这部分代码已经拥有了相应的权限，通过fork也不会获得更多的权限。</p>
<p>但是另一方面，Dune的Guest User mode代码中，我们有未被信任的代码，如果让它在没有Dune管理的情况下运行会有一定的风险。</p>
<p>所以这部分代码不能fork，如果它尝试执行fork系统调用，会通过trap走到进程的Guest Supervisor mode。</p>
<p>假设进程的Guest Supervisor mode部分代码写的非常的小心，并且不会被欺骗，那么它不会执行fork，所以这时fork不能工作。</p>
<p>如果Supervisor mode的代码允许fork，它会调用Linux的fork系统调用，并得到一个fork进程包含了与原进程有相同的内存镜像，所以我们在新进程中包含可能是恶意的插件代码。</p>
<p>如果新进程没有意识到Dune已经被关闭了，那么原来的Supervisor mode中的privileged指令会是非法的。</p>
<p>所以我们需要假设Dune管理的进程里面的Supervisor mode部分代码能够足够的小心且足够的聪明，来阻止User mode中的插件代码执行fork。</p>
</blockquote>
<hr>
<blockquote>
<p>学生：被Dune管理的进程拥有Supervisor mode并没有不安全，因为它实际上是non-root mode下的Supervisor mode，就像是Guest操作系统中的Supervisor mode一样，你可以让它做任何事情，因为VT-x的存在，进程就像是一个虚拟机一样，并不能伤害到真正的操作系统。</p>
<p>Robert教授：是的，进程不能逃逸出来，因为存在EPT，而EPT会限制进程的地址空间。</p>
</blockquote>
<hr>
<blockquote>
<p>学生提问：在VT-x的方案中，当我们访问Page Table时，因为我们需要通过EPT进行第二层翻译，将Guest物理内存地址翻译到Host物理内存地址，这样从Page Table返回的延时是不是增加了？</p>
<p>Robert教授：这里可能会花费更多的时间让硬件MMU来翻译内存地址。</p>
<p>在最坏的情况下，比如在RISC-V中，会有多层Page Table，MMU需要一层一层的去查找PTE，x86下同样也有多层Page Table，所以在x86中首先会查找主Page Table，如果要访问更多的内存地址，每一次内存地址的访问都需要再次走到EPT，而EPT也是一个多层的Page Table。</p>
<p>所以我并不知道最差情况下需要访问Page Table多少次才能完成翻译，但是很明显在VT-x下会比普通情况下差得多。不过实际中会有cache所以通常不会走到最坏的情况。</p>
</blockquote>
<hr>
<blockquote>
<p>学生提问：今天的虚拟机还是普遍会更慢吗？如果是的话，AWS是怎么工作的，因为看起来还挺快的，并且工作的也很好。</p>
<p>Robert教授：我认为他们使用了硬件上的VT-x支持，并且使用了我们讨论过的一些功能，这样使得AWS虚拟机比较快，或者并不比真实的计算机慢多少。</p>
</blockquote>
<hr>
<blockquote>
<p>学生提问：我对于Trap and Emulate中的Shadow Page Table有个问题，每次都会创建Shadow Page Table吗？难道不能记住上次的Shadow Page Table吗？</p>
<p>Robert教授：VMM需要创建新的Shadow Page Table以供真实的硬件使用。当然在很多时候都可以增加缓存，对于一个聪明的VMM，它可以注意到Guest更新了一个PTE，VMM可以做相应的有限的工作来更新Shadow Page Table。</p>
<p>如果机器是在多个虚拟机上分时复用的，VMM会为还在运行的虚拟机保存Shadow Page Table，这样这些虚拟机可以在恢复时直接重用。</p>
<p>学生提问：这难道不是意味着VMM为每个虚拟机中的每个进程都保存了Shadow Page Table的拷贝？</p>
<p>Robert教授：是的，虚拟机里面有很多很多个Page Table，所以维护Shadow Page Table需要大量的工作。</p>
<p>而类似于VT-x的硬件支持使得这部分工作更加的容易了，因为EPT表示你不用构建Shadow Page Table了。</p>
<p>学生提问：我有个问题有关GC的，如果有dirty位的话需要重新扫描对象，那么有没有可能会无限扫描？</p>
<p>Robert教授：是的，这有个问题，如果一直有对象在更新，扫描能正常结束吗？</p>
<p>实际中，GC会先扫描一次，之后它会冻结除了GC线程以外的其他线程，所以这期间不可能再发生任何其他的变更。之后GC才会查看所有PTE的dirty位，但是因为其他所有线程都冻结了，所以不可能会有更多的dirty位了，所以GC查看了所有的dirty位，之后结束GC会结束扫描并创建需要释放对象的列表，最后再恢复所有之前冻结的线程的执行。GC是一个复杂的流程，Dune的论文中并没有足够的篇幅讨论它。</p>
</blockquote>

</section>


    <footer class="article-footer">
    

    <section class="article-lastmod">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <span>
            最后更新于 Nov 12, 2024 23:05 &#43;0800
        </span>
    </section></footer>




    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI&#43;WdtXRGWt2kTvGFasHpSy3SV"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG&#43;vnGctmUb0ZY0l8"crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05"crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.body, {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>
    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="has-image">
    <a href="/p/mit6s08123rcu/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08123rcu/bg.91a08bf3fe0a8ca435e8fbc902291fd5_hu4589796922609635382.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：23RCU"
                        
                        data-hash="md5-kaCL8/4KjKQ16PvJAikf1Q==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：23RCU</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/mit6s08122meltdown/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08122meltdown/19.8d880549dccba2f0c1613b3e41a721e5_hu3753156070077914420.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：22Meltdown"
                        
                        data-hash="md5-jYgFSdzLovDBYTs&#43;Qach5Q==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：22Meltdown</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/mit6s08121networking/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08121networking/bg.68c4376fd87b0b35da07319dd155c90d_hu10351534106733688476.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：21Networking"
                        
                        data-hash="md5-aMQ3b9h7CzXaBzGd0VXJDQ==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：21Networking</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/mit6s08120kernels-and-hll/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08120kernels-and-hll/bg.4175e6a2793e0fc340e5aced2529e40b_hu6405785273338381617.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：20Kernels and HLL"
                        
                        data-hash="md5-QXXmonk&#43;D8NA5aztJSnkCw==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：20Kernels and HLL</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/mit6s08118os-organization/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08118os-organization/bg.6254618fb3eb08f3bf5d7cd89d4cd672_hu15449325963333300792.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：18OS organization"
                        
                        data-hash="md5-YlRhj7PrCPO/XXzYnUzWcg==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：18OS organization</h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    

    <footer class="site-footer">

    <section class="copyright">
        &copy; 
        
        2024 echudet
    </section>
    
    <section class="powerby">
        


        <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>

        <script language="javascript"> 
            var now = new Date();
            function createtime(){
                now.setTime(now.getTime()+250);
                var grt= new Date("2024/11/10 00:00:00"); 
                days = (now - grt ) / 1000 / 60 / 60 / 24;
                dnum = Math.floor(days);
                hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
                hnum = Math.floor(hours);
                if(String(hnum).length ==1 ){hnum = "0" + hnum;}
                minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
                mnum = Math.floor(minutes);
                if(String(mnum).length ==1 ){mnum = "0" + mnum;}
                seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
                snum = Math.round(seconds);
                if(String(snum).length ==1 ){snum = "0" + snum;}

                document.getElementById("timeDate").innerHTML = "本站已稳定运行"+dnum+" 天 ";
                document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒<br>"
            }
            setInterval("createtime()",250); 
        </script> 

        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        
    
        
         
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
        

        共 653674 字 , 30 篇文章<br>使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.29.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>

</footer>



    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>


    </body>
</html>
