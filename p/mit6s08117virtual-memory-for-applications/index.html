<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="虚拟内存在操作系统中扮演着重要角色，通过抽象物理内存的复杂性为每个进程提供一个统一、隔离的地址空间。这一机制允许程序运行时拥有自己的内存视图，确保不会相互干扰，提升了系统的稳定性与安全性。虚拟内存将物理内存和磁盘空间结合，允许系统运行比实际物理内存更大的程序。通过分页或分段等技术，操作系统能够在后台进行内存和存储之间的智能管理，使用页面置换算法来优化性能，保证多任务处理的高效性。这个机制不仅提高了内存利用率，还使得程序开发更为高效，因为开发者无需处理内存分配的复杂细节。">
<title>MIT6S081：17Virtual memory for applications</title>

<link rel='canonical' href='https://echudet.github.io/p/mit6s08117virtual-memory-for-applications/'>

<link rel="stylesheet" href="/scss/style.min.86fc5e5efb829fb1bdd7a2d2275017fb3ae01ba7fcf491e347d76495ae5e3ae2.css"><meta property='og:title' content="MIT6S081：17Virtual memory for applications">
<meta property='og:description' content="虚拟内存在操作系统中扮演着重要角色，通过抽象物理内存的复杂性为每个进程提供一个统一、隔离的地址空间。这一机制允许程序运行时拥有自己的内存视图，确保不会相互干扰，提升了系统的稳定性与安全性。虚拟内存将物理内存和磁盘空间结合，允许系统运行比实际物理内存更大的程序。通过分页或分段等技术，操作系统能够在后台进行内存和存储之间的智能管理，使用页面置换算法来优化性能，保证多任务处理的高效性。这个机制不仅提高了内存利用率，还使得程序开发更为高效，因为开发者无需处理内存分配的复杂细节。">
<meta property='og:url' content='https://echudet.github.io/p/mit6s08117virtual-memory-for-applications/'>
<meta property='og:site_name' content='echudet'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2024-10-02T22:02:50&#43;08:00'/><meta property='article:modified_time' content='2024-11-13T17:04:51&#43;08:00'/><meta property='og:image' content='https://echudet.github.io/p/mit6s08117virtual-memory-for-applications/bg.png' />
<meta name="twitter:title" content="MIT6S081：17Virtual memory for applications">
<meta name="twitter:description" content="虚拟内存在操作系统中扮演着重要角色，通过抽象物理内存的复杂性为每个进程提供一个统一、隔离的地址空间。这一机制允许程序运行时拥有自己的内存视图，确保不会相互干扰，提升了系统的稳定性与安全性。虚拟内存将物理内存和磁盘空间结合，允许系统运行比实际物理内存更大的程序。通过分页或分段等技术，操作系统能够在后台进行内存和存储之间的智能管理，使用页面置换算法来优化性能，保证多任务处理的高效性。这个机制不仅提高了内存利用率，还使得程序开发更为高效，因为开发者无需处理内存分配的复杂细节。"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://echudet.github.io/p/mit6s08117virtual-memory-for-applications/bg.png' />
    <link rel="shortcut icon" href="/timer.ico" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu11199958555974308744.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">⌨️</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">echudet</a></h1>
            <h2 class="site-description">探索编程的学生一枚</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/EchudeT'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://twitter.com'
                        target="_blank"
                        title="Twitter"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>档案</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>Links</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#课前预习">课前预习</a></li>
    <li><a href="#论文速览">论文速览</a></li>
    <li><a href="#generational-garbage-collection分代垃圾回收"><strong>Generational Garbage Collection（分代垃圾回收）</strong></a></li>
    <li><a href="#persistent-stores持久存储">Persistent stores(持久存储)</a></li>
    <li><a href="#extending-addressability">Extending addressability</a></li>
    <li><a href="#extending-addressability翻译表">Extending addressability翻译表</a></li>
    <li><a href="#data-compression-paging">Data-compression paging</a></li>
    <li><a href="#heap-overflow-detection">Heap overflow detection</a></li>
    <li><a href="#vm-primitive-performance">VM primitive performance</a></li>
    <li><a href="#tlb的回顾">TLB的回顾</a></li>
    <li><a href="#tlb-consistency">TLB Consistency</a></li>
    <li><a href="#optimal-page-size">Optimal page size</a></li>
    <li><a href="#access-to-protected-pages">Access to protected pages</a></li>
    <li><a href="#is-this-too-much-to-ask">Is this too much to ask?</a></li>
    <li><a href="#heap-overflow-detection-and-other-algorithms">heap overflow detection and other algorithms</a></li>
    <li><a href="#正课">正课</a></li>
    <li><a href="#应用程序使用虚拟内存所需要的特性">应用程序使用虚拟内存所需要的特性</a></li>
    <li><a href="#支持应用程序使用虚拟内存的系统调用">支持应用程序使用虚拟内存的系统调用</a>
      <ol>
        <li><a href="#mmap的系统调用">mmap的系统调用</a></li>
        <li><a href="#mprotect系统调用">mprotect系统调用</a></li>
        <li><a href="#munmap">munmap</a></li>
        <li><a href="#sigaction">sigaction</a></li>
        <li><a href="#虚拟内存特性">虚拟内存特性</a></li>
      </ol>
    </li>
    <li><a href="#虚拟内存系统如何支持用户应用程序">虚拟内存系统如何支持用户应用程序</a></li>
    <li><a href="#构建大的缓存表">构建大的缓存表</a></li>
    <li><a href="#bakers-real-time-copying-garbage-collector">Baker&rsquo;s Real-Time Copying Garbage Collector</a></li>
    <li><a href="#使用虚拟内存特性的gc">使用虚拟内存特性的GC</a></li>
    <li><a href="#使用虚拟内存特性的gc代码展示">使用虚拟内存特性的GC代码展示</a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/mit6s08117virtual-memory-for-applications/">
                <img src="/p/mit6s08117virtual-memory-for-applications/bg_hu13659540609009056379.png"
                        srcset="/p/mit6s08117virtual-memory-for-applications/bg_hu13659540609009056379.png 800w, /p/mit6s08117virtual-memory-for-applications/bg_hu16658861918845069526.png 1600w"
                        width="800" 
                        height="500" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：17Virtual memory for applications" />
                
            </a>
        </div>
    

    <div class="article-details">


    
    <header class="article-category">
        
            <a href="/categories/mit6s081/" >
                Mit6s081
            </a>
        
            <a href="/categories/os/" >
                Os
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/mit6s08117virtual-memory-for-applications/">MIT6S081：17Virtual memory for applications</a>
        </h2>
    
        
        <h3 class="article-subtitle">
            虚拟内存在操作系统中扮演着重要角色，通过抽象物理内存的复杂性为每个进程提供一个统一、隔离的地址空间。这一机制允许程序运行时拥有自己的内存视图，确保不会相互干扰，提升了系统的稳定性与安全性。虚拟内存将物理内存和磁盘空间结合，允许系统运行比实际物理内存更大的程序。通过分页或分段等技术，操作系统能够在后台进行内存和存储之间的智能管理，使用页面置换算法来优化性能，保证多任务处理的高效性。这个机制不仅提高了内存利用率，还使得程序开发更为高效，因为开发者无需处理内存分配的复杂细节。
        </h3>
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2024-10-02</time>
            </div>
        

        
            <div>
                <?xml version="1.0" encoding="iso-8859-1"?>
<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="792px" height="792px" viewBox="0 0 792 792" style="enable-background:new 0 0 792 792;" xml:space="preserve">
<g>
	<g id="_x31_0_19_">
		<g>
			<path d="M643.5,742.5H594V569.25C594,473.566,516.434,396,420.75,396C516.434,396,594,318.434,594,222.75V49.5h49.5
				c13.662,0,24.75-11.088,24.75-24.75S657.162,0,643.5,0h-495c-13.662,0-24.75,11.088-24.75,24.75S134.838,49.5,148.5,49.5H198
				v173.25C198,318.434,275.566,396,371.25,396C275.566,396,198,473.566,198,569.25V742.5h-49.5c-13.662,0-24.75,11.088-24.75,24.75
				S134.838,792,148.5,792h495c13.662,0,24.75-11.088,24.75-24.75S657.162,742.5,643.5,742.5z M247.5,222.75
				c0-43.387,0-173.25,0-173.25h297c0,0,0,133.427,0,173.25c0,68.335-58.188,123.75-129.938,123.75h-37.125
				C305.687,346.5,247.5,291.085,247.5,222.75z M544.5,742.5h-297c0,0,0-129.888,0-173.25c0-68.335,58.187-123.75,129.938-123.75
				h37.125c71.75,0,129.938,55.415,129.938,123.75C544.5,609.072,544.5,742.5,544.5,742.5z"/>
		</g>
	</g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
</svg>

                <time class="article-time--reading">
                    阅读时长: 73 分钟
                </time>
            </div>
        

         
        <div>
            <?xml version="1.0" encoding="iso-8859-1"?>
<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="79.536px" height="79.536px" viewBox="0 0 79.536 79.536" style="enable-background:new 0 0 79.536 79.536;"
	 xml:space="preserve">
<g>
	<path style="fill:#010002;" d="M40.162,17.906C37.415,15.275,21.614,6.141,0,15.451c0,0.138,0,2.722,0,6.654v44.418h32.747
		c1.126,0.968,3.798,1.651,6.926,1.651c3.119,0,5.802-0.684,6.931-1.651h32.933V22.105c0-3.933,0-6.517,0-6.654
		C58.813,6.314,42.257,15.982,40.162,17.906z M37.229,63.349c0-1.75-15.372-11.981-33.125-0.818V19.216
		c3.516-2.014,8.246-3.249,13.463-3.249c10.864,0,19.662,3.562,19.662,10.175V63.349z M75.684,62.53
		c-17.751-11.163-33.108-0.932-33.108,0.818V26.146c0-6.612,8.792-10.175,19.646-10.175c5.22,0,9.952,1.235,13.463,3.249V62.53z"/>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
</svg>

            <time class="article-words">
                文章字数：36078字
            </time>
        </div>
        <div class="article-lastmod">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time>
                    Nov 13, 2024 17:04 &#43;0800
                </time>
            </div></footer>
    

    




    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="lecture-17-virtual-memory-for-applications">Lecture 17 Virtual memory for applications
</h1><h2 id="课前预习">课前预习
</h2><h2 id="论文速览">论文速览
</h2><p>在<strong>简介</strong>部分提到，论文的核心讨论点是：虚拟内存（Virtual Memory）不仅仅可以用来扩展操作系统的地址空间，还能用于很多其他的目的，例如内存共享、写时复制（copy-on-write）以及处理保护违规。作者探讨了操作系统应提供给用户程序的虚拟内存基本原语，特别是这些原语如何支持不同的用户级应用。</p>
<p>在<strong>虚拟内存原语</strong>部分提到，论文中提到的关键虚拟内存操作包括：</p>
<ul>
<li><strong>trap：</strong> 处理用户模式下的页故障。</li>
<li><strong>prot1 &amp; protN：</strong> 降低单页或多页的访问权限。</li>
<li><strong>unprot：</strong> 增加页面的访问权限。</li>
<li><strong>dirty：</strong> 返回自上次检查以来被修改的页面列表。</li>
<li><strong>map2：</strong> 将同一个物理页面映射到不同的虚拟地址。</li>
</ul>
<p>这些原语旨在支持中粒度的同步操作和多处理器系统上的高效内存管理。</p>
<p>在<strong>虚拟内存应用</strong>部分，论文展示了多种利用虚拟内存原语的应用，包括：</p>
<ul>
<li><strong>并发垃圾回收：</strong> 通过页面保护技术检测未扫描的对象，以实现垃圾收集器与程序的同步。</li>
<li><strong>共享虚拟内存：</strong> 在多计算机网络上实现页面级别的内存一致性。</li>
<li><strong>并发检查点保存：</strong> 通过设置页面为只读，允许程序在不间断的情况下进行内存保存操作。</li>
<li><strong>世代垃圾回收：</strong> 使用页面保护机制减少对老年内存段的修改检查开销。</li>
<li><strong>持久性存储：</strong> 将内存映射文件作为跨程序执行周期的数据结构，使用虚拟内存实现持久性和事务管理。</li>
<li><strong>扩展寻址能力：</strong> 用虚拟内存技术处理超过32位地址空间的大量数据。</li>
<li><strong>数据压缩分页：</strong> 使用压缩技术减少磁盘检索时间。</li>
<li><strong>堆溢出检测：</strong> 使用页错误机制检测堆溢出，而无需手动检查每次内存分配。</li>
</ul>
<p>在<strong>虚拟内存原语的性能</strong>部分，作者对多个操作系统（例如 Ultrix、SunOS 和 Mach）进行了基准测试，结果显示各系统在处理页面保护、陷阱处理和转换缓冲区（TLB）一致性上的性能存在显著差异。</p>
<p>在<strong>系统设计考虑</strong>部分提到，操作系统在设计时应重视以下几个方面：</p>
<ul>
<li><strong>TLB一致性：</strong> 在多处理器系统中，确保高效的TLB一致性对于减少过时TLB条目带来的非法访问至关重要。</li>
<li><strong>页面大小：</strong> 较小的页面可以减少故障处理延迟，但具体选择应根据应用的需求进行调整。</li>
<li><strong>访问受保护页面：</strong> 用户模式服务例程可能需要在保持页面保护的情况下访问页面，操作系统应支持这种访问方式。</li>
</ul>
<p>在<strong>结论</strong>部分作者指出，现代硬件和操作系统应将虚拟内存视为用户级应用的关键组件。这些原语能够在系统规模不断扩大时保持高效。操作系统设计中必须重视虚拟内存机制的高效性，如TLB一致性、页面大小灵活性和快速的页面保护机制。</p>
<h2 id="generational-garbage-collection分代垃圾回收"><strong>Generational Garbage Collection（分代垃圾回收）</strong>
</h2><p>虚拟内存保护的重要应用之一是分代垃圾回收（<strong>Generational Garbage Collection</strong>），这是一种高效的算法，依赖于动态分配记录的两个特性，通常用于 LISP 和其他编程语言中：</p>
<ol>
<li><strong>年轻记录更有可能迅速死亡</strong>，而老记录则有更大的存活可能。如果一个记录已经存活了很长时间，那么它很可能继续存活；相反，一个新的记录更可能只是一个临时的中间值。</li>
<li><strong>年轻记录通常指向老记录</strong>，因为在 LISP 和函数式编程语言中，分配一个新记录时，它通常会被初始化为指向已经存在的记录。</li>
</ol>
<p>根据特性1，大部分垃圾回收器的工作应集中在较年轻的记录上；根据特性2，垃圾回收器可以利用这一特性来优化回收效率。分配的记录会被保存在内存中的不同区域 $G_i$，称为“代”（<strong>Generations</strong>）。每代中的记录具有相似的年龄，$G_i$ 代中的所有记录都比 $G_{i+1}$代中的记录更老。基于观察，较低代 $G_i$ 通常不会指向较高代 $G_j$，因此垃圾回收器通常只在最年轻的代中进行回收，因为那里含有最多的垃圾。</p>
<p>为了回收某一代，回收器需要知道所有指向这一代的指针。这些指针可能存在于机器寄存器、全局变量或堆栈中。由于年轻记录几乎不会指向老记录，通常只有对现有记录的赋值操作才可能打破这一假设。因此，垃圾回收器需要检查每次修改，以确保不会破坏这一规则。</p>
<p>要检测这种指针的赋值操作，通常有以下两种方法：</p>
<ul>
<li><strong>使用专用硬件支持</strong>，进行修改检测。</li>
<li><strong>通过编译器检查赋值</strong>，需要执行额外的指令（大约2条或更多）。幸运的是，LISP、Smalltalk 等语言中的非初始化赋值相对较少，因此额外的检测开销约占总执行时间的5-10%。</li>
</ul>
<p>虚拟内存硬件可以通过“脏页”机制来检测对老对象的修改。如果操作系统提供了“脏页”（<strong>dirty</strong>）功能，垃圾回收器可以检查被修改的页面，找出从老代到新代的指针，并进行处理。如果没有这种服务，垃圾回收器可以使用页面保护机制：将老代的页面设置为只读，任何对它们的写操作都会引发异常。用户模式的异常处理器可以将触发异常的页面添加到列表中供垃圾回收器扫描，之后页面必须被解除保护以允许写入操作。</p>
<p>这一算法的多个变体表现出良好的性能。随着堆和内存的增大，这种机制开始优于其他技术。</p>
<p>该技术依赖于以下虚拟内存原语：</p>
<ul>
<li><strong>trap</strong>：捕获指针赋值异常。</li>
<li><strong>protN</strong>：将多个页面设置为只读。</li>
<li><strong>unprot</strong>：解除页面的只读保护。</li>
</ul>
<p>此外，由于用户模式处理器处理页面的时间与页面大小无关，而垃圾回收器扫描页面的时间与页面大小成正比，因此使用较小的页面大小可能更为合适。</p>
<p>这部分总结了分代垃圾回收的工作原理及其如何利用虚拟内存原语提高效率。</p>
<blockquote>
<p>在**Generational Garbage Collection（分代垃圾回收）**部分中，指针起到了连接不同代对象的作用。新生成的对象（新代）往往会指向已经存在的老对象（老代）。论文提到，这种指向老代的指针行为在分配时很常见，而从老代指向新代的指针是较为罕见的。为了确保在垃圾回收过程中能够有效处理这些异常情况，需要专门监控这些指针变化。</p>
<p>分代垃圾回收机制中，垃圾收集器重点处理新生成的对象，因为这些对象更可能迅速变为垃圾。为了高效回收，垃圾收集器只需要知道指向新代（年轻代）的指针，这些指针可能存在于寄存器、全局变量、或堆栈中。然而，根据观察，老代几乎不会有指针指向新代。唯一的可能性是通过赋值操作使得老代指向新代。</p>
<p>因此，为了检测这种从老代指向新代的异常赋值操作，系统会在修改堆对象时进行检查，以确保不违反“新代指向老代”的假设。如果检测到从老代指向新代的指针，垃圾收集器需要做进一步处理。操作系统或硬件可以通过脏页机制（dirty page）来辅助这个过程：垃圾收集器可以扫描那些被标记为“脏页”的内存，找出其中的老代指向新代的指针并处理这些指针。</p>
<p>如果操作系统没有提供脏页机制，垃圾收集器可以通过页面保护机制来实现这一目的：通过将老代的页面设置为只读模式，任何对这些页面的写操作都会引发页错误（trap）。用户态的错误处理程序会捕获这些错误，将涉及的页面添加到待扫描列表中，并解除该页面的只读保护以继续允许写操作。最后，在垃圾回收时，收集器会扫描这些列表中的页面，以查找并处理可能指向新代的指针。</p>
<p><strong>“找出从老代到新代的指针，并进行处理”</strong>，具体来说，这个过程如下：</p>
<ol>
<li><strong>检测指针变动</strong>：当老代对象尝试指向新代时，会通过页面保护或脏页机制检测到该指针变动。</li>
<li><strong>处理指针</strong>：垃圾收集器扫描相关页面，识别出从老代指向新代的指针。</li>
<li><strong>解除保护</strong>：识别和处理后，解除该页面的只读保护，恢复其正常的读写权限。</li>
</ol>
<p>这一机制允许系统高效地处理指针赋值带来的潜在错误，同时优化了垃圾回收的效率，尤其是在内存增大的情况下。</p>
</blockquote>
<h2 id="persistent-stores持久存储">Persistent stores(持久存储)
</h2><p><strong>持久存储</strong>（Persistent Stores）是用于创建超越单个程序调用的动态分配堆。程序可以遍历和修改数据结构、提交更改，甚至可以在不进行永久更改的情况下放弃这些更改。</p>
<p>在持久存储中，<strong>指针遍历</strong>（即读取操作）的设计与在主存储器中的数据读取操作（fetch）一样快速。这是因为持久存储通常被映射到磁盘文件上，从而允许在访问存储的新部分时触发页面错误（类似于内存中的正常操作）。</p>
<p>因此，就<strong>读取数据</strong>而言，持久存储确实可以像正常的内存获取操作一样高效。然而，<strong>写入操作</strong>则需要额外处理，例如跟踪“脏页”（dirty pages）和提交更改到磁盘，这可能会引入一定的延迟，具体取决于实现方式。</p>
<p>总结一下，<strong>从持久存储中读取数据的效率</strong>可以与普通的内存获取操作一样迅速，但<strong>写入操作</strong>可能会因为需要提交更改而稍有延迟。</p>
<h2 id="extending-addressability">Extending addressability
</h2><p>在“<strong>扩展寻址能力</strong>”部分，作者讨论了如何处理持久存储增长到超过处理器地址空间的情况。</p>
<p>由于现代磁盘驱动器（尤其是光盘）可以存储大量数据，持久存储有可能增长到包含超过232232个对象，因此32位的地址空间无法足够支持。虽然单个程序运行期间可能访问的对象数量不会超过232232，但整个数据库的规模可能会超出这一限制。</p>
<p>为了解决这个问题，可以修改持久存储的机制，使得<strong>在内存中的对象使用32位地址</strong>，而<strong>在磁盘上的对象使用64位地址</strong>。具体的做法是，将磁盘上的页面设定为内存页面的两倍大小。当从磁盘加载页面到内存时，64位的磁盘指针将通过<strong>翻译表</strong>转换为32位的内存指针。当这些32位指针首次被解引用时，可能会触发页面错误，页面错误处理程序会从磁盘中加载另一个页面，并将其转换为短指针。</p>
<h2 id="extending-addressability翻译表">Extending addressability翻译表
</h2><p>翻译表只为单次执行过程中访问的对象创建条目，这就是为什么32位的指针在内存中仍然足够使用。内存中的指针可以指向尚未被访问的页面，而这些页面还未被分配到内存中，但翻译表中会有条目指出它们在磁盘上的位置。</p>
<p>这个方案的概念源自Smalltalk-80中的<strong>LOOM系统</strong>，而通过页面错误机制实现这一点是较新的方法。</p>
<p>关于“<strong>翻译表只为单次执行过程中访问的对象创建条目，这就是为什么32位的指针在内存中仍然足够使用</strong>”的理解，我来帮您详细解释一下：</p>
<p>这里的核心观点是：<strong>32位指针在内存中仍然足够使用</strong>，因为在任何一次程序运行时，<strong>不会访问超过232232个对象</strong>。也就是说，虽然持久存储的大小可能超过232232个对象（这时需要64位指针来表示这些对象在磁盘上的位置），但在单次程序执行中，程序通常只会访问这些对象中的一小部分。因此，<strong>在内存中</strong>，使用32位指针就足够了。</p>
<p><strong>翻译表的作用</strong>是：当从磁盘加载某个页面时，64位的磁盘指针通过翻译表转换成32位内存指针。只有访问到特定的对象时，才需要为该对象分配内存地址，并在翻译表中创建相应的条目。这意味着翻译表只包含当前程序运行中<strong>实际访问的对象</strong>。由于每次程序运行时访问的对象总数远远小于232232，因此32位指针足以处理这些内存中的对象。</p>
<p>因此，<strong>32位指针在内存中足够使用</strong>，是因为翻译表动态地只为当前执行过程中访问到的对象分配内存和创建条目，内存中不需要同时容纳所有的对象。</p>
<h2 id="data-compression-paging">Data-compression paging
</h2><p>**数据压缩分页（Data-compression paging）**如下：</p>
<p>在典型的链式数据结构中，许多字会指向相邻的对象，许多字是空（nil）值。那些包含整数而不是指针的字通常包含小整数或零。简而言之，<strong>平均每个字的熵很小</strong>；此外，垃圾收集器可以将互相指向的对象放置在邻近位置，从而将每个字的熵减少到大约7个比特。</p>
<p>因此，<strong>通过使用数据压缩算法</strong>，一个由32位字组成的页面可以被压缩到大约四分之一页面大小。与其将最近未使用的页面直接分页到磁盘，不如先将它们压缩后放回主存储器中【36】。这样，当这些虚拟页面再次需要时，解压缩可能比从磁盘中取回要快得多。当然，经过长时间未使用后，压缩后的页面仍然可以被发送到磁盘中。</p>
<p>当然，数据压缩分页可以在操作系统中以透明方式实现，对用户进程完全不可见【28】。然而，由于垃圾收集器可以移动对象以最小化它们的熵，<strong>如果用户进程能够控制如何以及何时进行压缩</strong>，可能会获得更好的效果。</p>
<p>这个算法需要以下支持：</p>
<ul>
<li><strong>trap</strong>：用于捕捉页面访问故障。</li>
<li><strong>prot1（或protN）</strong>：用于保护或解除保护某个页面（或一组页面），这通常需要谨慎的缓冲操作。</li>
<li><strong>unprot</strong>：用于解除对页面的保护。</li>
</ul>
<p>此外，还需要判断哪些页面是最近没有被使用的。可以通过偶尔保护页面（测试是否有引用）来完成，也可以通过操作系统和硬件的帮助来实现这一点。</p>
<p>通过一个例子来解释“数据压缩分页”的过程。</p>
<p>假设我们有一个应用程序使用链式数据结构来管理对象，这些对象相互引用，并且很多字段都是空值（nil），或者是常见的小整数（如0）。这些对象存储在内存的多个页面中，每个页面大小为4KB。随着程序的运行，有些页面可能长时间不被访问，因此可以将这些页面从内存中移出。</p>
<p>在传统的虚拟内存系统中，未使用的页面会被直接分页到磁盘，等到需要时再从磁盘取回。但如果我们使用“数据压缩分页”的方法，这个过程会有所不同。</p>
<ol>
<li><strong>压缩未使用的页面</strong>：当系统检测到某个页面长时间未被访问时，而不是直接将其分页到磁盘，系统首先对页面进行数据压缩。由于页面中的很多数据是空值或者小整数，这些数据的熵很低，可以使用数据压缩算法将这些4KB的页面压缩到大约1KB大小。</li>
<li><strong>保留在内存中</strong>：压缩后的页面不会立即被分页到磁盘，而是依然保存在主存储器中，只是占用的空间大大减少了。这样，当这些页面再次需要时，程序可以直接从内存中解压缩页面，而不需要从磁盘读取。解压缩的速度通常比从磁盘读取要快得多。</li>
<li><strong>需要时解压缩</strong>：当程序再次访问到这些页面时，系统会检测到该页面已经被压缩，这时只需进行快速的解压缩操作，就可以将页面恢复到原来的状态，让程序继续运行。</li>
<li><strong>最终分页到磁盘</strong>：如果页面长时间不被访问，系统仍然可以选择将压缩后的页面最终分页到磁盘，但通过这种方法，系统可以减少频繁的磁盘访问，从而提高效率。</li>
</ol>
<p>这个过程的一个关键优势在于：对于内存中那些长时间不被访问的页面，通过压缩操作可以在不牺牲性能的前提下释放大量内存。而且，由于解压缩比从磁盘读取快得多，这样的机制比传统的分页系统更高效。</p>
<h2 id="heap-overflow-detection">Heap overflow detection
</h2><p>进程或线程的栈需要保护，以防止溢出访问。一种常见且实际的技术是将栈顶上方的页面标记为无效或不可访问。任何对这些页面的内存访问都会导致页面错误，操作系统可以捕捉该错误并通知用户程序栈溢出。在大多数Unix实现中，栈页面在首次使用之前不会被分配；操作系统对页面错误的响应是分配物理页面，标记为可访问，并继续执行而不通知用户进程（除非资源限制被超过）。</p>
<p>这种技术需要<strong>trap</strong>（捕获异常）、<strong>protN</strong>（减少多个页面的访问权限）和<strong>unprot</strong>（增加页面的访问权限）。但由于页面错误的发生率很低（大多数进程不会使用太多的栈空间），效率并不是一个问题。</p>
<p>同样的技术可以用于检测垃圾回收系统中的堆溢出【2】。通常，堆溢出通过在每次内存分配时执行比较和条件分支来检测。通过让用户进程在一块由保护页面（guard page）终止的内存区域中分配新记录，可以消除比较和条件分支。当可分配的内存区域用完时，页面错误陷阱会调用垃圾回收器。通常可以安排不需要重新调整内存保护，因为在回收后可以重新使用相同的分配区域。因此，这项技术只需要<strong>prot1</strong>（减少单个页面的访问权限）和<strong>trap</strong>。</p>
<p>在这里，陷阱的效率非常重要。某些语言的实现可能每50条指令就分配一个新单元。在分代垃圾回收器中，分配区域的大小可能非常小，以便让最年轻的一代完全适合于数据缓存。例如，一个64KB的分配区域可以容纳16,000个8字节的链表单元。在一个非常频繁分配的系统中（如将激活记录存储在堆上的系统），这样一小部分数据将是存活的，因此垃圾回收所需的时间本身将非常短。</p>
<p>因此，我们可以得出：</p>
<p><strong>堆溢出之前执行的指令数量</strong>：$64K/8×50=400K$</p>
<p><strong>使用比较和分支的开销指令数量</strong>：$64K/8×2=16K$</p>
<p>如果处理一个陷阱需要1200个周期（这是典型的情况，见第4节），那么这种技术可以将开销从4%减少到0.3%，这是一个值得的节省。如果陷阱处理时间更长，那么这种技术将不那么高效。</p>
<p>由于还有其他好的技术可以减少堆限制检查的开销，比如在展开的循环中结合连续分配的限制检查，因此虚拟内存的这一应用可能是本文讨论的所有应用中<strong>最不有趣</strong>的。</p>
<blockquote>
<p>文中提到，传统的堆溢出检测通常是在每次内存分配时，通过<strong>比较和条件分支</strong>（compare and branch）的方式来检测是否发生了堆溢出。这种方法需要在每次分配时额外执行两条指令来进行比较和条件分支，因此在系统中，这个过程会增加额外的指令开销。</p>
<p>而通过使用<strong>trap机制</strong>，这种额外的指令开销可以被消除。系统可以通过设置一个保护页面（guard page），当内存分配超出可分配的范围时，程序会触发<strong>页面错误（page fault）</strong>，然后调用垃圾收集器来处理这个溢出。这就不再需要每次分配时进行比较和条件分支的操作，减少了指令数量。</p>
<p><strong>指令数量的关系计算</strong>：</p>
<ul>
<li>在传统的比较和分支方法中，每次内存分配都需要两条指令来进行检查。</li>
<li>在使用trap的情况下，这些检查可以通过页面错误来触发，减少了频繁的比较和分支操作。</li>
</ul>
<p><strong>trap所需的周期数</strong>是指，当程序触发页面错误时，操作系统或硬件需要花费的时间来处理该错误。文中提到，处理一次页面错误的trap大约需要<strong>1200个周期</strong>。相比之下，程序执行普通指令（如加法）所需的时间要少得多。例如，在一个典型的处理器上，执行一条指令可能只需要<strong>1到几个周期</strong>。</p>
<p>文中提到：</p>
<ul>
<li>如果没有trap机制，堆溢出检测每次都需要比较和分支，这会导致**4%**的性能开销。</li>
<li>使用trap后，虽然每次页面错误处理需要大约1200个周期，但它只会在堆溢出时触发，而不是在每次分配时进行比较和分支，因此可以将性能开销减少到<strong>0.3%</strong>。</li>
</ul>
<p>trap的原理是利用页面保护机制。当程序尝试访问一个受保护的页面时，系统会捕获这个错误，并触发一个陷阱（trap）。操作系统或用户态的错误处理程序会处理这个错误，然后可能会解除页面的保护，允许程序继续访问该页面。这个过程的关键在于减少程序在正常情况下的指令开销，而只在必要时通过页面错误机制处理特殊情况。</p>
<p>在文中的例子中，垃圾收集器会在分配区域末端设置一个保护页面。当程序试图超出分配区域时，系统触发页面错误，这时垃圾收集器被调用，清理堆内存并允许程序继续运行。</p>
</blockquote>
<h2 id="vm-primitive-performance">VM primitive performance
</h2><p>几乎我们在本文中描述的所有算法都属于以下两类之一。<strong>第一类算法</strong>会将页面批量保护起来（使其无法访问），然后在每次页面错误（page-fault）陷阱发生时，逐个解除这些页面的保护状态。<strong>第二类算法</strong>则是对页面进行单独的保护和解除保护操作。由于 <code>protN</code>（批量保护）、<code>trap</code>（陷阱）和 <code>unprot</code>（解除保护）始终是一起使用的，如果其中一个操作效率很高，而其他操作非常慢，那么该操作系统的性能也不会很好。</p>
<p>我们对整体的用户模式虚拟内存性能进行了两项测试。<strong>第一项测试</strong>是测量 <code>prot1</code>、<code>trap</code> 和 <code>unprot</code> 的总耗时，方法是对以下基准程序执行100次：</p>
<ul>
<li>访问一个随机被保护的页面，然后在错误处理程序中保护另一个页面，并解除对发生错误的页面的保护。</li>
</ul>
<p>为了得到更准确的时间测量，这个过程重复了100次。</p>
<p><strong>第二项测试</strong>是测量 <code>protN</code>、<code>trap</code> 和 <code>unprot</code> 的总耗时，基准程序的步骤如下：</p>
<ul>
<li>保护100个页面；</li>
<li>以随机顺序访问每个页面；</li>
<li>在错误处理程序中解除对发生错误的页面的保护。</li>
</ul>
<p>在计时开始之前，这两个程序都会对每个页面进行写操作，以消除填充缓存和TLB（转换后备缓冲区）所带来的暂时性影响。</p>
<p>我们对几种操作系统的性能进行了比较，包括 <strong>Ultrix</strong>、<strong>SunOS</strong> 和 <strong>Mach</strong>，分别在不同平台上运行这些基准程序。为了校准测量结果，我们还给出了单条指令（<code>add</code>）的执行时间，该时间是通过一个包含20条指令的循环（包括18个加法操作、一个比较和一个分支）测量出来的。我们还给出了一个 <code>trap</code>（陷阱处理程序）的时间，它不改变任何内存保护；这个时间对于堆溢出检测是有用的。结果见表1。需要注意的是，这个基准测试不是一个“<strong>整体操作系统吞吐量</strong>”的测试【27】，不应该受到磁盘速度的影响；它测量的是用户级程序对虚拟内存服务的CPU处理性能。</p>
<p>我们还尝试在同一进程中使用两个不同的虚拟地址映射同一个物理页面，分别使用 <strong>SunOS</strong> 和 <strong>Ultrix</strong> 的共享内存操作（<code>shmop</code>），以及 <strong>Mach</strong> 中的 <code>vmamap</code>。<strong>SunOS</strong> 和 <strong>Mach</strong> 支持此操作，但 <strong>Ultrix</strong> 不允许在同一进程中使用 <code>shmat</code> 连接同一个共享内存对象到不同地址。</p>
<p>显然，不同操作系统在相同硬件上的性能差异很大。这表明某些或所有系统中都有很大的改进空间。此外，一些操作系统的某些版本在 <code>mprotect</code> 调用后没有正确刷新 TLB，这表明许多操作系统实现者并没有认真对待这个功能。</p>
<p>重要的是，这些操作系统服务的效率要高。这里的论点比“<strong>高效是好的</strong>”这个空洞的说法更具体。对于磁盘分页而言，页面错误通常意味着要等待20毫秒才能让磁盘旋转到正确的扇区；因此，3至5毫秒的错误处理开销几乎不会被视为错误处理延迟的贡献者。但是在本文中描述的算法中，错误将完全由CPU处理。例如，我们已经实现了一个垃圾收集器，在20 MIPS的机器上，处理一个页错误需要执行大约10条指令来完成对 <code>to-space</code> 的每个字（word）的操作。在一个页大小为4096字节（1024字）的系统中，计算处理时间大约为500微秒。如果操作系统的错误处理和页面保护开销为1200微秒（如平均所示），那么操作系统显然成为瓶颈。</p>
<p>如果程序表现出良好的访问局部性，那么垃圾收集产生的错误将很少，操作系统的开销就不那么重要。但对于实时程序，它们必须满足严格的延迟要求，即使偶尔出现的“<strong>慢错误</strong>”也会造成问题。例如，如果客户端程序不能被中断超过1毫秒，那么500微秒的错误处理计算时间几乎没有给操作系统提供额外1200微秒的空间！(这个问题在我们考虑多个连续错误时变得更加复杂；详见【11】)</p>
<p>为了比较不同架构上的虚拟内存基元性能，我们用处理器速度对测量值进行了归一化。图4显示了各处理器在保护一个页面、发生错误以及解除保护一个页面所需时间内可以执行的 <code>add</code> 指令数。</p>
<p>我们的基准测试表明，不同操作系统对虚拟内存基元的实现效率存在很大的差异。在 <strong>NX/2</strong> 操作系统上运行的基于 <strong>Intel 80386</strong> 的机器【29】（一种用于 <strong>iPSC/2</strong> 超立方体多计算机的简单操作系统）在我们的基准测试中表现最佳。其归一化基准性能约为表现最差的系统（在 <strong>Sparcstation</strong> 上运行的 <strong>Mach</strong>）的十倍。显然，这些基元没有固有的原因一定会慢。硬件和操作系统设计者应将内存保护性能视为设计过程中需要权衡的一个重要方面。</p>
<h2 id="tlb的回顾">TLB的回顾
</h2><p>在现代计算机系统中，**转换后备缓冲区（TLB, Translation Lookaside Buffer）**是一个缓存，用来存储虚拟地址到物理地址的映射。它的作用是加速虚拟内存系统中地址转换的过程，避免每次都需要通过页表（page table）来查找地址映射。</p>
<p>当程序访问一个虚拟地址时，处理器首先会在TLB中查找对应的物理地址。如果找到（TLB命中），处理器可以快速访问数据；如果找不到（TLB未命中），系统会去页表中查找并更新TLB。</p>
<p>在进行内存访问控制时，可能会改变某些页面的访问权限。比如，程序可能设置某个页面为<strong>可访问</strong>或<strong>不可访问</strong>。此时，TLB 中缓存的映射信息可能已经过时，而这会影响系统的行为。</p>
<ul>
<li>
<p><strong>当页面被设为</strong>“<strong>更易访问</strong>”时，TLB 中的<strong>过时信息</strong>是无害的。</p>
<p>假设之前一个页面是不可访问的（例如，页面被保护以防止读写），并且TLB中缓存了这个页面的不可访问状态。现在，如果我们将该页面设为可访问的，但TLB 中依然存在不可访问的过时条目，那么最坏的情况是系统会因为TLB未更新，错误地认为页面不可访问，从而触发一次<strong>TLB未命中</strong>或者<strong>页错误</strong>（page fault）。此时，系统会发现页面实际上是可访问的，于是会<strong>更新TLB</strong>并允许访问。虽然会多一次错误处理，但这不会影响程序的正确性，因为页面本身现在是可访问的。</p>
</li>
<li>
<p><strong>当页面被设为</strong>“<strong>不易访问</strong>”时，TLB 中的<strong>过时信息</strong>可能导致非法访问。</p>
<p>如果页面原本是可访问的，而现在被设置为不可访问，但TLB 中依然缓存着可访问的过时映射，那么程序仍可能通过过时的 TLB 条目访问该页面。这时，系统没有触发访问保护机制，程序可能进行非法读写操作，导致数据不安全或者程序崩溃。因此，这种情况是有害的。</p>
</li>
</ul>
<p><strong>举个例子：内存页面权限更改</strong></p>
<p>场景1：页面设为<strong>更易访问</strong></p>
<p>假设有一个页面 <code>P</code>，最初是<strong>不可写</strong>的（只读），程序试图写入该页面时触发了保护机制，系统将该页面设为<strong>可写</strong>。但由于TLB中还缓存着页面 <code>P</code> 的不可写权限（过时信息），程序接下来的写操作可能触发<strong>TLB未命中</strong>。系统会发现这是过时信息，重新查找并确认页面 <code>P</code> 现在是可写的，于是<strong>更新TLB条目</strong>，并允许程序写入。这只是一次额外的查找，最终程序能够正常运行，因此无害。</p>
<p>场景2：页面设为<strong>不易访问</strong></p>
<p>现在设想页面 <code>P</code> 原来是<strong>可写</strong>的，但为了保护数据，系统将该页面设为<strong>只读</strong>。如果 TLB 中仍然缓存着原来的<strong>可写权限</strong>，那么程序接下来的写操作将绕过系统的保护机制，导致非法修改。由于TLB条目没有更新，操作系统不会立即发现这个问题，直到后来数据不一致或崩溃。因此，这种过时的 TLB 信息会导致<strong>非法访问</strong>，必须避免。</p>
<p>所以，</p>
<ul>
<li>
<p><strong>设为更易访问时</strong>：过时的 TLB 条目导致一次额外的处理（如TLB未命中或页错误），但不会影响数据安全或程序正确性。</p>
</li>
<li>
<p><strong>设为不易访问时</strong>：过时的 TLB 条目会导致非法访问，破坏系统保护机制，必须通过刷新 TLB 来保证页面访问权限的正确性。</p>
</li>
</ul>
<p>这也是为什么在内存访问权限变得更严格（如设为不可访问）时，必须确保所有处理器的 TLB 中的信息一致。否则，就可能导致安全漏洞或程序异常。</p>
<h2 id="tlb-consistency">TLB Consistency
</h2><p>许多在本文中介绍的算法，都会以批量方式减少内存的可访问性，并在每次访问时逐页增加内存的可访问性。这对于并发垃圾收集、分代垃圾收集、并发检查点、持久存储和扩展寻址能力来说尤其如此。</p>
<p>这对多处理器来说是一件好事，因为它能够解决<strong>转换后备缓冲区（TLB）一致性问题</strong>。当一个页面被设为<strong>更易访问</strong>时，TLB 中的过时信息是无害的，最多只会导致一个虚假的、容易修复的 TLB 未命中或 TLB 错误。然而，当页面被设为<strong>不易访问</strong>时，TLB 中的过时信息可能导致非法访问此页面。为了防止这种情况，有必要从每个可能包含该页面的 TLB 中刷新此页面。这个**“清除（shootdown）”**过程可以通过软件完成，即通过中断每个其他处理器并要求它们刷新 TLB 中的该页面，或者通过各种总线系统在硬件上完成【7，32】。</p>
<p>如果有许多处理器需要中断，软件清除过程可能会非常昂贵。我们解决清除问题的方案是<strong>批量清除</strong>；覆盖多个页面的清除成本并不比单个页面清除的成本高多少，当处理多个页面时，清除的成本可以被分摊，单个页面的成本变得可以忽略不计。本文中描述的那些以批量方式保护页面的算法“无意中”利用了批量清除的优势。</p>
<p>批量操作的概念是根据我们在本文中描述的算法结构自然得出的，但它也可以用于解决<strong>传统的磁盘分页</strong>中的清除问题。在磁盘分页中，为了释放物理页面供其他虚拟页面使用，页面被设置为不易访问（即“分页出去”）。如果操作系统能够维持一个较大的未使用物理页面的预留空间，那么它可以以批量方式执行分页操作（以补充预留空间）；这样可以将清除成本分摊到整个批量操作中。因此，尽管有人声称软件解决方案表现良好，但可能需要硬件支持【7】，通过批量处理，硬件支持可能就不再必要。</p>
<p>这段内容主要讨论了如何通过批量处理页面访问控制来优化 TLB 的一致性问题，特别是在多处理器系统中批量处理能够显著减少系统开销。</p>
<blockquote>
<p>它是如何应用在传统的磁盘分页问题中的。</p>
<p>首先，文中提到的“批量操作”是指同时对多个页面执行某种操作（例如设置访问权限或执行清除），而不是一次只对单个页面进行操作。这种批量操作在处理大量页面时更有效，因为可以将多个页面的处理开销合并，降低每个页面操作的成本。</p>
<p>在传统的虚拟内存系统中，当内存不足时，操作系统会通过<strong>磁盘分页</strong>将不经常使用的物理内存页面<strong>分页到磁盘</strong>（即“交换出去”）。当需要这些页面时，再从磁盘读取回内存。这个过程中涉及到将内存页面标记为“<strong>不易访问</strong>”或“<strong>不可访问</strong>”，以释放物理内存。</p>
<p><strong>问题：</strong> 当页面被设置为不可访问时，系统需要确保这些页面的旧访问权限不会留在<strong>TLB</strong>中。否则，处理器可能仍然使用过时的权限，导致非法访问这些已分页出去的页面。为了防止这种情况发生，操作系统需要将这些页面从各个处理器的 TLB 中<strong>清除</strong>（即<strong>清除操作</strong>或 shootdown）。</p>
<p>在传统的分页过程中，当操作系统分页出去页面时，如果每次都对每一个页面单独执行清除操作（逐个刷新每个页面的 TLB 条目），这个开销会很大，尤其是在多处理器系统中。每个处理器都必须被中断，要求它们刷新 TLB，可能会造成性能瓶颈。</p>
<p>文中提出的批量操作解决方案可以用于优化这个过程：</p>
<ul>
<li><strong>批量清除：</strong> 而不是逐个处理每个页面的清除（刷新 TLB），可以将多个页面一起批量执行。清除多个页面的成本与清除单个页面的成本相差不大，因此通过批量处理可以将开销分摊到多个页面上，从而<strong>降低每个页面的平均处理成本</strong>。</li>
<li><strong>预留空间：</strong> 通过保持一部分<strong>未使用的物理内存页面</strong>（预留空间），操作系统可以一次性批量将多个虚拟页面分页出去，释放物理内存。这种批量分页操作减少了单个页面分页出去时所需的清除次数和中断处理器的次数，提升了性能。</li>
</ul>
<p>在传统的磁盘分页中，操作系统通常需要依赖<strong>硬件支持</strong>来加速这些分页和清除操作。然而，如果批量处理做得足够高效，那么这些分页和清除操作的开销会显著降低，可能就不再需要特殊的硬件支持。这意味着即便没有硬件优化，操作系统仍然可以通过批量操作来实现较高的性能。</p>
<p>文中通过将批量处理应用到磁盘分页，解决了以下问题：</p>
<ul>
<li><strong>TLB 清除的开销：</strong> 多个页面的清除成本可以被分摊，减少了逐个页面执行清除时的成本。</li>
<li><strong>硬件依赖性降低：</strong> 批量处理可以使分页操作的效率提升，降低对硬件支持的需求。</li>
</ul>
<p>最终，批量操作不仅适用于本文中讨论的高级算法（如垃圾收集），也可以用于传统的磁盘分页系统，以更高效地释放物理内存和管理页面权限。</p>
</blockquote>
<h2 id="optimal-page-size">Optimal page size
</h2><p>选择页面大小是一项重要的设计决策，受多种因素的影响。</p>
<p>首先，小页面的主要优点是：当从磁盘读取或写入内存时，传输时间是线性增加的，而查找时间是固定的。因此，较小的页面减少了未使用数据传输到磁盘的浪费。这对于具有<strong>糟糕的局部性</strong>的应用程序来说尤为重要，因为它们的每个页面中只有很少的字被访问。</p>
<p>另一方面，大页面有助于减少页表的开销，尤其是在使用二维或多级页表时。此外，大页面能够显著降低TLB未命中的频率，因为TLB每个条目可以映射更大的内存区域。如果TLB条目的数量是固定的，页面越大，每个条目能覆盖的内存区域就越多，从而减少了TLB未命中的可能性。</p>
<p>因此，页面大小的选择涉及在<strong>减少磁盘传输时间</strong>和<strong>减少TLB未命中</strong>之间的权衡。为此，有几条经验法则：</p>
<ol>
<li><strong>对于随机内存访问</strong>，即当程序没有表现出良好的局部性时，小页面往往更有效，因为它们减少了未使用数据的传输。</li>
<li><strong>对于表现出良好局部性的程序</strong>，大页面更有利，因为它们能够减少TLB未命中和页表开销。</li>
<li><strong>现代磁盘和内存系统的性能特征</strong>表明，随着传输速率的提高，大页面的相对优势在增加。</li>
</ol>
<p>有些系统允许在运行时调整页面大小，而有些系统则通过使用多个页面大小（称为“<strong>大页面支持</strong>”）来允许某些进程使用较大的页面。后一种方法通常在大型科学应用或数据库系统中使用，它们具有良好的局部性并且需要大量内存。</p>
<p>总而言之，<strong>最佳页面大小</strong>的选择依赖于应用程序的特性以及系统的具体硬件特征。</p>
<h2 id="access-to-protected-pages">Access to protected pages
</h2><p>&ldquo;Access to protected pages&quot;部分讲述了在多处理器系统中，用户模式的服务程序需要访问那些对客户端线程不可访问的页面。这种需求出现在并发垃圾收集、扩展寻址能力、共享虚拟内存以及数据压缩分页等算法中。</p>
<p>实现对受保护页面的访问有几种方式：</p>
<ol>
<li><strong>在同一个地址空间中，给相同页面提供多个映射，并且每个映射具有不同的保护级别</strong>。例如，垃圾收集器可以通过一个“非标准”地址访问to-space的页面，而mutator看到的to-space页面则是受保护的。</li>
<li><strong>提供一个系统调用来复制受保护区域的内存</strong>。垃圾收集器可以在处理每个页面时调用该系统调用三次：一次用于从from-space复制记录到to-space；一次用于扫描to-space页面之前；还有一次是在扫描结束后，在让mutator访问该页面之前。这种方法效率较低，因为需要频繁地复制数据。</li>
<li><strong>在允许共享页面的操作系统中，垃圾收集器可以运行在不同的重量级进程中，这个进程有一个不同的页表</strong>。这种方法的问题在于每次垃圾收集页面故障时需要进行两次昂贵的重量级上下文切换。然而，在多处理器系统中，可能通过远程过程调用（RPC）通知另一个已经处于正确上下文中的处理器，这样该选项可能会更加有吸引力。</li>
<li><strong>垃圾收集器可以在操作系统内核中运行</strong>。这种方式效率最高，但可能不适合因为垃圾收集器并不应该运行在内核中。此外，每种编程语言的运行时数据格式不同，内核可能无法处理所有语言的垃圾收集。</li>
</ol>
<p>文中建议，对于物理寻址缓存的计算机架构来说，<strong>在同一地址空间中提供多重虚拟地址映射</strong>是一个干净且高效的解决方案。它不需要重量级上下文切换，也不需要复制数据结构，也不需要将垃圾收集器运行在内核中。缺点是每个物理页面可能需要在页表中占用两个不同的条目，增加了物理内存的需求，不过这个增量很小。</p>
<p>在具有虚拟寻址缓存的系统中，多重虚拟地址映射可能会带来缓存一致性问题，但这在垃圾收集算法中很容易解决。在垃圾收集器扫描页面时，mutator无法访问该页面，因此mutator地址空间中不会有该页面的缓存行。扫描结束后，垃圾收集器应刷新该页面的缓存行，从而避免不一致性问题。</p>
<p>这段内容强调了在并发计算环境中如何实现受保护页面的高效访问，以及不同方法的优缺点。</p>
<blockquote>
<p>垃圾收集器在处理每个页面时调用系统调用三次，是因为它们分别对应不同的步骤，以确保页面的有效同步和访问控制。具体作用如下：</p>
<ol>
<li><strong>第一次调用：从 from-space 复制到 to-space</strong>。垃圾收集器需要将已经不再使用的对象从一个内存区域 (from-space) 复制到另一个内存区域 (to-space)。为了进行这次复制操作，垃圾收集器需要调用系统以访问并复制受保护的内存页面。</li>
<li><strong>第二次调用：在扫描页面之前</strong>。在垃圾收集器准备扫描 to-space 中的新页面时，它需要确保该页面中不再包含任何指向旧空间 (from-space) 的指针。为了在扫描过程中进行这项操作，垃圾收集器需要再次通过系统调用获取对该页面的访问权限。</li>
<li><strong>第三次调用：扫描结束后，将页面提供给 mutator 访问</strong>。当垃圾收集器完成了对页面的扫描并确保页面中所有的指针都已更新为指向 to-space 的新对象后，它会调用系统，让 mutator (主线程) 可以安全地访问该页面，从而使程序的其他部分能够继续正常运行。</li>
</ol>
<p>每次调用系统调用的主要目的在于保证内存页面的访问权限和内容在不同阶段的正确性和一致性。这样设计的好处在于保证了并发垃圾收集过程中，collector 和 mutator 之间的同步，同时也确保了指针的正确更新和数据的安全性。</p>
<p>多重虚拟地址映射可能会带来缓存一致性问题的原因与计算机体系结构中的缓存机制有关。缓存的主要目的是提高内存访问速度，将常用数据存储在较靠近处理器的高速存储器中，而不是每次都从较慢的主内存中读取。缓存通常是按照<strong>虚拟地址</strong>进行索引的，这意味着相同的物理内存页面如果被映射到多个虚拟地址上，那么系统在不同的虚拟地址下访问该页面时，可能会在缓存中存储多个副本。由于这些副本可以存在于缓存的不同位置，这就可能导致缓存中的数据不一致问题。</p>
<p>当系统中存在多个虚拟地址指向同一物理页面时，以下情况可能会发生：</p>
<ol>
<li><strong>缓存不一致性</strong>：一个虚拟地址指向的物理页面可能会被更新，但另一个映射到该物理页面的虚拟地址却没有反映这些更新，因为它的缓存副本没有被同步更新。这会导致两个虚拟地址对应的缓存中的数据不同步，出现数据不一致的情况。</li>
<li><strong>数据同步问题</strong>：如果同一个物理页面有多个缓存副本，当系统从某个虚拟地址修改数据后，如果不及时更新或清除其他虚拟地址的缓存副本，处理器在访问这些虚拟地址时可能会读取过时的数据，从而导致缓存一致性问题。</li>
</ol>
<p>缓存通常会根据虚拟地址进行分配，如果同一个物理页面通过多个虚拟地址映射，这些虚拟地址可能在缓存中占用不同的缓存行，而这正是造成不一致的根本原因。这种不一致性可能导致程序的错误运行，尤其是在垃圾回收等需要保证内存一致性的场景下。</p>
<p>所以，<strong>每个虚拟地址不会抽出一个特定的缓存块</strong>，但同一个物理页面可能通过多个虚拟地址映射，从而在缓存中创建多个条目，增加了保持这些条目一致的复杂性。</p>
</blockquote>
<h2 id="is-this-too-much-to-ask">Is this too much to ask?
</h2><p>有些Unix的实现，在某些机器上，提供了非常干净且同步的信号处理机制。引发页面故障的指令会调用信号处理程序，而不会改变处理器的其他状态；后续的指令不会执行，等等。信号处理程序可以完全同步地访问机器寄存器，改变内存映射或机器寄存器，然后重新开始执行故障指令。然而，在高度流水化的机器上，可能会存在多个未处理的页面故障【26】，并且可能在注意到故障之前，多个故障后的指令已经将其结果写入寄存器；这些指令可以恢复执行，但不能重新启动。</p>
<p>当用户程序依赖于同步行为时，它们在流水线机器上运行会很困难。现代UNIX系统让用户程序主动参与内存管理功能，允许它们显式地操作其内存映射。这在某种程度上就像是发出了“通往地狱的镌刻请柬”【26】。</p>
<p>如果所描述的这些算法确实与快速流水线机器不兼容，那将是一个严重的问题。幸运的是，除了一个例子之外，我们描述的所有算法都是足够异步的。从机器的角度来看，它们的行为非常像传统的磁盘分页：发生故障，提供物理页面，使该页面在页表中可访问，然后继续执行。</p>
<p>例外的是堆溢出检测：页面故障会启动垃圾回收，垃圾回收会修改寄存器（通过将其指向堆记录的新位置），然后恢复执行。存储下一分配单元地址的寄存器会被调整以指向分配空间的起始位置。之前发生故障的指令会重新执行，但这次它不会再发生故障，因为它正在存储到一个不同的位置。</p>
<p>这种行为在高度流水化的机器上是不可接受的（除非像在VAX 8800上那样【10】有硬件用于“撤销”那些已经完成的后续指令或地址模式副作用）。实际上，即便在Motorola 68020上，使用页面故障来检测堆溢出也不可靠。</p>
<p>因此，除了堆溢出检测之外，我们提出的所有算法对于硬件来说不会比普通磁盘分页带来更多问题，可以退还这张“通往地狱的请柬”；然而，操作系统必须确保为硬件提供足够的支持，以正确恢复半同步陷阱处理程序的故障操作。</p>
<h2 id="heap-overflow-detection-and-other-algorithms">heap overflow detection and other algorithms
</h2><p>堆溢出检测算法与其他内存管理算法在虚拟内存管理中的相同点和不同点如下：</p>
<p>Similarities</p>
<ol>
<li><strong>依赖页面保护机制</strong>：
<ul>
<li>无论是堆溢出检测还是其他内存管理算法，二者都依赖于页面保护机制来监控内存访问。这些算法利用设置页面为“不可访问”或“只读”等来触发页面错误（page fault），并在发生错误时进行相应处理。</li>
</ul>
</li>
<li><strong>通过页面错误进行内存管理</strong>：
<ul>
<li>堆溢出检测与诸如并发垃圾回收（concurrent garbage collection）等其他算法都依赖于操作系统提供的页面错误处理机制，以便在内存使用达到某个限度时进行回收或管理。</li>
</ul>
</li>
<li><strong>内存同步机制</strong>：
<ul>
<li>两种算法都涉及多线程或多处理器环境下的内存同步。在并发垃圾回收算法中，利用页面保护机制来同步不同线程对同一内存区域的访问。而堆溢出检测则使用页面错误触发垃圾回收，以防止超出可分配内存。</li>
</ul>
</li>
</ol>
<p>Differences</p>
<ol>
<li><strong>触发条件不同</strong>：
<ul>
<li><strong>堆溢出检测算法</strong>：该算法主要依赖于页面错误来检测堆内存溢出。当分配空间到达预设的保护页面时，触发页面错误，并调用垃圾回收器来整理内存。</li>
<li><strong>其他算法</strong>（例如并发垃圾回收或世代垃圾回收）：这些算法的页面错误触发更多与内存中对象的移动或跨线程同步相关。并发垃圾回收利用页面保护来防止线程之间的不正确数据访问，而世代垃圾回收通过监测跨代指针来进行内存管理。</li>
</ul>
</li>
<li><strong>错误处理的复杂性</strong>：
<ul>
<li><strong>堆溢出检测</strong>：在堆溢出检测中，页面错误的处理相对简单，主要目的是调用垃圾回收器以释放内存并更新指针。垃圾回收完成后，内存可以再次分配。错误处理不涉及复杂的线程同步或指针更新。</li>
<li><strong>并发垃圾回收</strong>：并发垃圾回收的页面错误处理则更加复杂。除了要处理指针的移动外，还要确保线程之间的正确同步，防止一个线程在另一个线程完成垃圾回收之前访问被移动的对象。</li>
</ul>
</li>
<li><strong>性能影响</strong>：
<ul>
<li><strong>堆溢出检测</strong>：堆溢出检测中，页面错误的发生频率与内存分配频率直接相关。如果内存分配速度快，页面错误将频繁发生，从而导致更多的垃圾回收调用。文档中提到，堆溢出检测中，每分配约50次内存就会引发一次页面错误。</li>
<li><strong>其他算法</strong>：其他算法（如世代垃圾回收）依赖于内存分代的特点，仅在较长时间内的对象进行回收时才会触发页面错误。因此，这些算法在处理频率上通常较低，尤其在新对象的分配主要集中在年轻代时。</li>
</ul>
</li>
<li><strong>适应硬件的能力</strong>：
<ul>
<li><strong>堆溢出检测</strong>：在高度流水线化的处理器上，堆溢出检测可能面临问题。文档中指出，由于处理器可能在注意到页面错误之前已经执行了多个指令，因此无法可靠地恢复执行错误指令，尤其是在如Motorola 68020等架构中，堆溢出检测机制并不稳定。</li>
<li><strong>其他算法</strong>：并发垃圾回收和共享虚拟内存等其他算法则更具异步性，对现代硬件架构更具适应性。这些算法通常不依赖于特定的指令状态，而是处理页面错误后继续执行程序。</li>
</ul>
</li>
</ol>
<p>堆溢出检测算法和其他内存管理算法都依赖页面错误和页面保护机制来进行内存管理，但在处理复杂性、触发条件和性能影响上存在显著不同。堆溢出检测主要用于检测堆内存的溢出并触发垃圾回收，而其他算法则更多用于并发处理、同步和跨代内存管理。此外，堆溢出检测在高度流水线处理器上面临更大的挑战，而并发垃圾回收等算法则具有更好的硬件适应性。</p>
<h2 id="正课">正课
</h2><h2 id="应用程序使用虚拟内存所需要的特性">应用程序使用虚拟内存所需要的特性
</h2><p>今天的话题是用户应用程序使用的虚拟内存，它主要是受这篇1991年的<a class="link" href="https://pdos.csail.mit.edu/6.828/2020/readings/appel-li.pdf"  target="_blank" rel="noopener"
    >论文</a>

的启发。</p>
<p>首先，你们已经知道了，操作系统内核以非常灵活的方式使用了虚拟内存Page Table。</p>
<p>你们已经通过Lazy Allocation Lab，Copy on Write Lab，以及XV6中的各种内存实现了解到了这一点。</p>
<p>而今天论文中的核心观点是，用户应用程序也应该从灵活的虚拟内存中获得收益，也就是说用户应用程序也可以使用虚拟内存。</p>
<p>用户应用程序本身就是运行在虚拟内存之上，我们这里说的虚拟内存是指：User Mode或者应用程序想要使用与内核相同的机制，来产生Page Fault并响应Page Fault（注，详见Lec08，内核中几乎所有的虚拟内存技巧都基于Page Fault）。</p>
<p>也就是说User Mode需要能够修改PTE的Protection位（注，Protection位是PTE中表明对当前Page的保护，对应了4.3中的Writeable和Readable位）或者Privileged level。</p>
<p>今天的论文，通过查看6-7种不同的应用程序，来说明用户应用程序使用虚拟内存的必要性。</p>
<p>这些应用程序包括了：</p>
<ul>
<li>Garbage Collector</li>
<li>Data Compression Application</li>
<li>Shared Virtual Memory</li>
</ul>
<p>你可以发现这都是一些非常不同的应用程序，并且它们都依赖虚拟内存的一些特性来正常工作。</p>
<p>所以第一个问题是，上面的应用程序需要的特性是什么？所以我们先来讨论一下需要的特性是什么？</p>
<ul>
<li>
<p>首先，你需要trap来使得发生在内核中的Page Fault可以传播到用户空间，然后在用户空间的handler可以处理相应的Page Fault，之后再以正常的方式返回到内核并恢复指令的执行。</p>
<p>这个特性是必须的，否则的话，你不能基于Page Fault做任何事情。</p>
</li>
<li>
<p>第二个特性是Prot1，它会降低了一个内存Page的accessability。</p>
<p>accessability的意思是指内存Page的读写权限。</p>
<p>内存Page的accessability有不同的降低方式，例如，将一个可以读写的Page变成只读的，或者将一个只读的Page变成完全没有权限。</p>
</li>
<li>
<p>除了对于每个内存Page的Prot1，还有管理多个Page的ProtN。</p>
<p>ProtN基本上等效于调用N次Prot1，那为什么还需要有ProtN？</p>
<p>因为单次ProtN的损耗比Prot1大不了多少，使用ProtN可以将成本分摊到N个Page，使得操作单个Page的性能损耗更少。</p>
<p>在使用Prot1时，你需要修改PTE的bit位，并且在Prot1的结束时，需要清除TLB（注，详见4.4 Translation Lookaside Buffer），而清除TLB比较费时。</p>
<p>如果能对所有需要修改的内存Page集中清理一次TLB，就可以将成本分摊。</p>
<p>所以ProtN等效于修改PTE的bit位N次，再加上清除一次TLB。</p>
<p>如果执行了N次Prot1，那就是N次修改PTE的bit位，再加上清除N次TLB，所以ProtN可以减少清除TLB的次数，进而提升性能。</p>
</li>
<li>
<p>下一个特性是Unprot，它增加了内存Page的accessability，例如将本来只读的Page变成可读可写的。</p>
</li>
<li>
<p>除此之外，还需要能够查看内存Page是否是Dirty。</p>
</li>
<li>
<p>以及map2。map2使得一个应用程序可以将一个特定的内存地址空间映射两次，并且这两次映射拥有不同的accessability。</p>
<blockquote>
<p>（注，也就是一段物理内存对应两份虚拟内存，并且两份虚拟内存有不同的accessability）。</p>
</blockquote>
</li>
</ul>
<p>XV6在用户程序中支持以上任意的特性吗？</p>
<p>除了有类似于trap及其相关的alarm hander之外，XV6不支持任何一个以上的特性。</p>
<p>XV6只有一个最小化的Unix接口，并不支持以上任何虚拟内存特性。</p>
<p>尽管在XV6的内核中包含了所有的可用的虚拟内存的机制，但是并没有以系统调用的形式将它们暴露给用户空间。</p>
<p>论文的观点是，任何一个好的操作系统都应该以系统调用的形式提供以上特性，以供应用程序使用。</p>
<p>所以自然的，这就引出了另一个问题，当今的Unix系统的功能范围是什么？以上特性属于Unix的范畴吗？</p>
<p>如果你查看现在的Unix系统，例如Linux，你会发现，或许并不与论文中描述的完全一样，但是这些特性都存在。</p>
<p>在论文那个年代（1991年），某些操作系统只包含了部分以上特性，但是如今这些特性都已经在现代的Unix系统中广泛支持了。接下来我们看一下如何实现这些特性。</p>
<h2 id="支持应用程序使用虚拟内存的系统调用">支持应用程序使用虚拟内存的系统调用
</h2><h3 id="mmap的系统调用">mmap的系统调用
</h3><p>第一个或许也是最重要的一个，是一个叫做mmap的系统调用。</p>
<p>它接收某个对象，并将其映射到调用者的地址空间中。</p>
<p>举个例子，如果你想映射一个文件，那么你需要将文件描述符传递给mmap系统调用。</p>
<p>mmap系统调用有许多令人眼花缭乱的参数（注，mmap的具体说明可以参考<a class="link" href="https://man7.org/linux/man-pages/man2/mmap.2.html"  target="_blank" rel="noopener"
    >man page</a>

）：</p>
<ul>
<li>
<p>第一个参数是一个你想映射到的特定地址，如果传入null表示不指定特定地址，这样的话内核会选择一个地址来完成映射，并从系统调用返回。</p>
</li>
<li>
<p>第二个参数是想要映射的地址段长度len。</p>
</li>
<li>
<p>第三个参数是Protection bit，例如读写R|W。</p>
</li>
<li>
<p>第四个参数我们会跳过不做讨论，它的值可以是MAP_PRIVATE。它指定了如果你更新了传入的对象，会发生什么。</p>
<blockquote>
<p>（注，第四个参数是flags，MAP_PRIVATE是其中一个值，在mmap文件的场景下，MAP_PRIVATE表明更新文件不会写入磁盘，只会更新在内存中的拷贝，详见<a class="link" href="https://man7.org/linux/man-pages/man2/mmap.2.html"  target="_blank" rel="noopener"
    >man page</a>

）。</p>
</blockquote>
</li>
<li>
<p>第五个参数是传入的对象，在上面的例子中就是文件描述符。</p>
</li>
<li>
<p>第六个参数是offset。</p>
</li>
</ul>
<p>通过上面的系统调用，可以将文件描述符指向的文件内容，从起始位置加上offset的地方开始，映射到特定的内存地址（如果指定了的话），并且连续映射len长度。</p>
<p>这使得你可以实现Memory Mapped File，你可以将文件的内容带到内存地址空间，进而只需要方便的通过普通的指针操作，而不用调用read/write系统调用，就可以从磁盘读写文件内容。</p>
<p>这是一个方便的接口，可以用来操纵存储在文件中的数据结构。</p>
<p>实际上，你们将会在下个lab实现基于文件的mmap，下个lab结合了XV6的文件系统和虚拟内存，进而实现mmap。</p>
<p>mmap还可以用作他途。</p>
<p>除了可以映射文件之外，还可以用来映射匿名的内存（Anonymous Memory）。</p>
<p>这是sbrk（注，详见8.2）的替代方案，你可以向内核申请物理内存，然后映射到特定的虚拟内存地址。</p>
<p>mmap是实现应用程序虚拟内存的核心系统调用之一，我们稍后会将它与之前提到的特性关联起来。</p>
<p>除此之外，还需要有一些系统调用来支持论文中讨论到的特性。</p>
<h3 id="mprotect系统调用">mprotect系统调用
</h3><blockquote>
<p>（注，详见<a class="link" href="https://man7.org/linux/man-pages/man2/mprotect.2.html"  target="_blank" rel="noopener"
    >man page</a>

）。</p>
</blockquote>
<p>当你将某个对象映射到了虚拟内存地址空间，你可以修改对应虚拟内存的权限，这样你就可以以特定的权限保护对象的一部分，或者整个对象。</p>
<p>举个例子，通过上图对于mprotect的调用将权限设置成只读（R），这时，对于addr到addr+len这段地址，load指令还能执行，但是store指令将会变成Page Fault。</p>
<p>类似的，如果你想要将一段地址空间变成完成不可访问的，那么可以在mprotect中的权限参数传入None，那么任何对于addr到addr+len这段地址的访问，都会生成Page Fault。</p>
<h3 id="munmap">munmap
</h3><p>对应mmap还有一个系统调用munmap，它使得你可以移除一个地址或者一段内存地址的映射关系。</p>
<h3 id="sigaction">sigaction
</h3><p>最后一个系统调用是sigaction，它本质上是用来处理signal。</p>
<p>它使得应用程序可以设置好一旦特定的signal发生了，就调用特定的函数。</p>
<p>可以给它传入函数f作为特定signal的handler。</p>
<p>在Page Fault的场景下，生成的signal是segfault。</p>
<p>你或许之前在用户代码中看过了segfault，通常来说当发生segfault时，应用程序会停止运行并crash。</p>
<p>但是如果应用程序为segfault signal设置了handler，发生segfault时，应用程序不会停止，相应的handler会被内核调用，然后应用程序可以在handler中响应segfault。</p>
<p>当内核发现Page Fault时，或许会通过修复Page Table来使得应用程序还能继续执行。</p>
<p>与内核响应Page Fault的方式类似，在这里的handler中或许会调用mprotect来修改内存的权限来避免segfault，这样应用程序的指令就可以恢复运行。</p>
<p>与sigaction类似的有sigalarm（译注：sigalarm 是<a class="link" href="https://pdos.csail.mit.edu/6.S081/2020/labs/traps.html"  target="_blank" rel="noopener"
    >traps lab</a>

 中实现的一个系统调用，不属于标准Unix 接口），在sigalarm中可以设置每隔一段时间就调用handler。</p>
<p>sigaction也可以实现这个功能，只是它更加的通用，因为它可以响应不同类型的signal。</p>
<blockquote>
<p>学生提问：看起来mprotect暗示了你可以为单独的地址添加不同的权限，然而在XV6中，我们只能为整个Page设置相同的权限，这里是有区别吗？</p>
<p>Frans教授：不，这里并没有区别，它们都在Page粒度工作。如果你好奇的话，有一个单独的系统调用可以查看Page的大小。</p>
</blockquote>
<h3 id="虚拟内存特性">虚拟内存特性
</h3><p>如果你回想前面提到过的虚拟内存特性，我们可以将它们对应到这一节描述的Unix接口中来。</p>
<ul>
<li>trap对应的是sigaction系统调用</li>
<li>Prot1，ProtN和Unprot可以使用mprotect系统调用来实现。mprotect足够的灵活，你可以用它来修改一个Page的权限，也可以用它来修改多个Page的权限。当修改多个Page的权限时，可以获得只清除一次TLB的好处。</li>
<li>查看Page的Dirty位要稍微复杂点，并没有一个直接的系统调用实现这个特性，不过你可以使用一些技巧完成它，我稍后会介绍它。</li>
<li>map2也没有一个系统调用能直接对应它，通过多次调用mmap，你可以实现map2特性。</li>
</ul>
<p>或许并不完全受这篇论文所驱动，但是内核开发人员已经在操作系统中为现在的应用程序提供了这些特性。</p>
<p>接下来，我将在框架层面简单介绍一下这些特性是如何实现的，之后再看看应用程序是如何使用这些特性。</p>
<h2 id="虚拟内存系统如何支持用户应用程序">虚拟内存系统如何支持用户应用程序
</h2><p>有关实现，有两个方面较为有趣。</p>
<p>第一个是虚拟内存系统为了支持这里的特性，具体会发生什么？</p>
<p>这里我们只会讨论最重要的部分，并且它也与即将开始的mmap lab有一点相关，因为在mmap lab中你们将要做类似的事情。</p>
<p>在现代的Unix系统中，地址空间是由硬件Page Table来体现的，在Page Table中包含了地址翻译。</p>
<blockquote>
<p>在现代的 Unix 系统中，<strong>地址空间的管理确实依赖于硬件级别的页表（Page Table）</strong>，但这并不意味着用户或操作系统完全无法控制它。我们可以理解为：</p>
<ol>
<li>
<p><strong>硬件辅助而非硬件独立控制</strong></p>
<ul>
<li>
<p><strong>页表的硬件实现</strong>：页表的实际翻译过程由硬件（比如 CPU 的内存管理单元 MMU）来执行。CPU 会根据页表中的内容将虚拟地址翻译成物理地址，这种翻译过程在访问内存时是由硬件快速完成的。</p>
</li>
<li>
<p><strong>软件管理与硬件依赖</strong>：操作系统在软件层面负责构建、修改和管理页表的内容，决定虚拟地址到物理地址的映射关系。虽然硬件负责执行实际的地址翻译，但操作系统通过系统调用和内核机制对页表进行控制，从而间接控制了地址空间。</p>
</li>
</ul>
</li>
<li>
<p><strong>为什么称为“硬件Page Table”</strong></p>
<ul>
<li>
<p><strong>性能的考量</strong>：地址翻译是频繁的基本操作，每次访问内存时都需要进行。这种高频率的操作如果完全由软件完成会非常耗时。因此，<strong>硬件（CPU）来负责翻译加速</strong>，以保证性能。页表硬件机制可以使这些翻译在数个 CPU 时钟周期内完成。</p>
</li>
<li>
<p><strong>页表的多级结构</strong>：现代 CPU 使用多级页表（例如 x86 架构中的四级页表）来高效地管理大规模地址空间。这些复杂的结构由硬件支持并高效处理。</p>
</li>
</ul>
</li>
<li>
<p><strong>用户的控制能力</strong></p>
<ul>
<li>
<p><strong>间接控制</strong>：用户态程序无法直接操作页表，但可以通过操作系统提供的接口（比如 <code>mmap</code> 或 <code>malloc</code>）来请求内存分配，操作系统会根据这些请求更新页表。</p>
</li>
<li>
<p><strong>内核态控制</strong>：在内核态，操作系统完全可以控制页表，包括创建新的页表、修改页表项、设置权限等。这些操作最终都影响到用户态进程的虚拟内存布局。</p>
</li>
</ul>
</li>
</ol>
<p>因此，<strong>“硬件 Page Table”指的是地址翻译依赖于硬件完成</strong>，而不是说用户或操作系统完全无法控制页表。操作系统仍然可以通过内核态管理页表并间接影响地址空间，只不过实际的地址翻译过程由硬件（CPU 和 MMU）来加速处理，以提高效率。这种设计是为了平衡性能与灵活性，使得系统能够高效地管理和访问内存。</p>
</blockquote>
<p>但是通常来说，地址空间还包含了一些操作系统的数据结构，这些数据结构与任何硬件设计都无关，它们被称为Virtual Memory Areas（VMAs）。</p>
<p>VMA会记录一些有关连续虚拟内存地址段的信息。</p>
<p>在一个地址空间中，可能包含了多个section，每一个section都由一个连续的地址段构成，对于每个section，都有一个VMA对象。</p>
<p>连续地址段中的所有Page都有相同的权限，并且都对应同一个对象VMA</p>
<p>例如一个进程的代码是一个section，数据是另一个section，它们对应不同的VMA，VMA还可以表示属于进程的映射关系，例如下面提到的Memory Mapped File。</p>
<p>举个例子，如果进程有一个Memory Mapped File，那么对于这段地址，会有一个VMA与之对应，VMA中会包含文件的权限，以及文件本身的信息，例如文件描述符，文件的offset等。</p>
<p>在接下来的mmap lab中，你们将会实现一个非常简单版本的VMA，并用它来实现针对文件的mmap系统调用。你可以在VMA中记录mmap系统调用参数中的文件描述符和offset。</p>
<p>第二个部分我们了解的就不多了，它或许值得仔细看一下，也就是User level trap是如何实现的？</p>
<p>我们假设一个PTE被标记成invalid或者只读，而你想要向它写入数据。</p>
<p>这时，CPU会跳转到kernel中的固定程序地址，也就是XV6中的trampoline代码（注，详见6.2）。</p>
<p>kernel会保存应用程序的状态，在XV6中是保存到trapframe。</p>
<p>之后再向虚拟内存系统查询，现在该做什么呢？</p>
<p>虚拟内存系统或许会做点什么，例如在lazy lab和copy-on-write lab中，trap handler会查看Page Table数据结构。</p>
<p>而在我们的例子中会查看VMA，并查看需要做什么。</p>
<p>举个例子，如果是segfault，并且应用程序设置了一个handler来处理它，那么</p>
<ul>
<li>segfault事件会被传播到用户空间</li>
<li>并且通过一个到用户空间的upcall在用户空间运行handler</li>
<li>在handler中或许会调用mprotect来修改PTE的权限</li>
<li>之后handler返回到内核代码</li>
<li>最后，内核再恢复之前被中断的进程。</li>
</ul>
<p>当内核恢复了中断的进程时，如果handler修复了用户程序的地址空间，那么程序指令可以继续正确的运行，如果哪里出错了，那么会通过trap再次回到内核，因为硬件还是不能翻译特定的虚拟内存地址。</p>
<blockquote>
<ol>
<li>
<p>&ldquo;segfault事件会被传播到用户空间&rdquo; 是什么意思？是指segfault这个信号会从内核态传给用户态吗？怎么传的？</p>
<p>是的，<strong>&ldquo;segfault事件会被传播到用户空间&rdquo;</strong> 意思是内核会检测到段错误（segfault）这种内存访问异常，然后通过一种信号机制将这个信息传递给用户态进程。</p>
<p>具体来说，在现代类 Unix 系统中，当进程试图非法访问内存（如访问一个无效的地址或尝试向只读页面写入数据）时，<strong>内核会捕获到这个异常并触发一个信号</strong>，通常是 <code>SIGSEGV</code> 信号（表示“段错误”）。这个信号会通知用户进程，内存访问出错。</p>
<p>传播机制如下：</p>
<ol>
<li><strong>内核捕获异常</strong>：CPU检测到非法内存访问，触发陷阱（trap）进入内核，内核负责处理该事件。</li>
<li><strong>生成信号（signal）</strong>：内核会向引发该异常的进程生成一个信号，比如 <code>SIGSEGV</code>，这个信号会被记录到进程的待处理信号队列中。</li>
<li><strong>向用户态传播</strong>：当进程被调度运行时，内核会检查该进程的待处理信号队列。如果有信号，内核会<strong>中断该进程的正常执行流程</strong>，并将控制权交给事先注册的信号处理程序（handler）。
<ul>
<li>如果进程注册了信号处理程序（handler），那么信号处理程序会在用户态被执行，处理这个异常。</li>
<li>如果没有设置处理程序，系统会终止进程并生成一个core dump（进程崩溃时的内存转储）。</li>
</ul>
</li>
</ol>
</li>
<li>
<p>在这个过程中，进程是trap，然后进入trampoline，存好上下文，进入内核，然后又从内核回到用户空间，执行handler吗？这个handler怎么有权限更改PTE的？</p>
<p>是的，你描述的过程基本正确。以下是详细的解释：</p>
<ol>
<li>
<p><strong>处理过程</strong>：</p>
<ul>
<li><strong>trap发生</strong>：当用户进程尝试写入一个被标记为 <code>invalid</code> 或 <code>只读</code> 的页面时，CPU触发异常，进入内核态。</li>
<li><strong>进入trampoline代码</strong>：内核首先通过 <code>trampoline</code> 代码进入内核，并保存当前进程的上下文信息（如寄存器、程序计数器等）。在 <code>XV6</code> 系统中，这些信息会被存储在 <code>trapframe</code> 结构中。</li>
<li><strong>查询虚拟内存系统</strong>：内核的trap handler会查看页面表（PTE），以及与虚拟内存相关的其他数据结构（如VMA，虚拟内存区域）。根据这些信息，内核决定接下来如何处理。
<ul>
<li><strong>如果是合法的页面缺失（Page Fault）</strong>，可能会分配一个新的页面或执行 <code>Copy-on-Write</code> 机制。</li>
<li><strong>如果是段错误（segfault）</strong>，内核会发送 <code>SIGSEGV</code> 信号给用户进程。</li>
</ul>
</li>
<li><strong>信号处理机制</strong>：如果用户程序设置了 <code>SIGSEGV</code> 信号的处理程序，内核会通过一种机制称为 <strong>upcall</strong>（上行调用）返回到用户态，让用户进程执行该信号处理函数（handler）。这是通过修改 <code>trapframe</code> 中保存的上下文来完成的，修改的内容包括将程序计数器（PC）指向用户态的 <code>handler</code> 地址。</li>
</ul>
</li>
<li>
<p><strong>handler修改PTE的权限</strong>：</p>
<p>信号处理函数（handler）可以调用系统提供的接口来修改 PTE（页表项）。具体来说，虽然用户态程序无法直接操作页表，但它可以通过系统调用来间接修改页表。比如：</p>
<ul>
<li><strong>调用 <code>mprotect</code></strong>：<code>mprotect</code> 是一个系统调用，允许用户程序请求内核修改特定页面的访问权限。通过调用 <code>mprotect</code>，用户可以请求将某些页面的权限从只读修改为可写，或从无效状态修改为有效状态。</li>
</ul>
<p>当 <code>handler</code> 中调用 <code>mprotect</code> 时，控制权会再次转交给内核，由内核负责对页表进行修改。内核可以直接操作 PTE，将其修改为新的权限配置（例如将页面从只读修改为可写）。这并不是用户态程序直接更改 PTE，而是通过系统调用请求内核来完成修改。</p>
</li>
<li>
<p><strong>内核恢复进程的执行</strong>：</p>
</li>
</ol>
<ul>
<li><strong>恢复上下文</strong>：<code>handler</code> 执行完毕后，控制权再次回到内核。内核会检查 <code>trapframe</code>，恢复之前保存的进程上下文，确保进程能够从上次中断的地方继续执行。</li>
<li><strong>继续执行原程序</strong>：如果 <code>handler</code> 成功修复了页面（例如通过调用 <code>mprotect</code> 修改了页面的权限），那么进程会从触发 <code>trap</code> 的指令处继续执行。如果地址空间依然有问题（例如 <code>handler</code> 没有正确处理），则进程会再次触发 <code>trap</code>。</li>
</ul>
</li>
</ol>
<p>所以，总的来说：</p>
<ol>
<li><strong>“segfault事件传播到用户空间”</strong> 是指通过信号机制，内核将 <code>segfault</code> 这个异常信息传递给用户态，用户态的 <code>handler</code> 处理程序可以在用户空间执行。</li>
<li><strong>进程从trap到trampoline再到用户空间</strong> 的确是一个循环的过程。<code>handler</code> 本身无法直接更改 PTE 的权限，但它可以通过系统调用（如 <code>mprotect</code>）向内核请求修改，最终由内核来执行 PTE 的更新操作。</li>
</ol>
<p>这种机制在性能和安全性之间取得了平衡：<strong>用户程序通过信号机制间接地影响页表内容，而页表的实际修改仍然由内核完成</strong>。</p>
</blockquote>
<blockquote>
<p>学生提问：当我们允许用户针对Page Fault来运行handler代码时，这不会引入安全漏洞吗？</p>
<p>Frans教授：这是个很好的问题。会有安全问题吗？你们怎么想的？这会破坏User/kernel或者不同进程之间的隔离性吗？或者从另一个角度来说，你的问题是sigalarm会破坏隔离性吗？</p>
<p>当我们执行upcall的时候，upcall会走到设置了handler的用户空间进程中，所以handler与设置了它的应用程序运行在相同的context，相同的Page Table中。</p>
<p>所以handler唯一能做的事情就是影响那个应用程序，并不能影响其他的应用程序，因为它不能访问其他应用程序的Page Table，或者切换到其他应用程序的Page Table。所以这里还好。</p>
<p>当然，如果handler没有返回，或者做了一些坏事，最终内核还是会杀掉进程。所以唯一可能出错的地方就是进程伤害了自己，但是它不能伤害任何其他进程。</p>
</blockquote>
<h2 id="构建大的缓存表">构建大的缓存表
</h2><p>接下来，我将通过介绍几个例子来看一下如何使用之前介绍的内容。</p>
<p>我会从一个非常简单的例子开始，之后我们会看一下Garbage Collector，因为很多同学都问了Garbage Collector的问题，所以GC是一个可以深入探讨的好话题。</p>
<p>首先我想讨论的是一个非常简单的应用，它甚至都没有在论文中提到，但它却是展示这节课的内容非常酷的一个方法。</p>
<p>这个应用里是构建一个大的缓存表，什么是缓存表？它是用来记录一些运算结果的表单。</p>
<p>举个例子，你可以这么想，下面是我们的表单，它从0开始到n。</p>
<p>表单记录的是一些费时的函数运算的结果，函数的参数就是0到n之间的数字。</p>
<p>如果这个表单在最开始的时候就预计算好了，那么当你想知道f(i)的结果是什么时，你需要做的就是查看表单的i槽位，并获取f(i)的值。</p>
<p>这样你可以将一个费时的函数运算转变成快速的表单查找，所以这里一个酷的技巧就是预先将费时的运算结果保存下来。如果相同的计算需要运行很多很多次，那么预计算或许是一个聪明的方案。</p>
<p>这里的挑战是，表单可能会很大，或许会大过物理内存，这里可以使用论文提到的虚拟内存特性来解决这个挑战。</p>
<p>首先，你需要分配一个大的虚拟地址段，但是并不分配任何物理内存到这个虚拟地址段。</p>
<p>这里只是从地址空间获取了很大一段地址，并说我将要使用地址空间的这部分来保存表单。</p>
<p>但是现在表单中并没有内容，表单只是一段内存地址。</p>
<p>如果你现在查找表单的i槽位，会导致Page Fault。</p>
<p>所以这里的计划是，在发生Page Fault时，先针对对应的虚拟内存地址分配物理内存Page，之后计算f(i)，并将结果存储于tb[i]，也就是表单的第i个槽位，最后再恢复程序的运行。</p>
<p>这种方式的优势是，如果你需要再次计算f(i)，你不需要在进行任何费时的计算，只需要进行表单查找。</p>
<p>即使接下来你要查找表单的i+1槽位，因为一个内存Page可能可以包含多个表单项，这时也不用通过Page Fault来分配物理内存Page。</p>
<p>不过如果你一直这么做的话，因为表单足够大，你最终还是会消耗掉所有的物理内存。</p>
<p>所以Page Fault Handler需要在消耗完所有的内存时，回收一些已经使用过的物理内存Page。</p>
<p>当然，你需要修改已经被回收了的物理内存对应的PTE的权限，这样在将来使用对应地址段时，就可以获得Page Fault。</p>
<p>所以你需要使用Prot1或者ProtN来减少这些Page的accessbility。</p>
<blockquote>
<p>学生提问：在分配物理内存Page时，我们需要让操作系统映射到地址空间的特定地址，否则的话可能会映射到任意地址，是吧？</p>
<p>Frans教授：操作系统会告知是哪个地址，并且这里可能是任意的地址。</p>
</blockquote>
<p>为了更具体的描述这里的应用，我这里有个小的实现，我们可以看一看这里是如何使用现有的Unix特性。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">page_size</span> <span class="o">=</span> <span class="nf">sysconf</span><span class="p">(</span><span class="n">_SC_PAGESIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;page_size is %ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">page_size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">setup_sqrt_region</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="nf">test_sqrt_region</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在main函数中，首先调用setup_sqrt_region函数，它会从地址空间分配地址段，但是又不实际分配物理Page。之后调用test_sqrt_region。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">test_sqrt_region</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">pos</span> <span class="o">=</span> <span class="nf">rand</span><span class="p">()</span><span class="o">%</span><span class="p">(</span><span class="n">MAX_SQRTS</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="kt">double</span> <span class="n">correct_sqrt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Validating square root table contents...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">srand</span> <span class="p">(</span><span class="mh">0xDEADBEEF</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">500000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="n">pos</span> <span class="o">=</span> <span class="nf">rand</span><span class="p">()</span><span class="o">%</span><span class="p">(</span><span class="n">MAX_SQRTS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">else</span>
</span></span><span class="line"><span class="cl">			<span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="nf">calculate_sqrts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">correct_sqrt</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">sqrts</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">!=</span> <span class="n">correct_sqrt</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">			<span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Square root is incorrect.Expected %f,got %f.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">correct_sqrt</span><span class="p">,</span> <span class="n">sqrts</span><span class="p">[</span><span class="n">pos</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">			<span class="nf">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;All tests passed!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在test_sqrt_region中，会以随机数来遍历表单，并通过实际运算对应的平方根值，来检查表单中相应位置值是不是保存了正确的平方根值。</p>
<p>在test_sqrt_region运行的过程中，会产生Page Fault，因为现在还并没有分配任何物理内存Page。</p>
<p>应用程序该如何收到Page Fault呢？</p>
<p><img src="/p/mit6s08117virtual-memory-for-applications/p30.png"
	width="800"
	height="622"
	srcset="/p/mit6s08117virtual-memory-for-applications/p30_hu8689687964618436358.png 480w, /p/mit6s08117virtual-memory-for-applications/p30_hu15381687237367237157.png 1024w"
	loading="lazy"
	
		alt="p30"
	
	
		class="gallery-image" 
		data-flex-grow="128"
		data-flex-basis="308px"
	
></p>
<p>在setup_sqrt_region函数中有一段代码，通过将handle_sigsegv函数注册到了SIGSEGV事件。</p>
<p>这样当segfault或者Page Fault发生时，内核会调用handle_sigsegv函数。</p>
<p><img src="/p/mit6s08117virtual-memory-for-applications/p31.png"
	width="750"
	height="452"
	srcset="/p/mit6s08117virtual-memory-for-applications/p31_hu12587021300830208574.png 480w, /p/mit6s08117virtual-memory-for-applications/p31_hu7924339075352379419.png 1024w"
	loading="lazy"
	
		alt="p31"
	
	
		class="gallery-image" 
		data-flex-grow="165"
		data-flex-basis="398px"
	
></p>
<p>handle_sigsegv函数与你们之前看过很多很多次的trap代码非常相似。</p>
<ul>
<li>它首先会获取触发Page Fault的地址，</li>
<li>之后调用mmap对这个虚拟内存地址分配一个物理内存Page（注，这里是mmap映射匿名内存）。这里的虚拟内存地址就是我们想要在表单中用来保存数据的地址。</li>
<li>然后我们为这个Page中所有的表单项都计算对应的平方根值，之后就完事了。</li>
</ul>
<p>这个应用程序有点极端，它在运行的时候只会使用一个物理内存Page，所以不论上一次使用的Page是什么，在handle_sigsegv的最后都会通过munmap释放它。</p>
<p>所以我们有一个巨大的表单，但是它只对应一个物理内存Page。</p>
<p>接下来我将运行一下这个应用程序。test_sqrt_region会随机查看表单的内容，所以可以假设这会触发很多Page Fault，但是可以看出表单中的所有内容都能通过检查。</p>
<p>所以，尽管这里有一个巨大的表单用来保存平方根，但是实际在物理内存中只有一个内存Page。</p>
<p>这是一个简单的例子，它展示了用户应用程序使用之前提到的虚拟内存特性之后可以做的一些酷的事情。</p>
<blockquote>
<p>学生提问：能再讲一下为什么一个物理内存Page就可以工作吗？我觉得这像是lazy allocation，但是区别又是什么呢？</p>
<p>Frans教授：当我们刚刚完成设置时，我们一个内存Page都没有，setup_sqrt_region分配了一个地址段，但是又立即通过munmap将与这个地址段关联的内存释放了。所以在启动的最开始对于表单并没有一个物理内存Page与之关联。</p>
<p>之后，当我们得到了一个Page Fault，这意味着整个表单对应的地址中至少有一个Page没有被映射，虽然实际上我们一个Page都没有映射。</p>
<p>现在我们得到了一个Page Fault，我们只需要映射一个Page，在这个Page中，我们会存入i，i+1。。。的平方根（注，因为一个Page4096字节，一个double8个字节，所以一个Page可以保存512个表单项）。</p>
<p>因为这是第一个Page Fault，之前并没有映射了内存Page，所以不需要做任何事情。</p>
<p>之后，程序继续运行并且查找了表单中的更多项，如果查找一个没有位于已分配Page上的表单项时，会得到另一个Page Fault。</p>
<p>这时，在handle_sigsegv会分配第二个内存Page，并为这个Page计算平方根的值。之后会munmap记录在last_page_base中的内存。</p>
</blockquote>
<h2 id="bakers-real-time-copying-garbage-collector">Baker&rsquo;s Real-Time Copying Garbage Collector
</h2><p>接下来我会讨论另一个例子，也就是Garbage Collector（注，后面将Garbage Collector和Garbage Collection都简称为GC），并且我也收到了很多有关Garbage Collector的问题。</p>
<p>GC是指编程语言替程序员完成内存释放，这样程序员就不用像在C语言中一样调用free来释放内存。</p>
<p>对于拥有GC的编程语言，程序员只需要调用类似malloc的函数来申请内存，但是又不需要担心释放内存的过程。</p>
<p>GC会决定内存是否还在使用，如果内存并没有被使用，那么GC会释放内存。</p>
<p>GC是一个很好的特性，有哪些编程语言带有GC呢？Java，Python，Golang，几乎除了C和Rust，其他所有的编程语言都带有GC。</p>
<p>你可以想象，GC有很大的设计空间。</p>
<p>这节课讨论的论文并没有说什么样的GC是最好的，它只是展示了GC可以利用用户空间虚拟内存特性。</p>
<p>论文中讨论了一种特定的GC，这是一种copying GC。什么是copying GC？假设你有一段内存作为heap，应用程序从其中申请内存。</p>
<p>你将这段内存分为两个空间，其中一个是from空间，另一个是to空间。</p>
<p>当程序刚刚启动的时候，所有的内存都是空闲的，应用程序会从from空间申请内存。假设我们申请了一个类似树的数据结构。</p>
<p>树的根节点中包含了一个指针指向另一个对象，这个对象和根节点又都包含了一个指针指向第三个对象，这里构成了一个循环。</p>
<p>或许应用程序在内存中还有其他对象，但是没有别的指针指向这些对象，所以所有仍然在使用的对象都可以从根节点访问到。</p>
<p>在某个时间，或许因为之前申请了大量的内存，已经没有内存空间给新对象了，也就是说整个from空间都被使用了。</p>
<p>Copying GC的基本思想是将仍然在使用的对象拷贝到to空间去，具体的流程是从根节点开始拷贝。</p>
<p>每一个应用程序都会在一系列的寄存器或者位于stack上的变量中保存所有对象的根节点指针，通常来说会存在多个根节点，但是为了说明的简单，我们假设只有一个根节点。</p>
<p>拷贝的流程会从根节点开始向下跟踪，所以最开始将根节点拷贝到了to空间，但是现在根节点中的指针还是指向着之前的对象。</p>
<p>之后，GC会扫描根节点对象。因为程序的运行时知道对象的类型是什么，当然也就知道对象中的指针。</p>
<p>接下来GC会将根节点对象中指针指向的对象也拷贝到to空间，很明显这些也是还在使用中的对象。</p>
<p>当一个对象被拷贝到to空间时，根节点中的指针会被更新到指向拷贝到了to空间的对象。</p>
<p>在之后的过程中，我们需要记住这个对象已经被拷贝过了。</p>
<p>所以，我们还会存储一些额外的信息来记住相应的对象已经保存在了to空间，这里会在from空间保留一个forwarding指针。</p>
<p>这里将对象从from空间拷贝到to空间的过程称为forward。</p>
<p>接下来还剩下一个对象，我们将这个对象从from空间拷贝到to空间，这个对象还包含一个指针指向第二个对象。</p>
<p>但是通过查看指针可以看到这个对象已经被拷贝了，并且我们已经知道了这个对象被拷贝到的地址（注，也就是之前在from空间留下的forwarding指针）。</p>
<p>所以我们可以直接更新第三个对象的指针到正确的地址。</p>
<p>现在与根节点相关的对象都从from空间移到了to空间，并且所有的指针都被正确的更新了，所以现在我们就完成了GC，from空间的所有对象都可以被丢弃，并且from空间现在变成了空闲区域。</p>
<p>论文中讨论的是一种更为复杂的GC算法，它被称为Baker算法，这是一种很老的算法。</p>
<p>它的一个优势是它是实时的，这意味着它是一种incremental GC（注，incremental GC是指GC并不是一次做完，而是分批分步骤完成）。</p>
<p>在Baker算法中，我们还是有from和to两个空间。假设其中还是包含了上面介绍的几个对象。</p>
<p>这里的基本思想是，GC的过程没有必要停止程序的运行并将所有的对象都从from空间拷贝到to空间，然后再恢复程序的运行。</p>
<p>GC开始之后，唯一必要的事情，就是将根节点拷贝到to空间。</p>
<p>所以现在根节点被拷贝了，但是根节点内的指针还是指向位于from空间的对象。</p>
<p>根节点只是被拷贝了并没有被扫描，其中的指针还没有被更新。</p>
<p>如果应用程序调用了new来申请内存，那就再扫描几个对象，并将这些对象从from空间forward到to空间。</p>
<p>这很好，因为现在我们将拷贝heap中还在使用的所有对象的过程，拆分成了渐进的步骤。</p>
<p>每一次调用new都使得整个拷贝过程向前进一步。</p>
<p>当然应用程序也会使用这里对象所指向的指针。</p>
<p>举个例子，现在当根节点需要读出其指向的一个对象时，这个对象仍然在from空间。这是危险的，因为我们不应该跟踪from空间的指针（注，换言之GC时的指针跟踪都应该只在同一个空间中完成）。</p>
<p>所以每次获取一个指针指向的对象时（dereference），你需要检查对象是否在在from空间，如果是的话，将其从from空间forward到to空间。</p>
<p>所以应用程序允许使用指针，但是编译器需要对每个指针的访问都包上一层检查，这样我们就可以保证在to空间的任何指针指向的是位于to空间的对象。</p>
<p>我们需要确保这一点，因为在最后当GC完成了所有对象的跟踪之后，我们会清空from部分并重用这部分内存。</p>
<p>论文对于这里的方案提出了两个问题：</p>
<ul>
<li>
<p>第一个是每次dereference都需要有以上的额外步骤，每次dereference不再是对于内存地址的单个load或者store指令，而是多个load或者store指令，这增加了应用程序的开销。</p>
</li>
<li>
<p>第二个问题是并不能容易并行运行GC。</p>
<p>如果程序运行在多核CPU的机器上，并且你拥有大量的空闲CPU，我们本来可以将GC运行在后台来遍历对象的图关系，并渐进的拷贝对象。</p>
<p>但是如果应用程序也在操作对象，那么这里可能会有抢占。应用程序或许在运行dereference检查并拷贝一个对象，而同时GC也在拷贝这个对象。</p>
<p>如果我们不够小心的话，我们可能会将对象拷贝两遍，并且最后指针指向的不是正确的位置。所以这里存在GC和应用程序race condition的可能。</p>
</li>
</ul>
<h2 id="使用虚拟内存特性的gc">使用虚拟内存特性的GC
</h2><p>论文中介绍，如果拥有了前面提到的虚拟内存特性，你可以使用虚拟内存来减少指针检查的损耗，并且以几乎零成本的代价来并行运行GC。</p>
<p>这里的基本思想是将heap内存中from和to空间，再做一次划分，每一个部分包含scanned，unscanned两个区域。</p>
<p>在程序启动，或者刚刚完成了from和to空间的切换时，整个空间都是unscanned，因为其中还没有任何对象。</p>
<p>之后的过程与前面描述的相同，在开始GC时，我们将根节点对象拷贝到to空间，但是根节点中的指针还是指向了位于from空间的对象。</p>
<p>现在unscanned区域包括了所有的对象（注，现在只有根节点），我们会将unscanned区域的权限设置为None。</p>
<p>这意味着，当开始GC之后，应用程序第一次使用根节点，它会得到Page Fault，因为这部分内存的权限为None。</p>
<p>在Page Fault Handler中，GC需要扫描位于内存Page中所有的对象，然后将这些对象所指向的其他对象从from空间forward到to空间。</p>
<p>所以，在GC最开始的时候，我们将根节点拷贝过来了；之后在Page Fault Handler中通过扫描，将根节点指向的对象也都拷贝过来了。</p>
<p>在我们的例子中根节点指向的只有两个对象，这两个对象会被拷贝到unscanned区域中，而根节点会被标记成scanned。</p>
<p>在我们扫描完一个内存Page中的对象时，我们可以通过Unprot（注，详见17.1）恢复对应内存Page的权限。</p>
<p>之后，应用程序就可以访问特定的对象，因为我们将对象中的指针转换成了可以安全暴露给应用程序的指针（注，因为这些指针现在指向了位于to空间的对象），所以应用程序可以访问这些指针。</p>
<p>当然这些指针对应的对象中还没有被扫描。如果dereference这些指针，我们会再次得到Page Fault，之后我们会继续扫描。</p>
<p>这种方案的好处是，它仍然是递增的GC，因为每次只需要做一小部分GC的工作。</p>
<p>除此之外，它还有额外的优势：现在不需要对指针做额外的检查了（注，也就是不需要查看指针是不是指向from空间，如果是的话，将其forward到to空间）。</p>
<p>或者说指针检查还在，只是现在通过虚拟内存相关的硬件来完成了。</p>
<blockquote>
<p>学生提问：刚刚说到在Handler里面会扫描一个Page中的所有对象，但是对象怎么跟内存Page对应起来呢？</p>
<p>Frans教授：在最开始的时候，to空间是没有任何对象的。</p>
<p>当需要forward的时候，我刚刚描述的是拷贝一个对象，但是实际上拷贝的是一个内存Page中的N个对象，这样它们可以填满整个Page。</p>
<p>所以现在我们在to空间中，有N个对象位于一个Page中，并且它们都没有被扫描。</p>
<p>之后某个时间，Page Fault Handler会被调用，GC会遍历这个内存Page上的N个对象，并检查它们的指针。</p>
<p>对于这些指针，GC会将对应的对象拷贝到to空间的unscanned区域中。</p>
<p>之后，当应用程序使用了这些未被扫描的对象，它会再次得到Page Fault，进而再扫描这些对象，以此类推。</p>
<p>学生提问：在完成了GC之后，会切换from和to空间吗？</p>
<p>Frans教授：最开始我们使用的是from空间，当用完了的时候，你会将对象拷贝到to空间，一旦完成了扫描，from空间也被完全清空了，你可以切换两个空间的名字。现在会使用to空间来完成内存分配。直到它也满了，你会再次切换。</p>
</blockquote>
<blockquote>
<p>在理解 <code>to</code> 空间的 <strong>unscanned 区域</strong>时，首先要明确 <code>to</code> 空间的作用及其与 <code>from</code> 空间的关系。这通常涉及到一种叫做 <strong>半空间垃圾回收算法</strong>（或称 <strong>复制收集算法</strong>），其中内存被划分为两个区域：<code>from</code> 空间和 <code>to</code> 空间。</p>
<p>在复制收集算法中：</p>
<ul>
<li><strong>From 空间</strong>：存放当前所有正在使用的对象。</li>
<li><strong>To 空间</strong>：在垃圾回收过程中，用于接收从 <code>from</code> 空间拷贝过来的活动对象（即被引用的对象）。</li>
</ul>
<p><code>to</code> 空间的 <strong>unscanned 区域</strong> 是指<strong>尚未被扫描的对象区域</strong>。当垃圾回收（GC）开始时，<code>to</code> 空间为空。GC 会将所有活动对象从 <code>from</code> 空间拷贝到 <code>to</code> 空间，并将这些对象放入 <code>unscanned 区域</code>。</p>
<ul>
<li><strong>一旦对象被拷贝到 <code>to</code> 空间，它就会被标记为未扫描（unscanned）</strong>。</li>
<li>随后，GC 会依次扫描 <code>to</code> 空间中的对象。扫描的过程中，GC 会查看这些对象的指针，如果指针引用了其他对象，就将这些对象也拷贝到 <code>to</code> 空间。</li>
<li><strong>每次扫描时，未被扫描的对象会被移出 unscanned 区域</strong>。这样，可以确保所有活动对象都被处理到，而不活动（垃圾）对象则被丢弃。</li>
</ul>
<p>Frans 教授提到“拷贝的是一个内存 Page 中的多个对象”，这是为了提高效率。在分页（Paging）机制下：</p>
<ul>
<li>系统通常会按页（Page）为单位处理内存，而非单个对象。</li>
<li>这意味着，在需要时，GC 会一次性地将整个页中的多个对象拷贝到 <code>to</code> 空间。这是因为单次页内存的映射和传输速度要比逐个拷贝对象更快。</li>
<li>当 GC 将整个页面中的对象拷贝到 <code>to</code> 空间时，它们可以填满整个页，避免频繁的页内存操作和碎片化问题。</li>
</ul>
<p>在复制过程中，<strong>只拷贝活动对象</strong>。垃圾回收器通过对象的引用关系来判断哪些对象是活动的，哪些对象是垃圾：</p>
<ul>
<li>从 <code>from</code> 空间拷贝对象到 <code>to</code> 空间时，GC 只处理那些仍然被程序引用的对象。这些对象是通过扫描根对象引用链找到的，而不活动的对象（没有被引用）不会被拷贝。</li>
<li>所以，即使是一个页面中的部分对象是垃圾，GC 也不会将这些垃圾对象拷贝到 <code>to</code> 空间。</li>
</ul>
<p>在垃圾回收完成后：</p>
<ul>
<li><code>from</code> 空间中原有的对象会被标记为可以回收。此时，<code>to</code> 空间中的对象成为新的活动对象集。</li>
<li><strong>空间交换</strong>：<code>from</code> 和 <code>to</code> 空间交换角色。原来的 <code>to</code> 空间变为新的 <code>from</code> 空间，用于分配和存放新对象；原来的 <code>from</code> 空间则被完全清空，作为下一次 GC 的目标。</li>
</ul>
<p>在垃圾回收过程中，<code>to</code> 空间的 <code>unscanned</code> 区域存放的是<strong>从 <code>from</code> 空间拷贝过来的</strong>、<strong>尚未被扫描的活动对象</strong>。通过扫描这些对象，GC 可以递归地找到并拷贝其他活动对象，避免将垃圾对象转移到 <code>to</code> 空间。这样可以保证 <code>to</code> 空间在完成后只包含当前的活动对象，垃圾被完全丢弃在 <code>from</code> 空间中等待清空。</p>
</blockquote>
<p>论文中提到使用虚拟内存的另一个好处是，它简化了GC的并发。</p>
<p>GC现在可以遍历未被扫描的内存Page，并且一次扫描一个Page，同时可以确保应用程序不能访问这个内存Page，因为对于应用程序来说，未被扫描的内存Page权限为None。</p>
<p>虚拟内存硬件引入了这种显式的同步机制，或者说对于抢占的保护。</p>
<p>现在只有GC可以访问未被扫描的内存Page，而应用程序不能访问。</p>
<p>所以这里提供了自动的并发，应用程序可以运行并完成它的工作，GC也可以完成自己的工作，它们不会互相得罪，因为一旦应用程序访问了一个未被扫描的Page，它就会得到一个Page Fault。</p>
<p>而GC也永远不会访问扫描过的Page，所以也永远不会干扰到应用程序。所以这里以近乎零成本获取到了并发性。</p>
<p>但是实际上有个麻烦的问题。回到我们之前那张图，我们在heap中有from空间，to空间。在to空间中又分为了unscanned和scanned区域，对于应用程序来说，unscanned区域中的Page权限为None。</p>
<p>这就引出了另一个问题，GC怎么能访问这个区域的内存Page？因为对于应用程序来说，这些Page是inaccessible。</p>
<p>这里的技巧是使用map2（注，详见17.1）。</p>
<p>这里我们会将同一个物理内存映射两次，第一次是我们之前介绍的方式，也就是为应用程序进行映射，第二次专门为GC映射。</p>
<p>在GC的视角中，我们仍然有from和to空间。在to空间的unscanned区域中，Page具有读写权限。</p>
<p>所以GC可以遍历这些内存Page，读取内容并forward必要的对象。</p>
<p>这里使用了map2将物理内存映射到应用程序地址空间中两次的能力，其中每次映射都有不同的权限，这样这里的场景才能工作。</p>
<blockquote>
<p>学生提问：GC和应用程序是不是有不同的Page Table？</p>
<p>Frans教授：不，它们拥有相同的Page Table。它们只是将物理内存映射到了地址空间的两个位置，也就是Page Table的两个位置。在一个位置，PTE被标记成invalid，在另一个位置，PTE被标记成可读写的。</p>
</blockquote>
<h2 id="使用虚拟内存特性的gc代码展示">使用虚拟内存特性的GC代码展示
</h2><p>为了更清晰的说明上一节的内容，我这里有个针对论文中方法的简单实现，我可以肯定它包含了一些bug，因为我并没有认真的测试它。</p>
<p>首先，应用程序使用的API包括了new和readptr。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">//API to collector
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">elem</span> <span class="o">*</span><span class="nf">readptr</span><span class="p">(</span><span class="k">struct</span> <span class="n">elem</span> <span class="o">**</span><span class="n">ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">elem</span> <span class="o">*</span><span class="nf">new</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>readptr会检查指针是否位于from空间，如果是的话，那么它指向的对象需要被拷贝。</p>
<p>当然，当我们使用虚拟内存时，这里的readptr成本会比较低，它会直接返回参数。</p>
<p>在这个简单的例子中，我有一个循环链表，并且有两个根节点，其中一个指向链表的头节点，另一个指向链表的尾节点。</p>
<p>应用程序线程的工作是循环1000次，每次创建list，再检查list。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">app_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1000</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">make_clist</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">		<span class="nf">check_clist</span><span class="p">(</span><span class="n">LISTSZ</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>所以它会产生大量的垃圾，因为每次make_clist完成之后，再次make_clist，上一个list就成为垃圾了。所以GC必然会有一些工作要做。</p>
<p>make_clist的代码有点丑，主要是因为每个指针都需要被readptr检查包围。</p>
<p>通常这里的检查代码是由编译器生成的。</p>
<p>但是我这里并没有一个针对带GC的编程语言的编译器，所以我只能模仿一个编译器可能生成的内容。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">make_clist</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">elem</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">root</span> <span class="n">head</span> <span class="o">=</span> <span class="nf">new</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="nf">readptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_head</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="nf">readptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_head</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nf">readptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_head</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">root_last</span> <span class="o">=</span> <span class="nf">readptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_head</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">LISTSZ</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="n">e</span> <span class="o">=</span> <span class="nf">new</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">		<span class="nf">readptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nf">readptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_head</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="nf">readptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">root_head</span> <span class="o">=</span> <span class="nf">readptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="nf">readptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_last</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nf">readptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_head</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="nf">check_clist</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>make_clist会构建一个LISTSZ大小的链表，分配新的元素，并将新元素加到链表的起始位置，之后更新链表尾指针指向链表新的起始位置，这样就能构成一个循环链表。</p>
<p>这里更有趣的部分是，GC部分怎么实现。</p>
<p>首先让我们看看如果没有虚拟内存会怎样。我们只需要查看两个API：new和readptr。</p>
<p><img src="/p/mit6s08117virtual-memory-for-applications/p32.png"
	width="594"
	height="370"
	srcset="/p/mit6s08117virtual-memory-for-applications/p32_hu17105423584646106132.png 480w, /p/mit6s08117virtual-memory-for-applications/p32_hu12474184965734027237.png 1024w"
	loading="lazy"
	
		alt="p32"
	
	
		class="gallery-image" 
		data-flex-grow="160"
		data-flex-basis="385px"
	
></p>
<p>以上就是new的实现，先不考虑这里的mutex，因为这是为基于虚拟内存的实现提供的。</p>
<p>先假设我们不需要扫描，也不需要collect。</p>
<p>接下来会检查是否有足够的空间，如果有足够的空间，我们就将指针地址增加一些，以分配内存空间给新的对象，最后返回。</p>
<p>如果没有足够的空间，我们需要调用flip，也就是运行GC。</p>
<p><img src="/p/mit6s08117virtual-memory-for-applications/p33.png"
	width="692"
	height="554"
	srcset="/p/mit6s08117virtual-memory-for-applications/p33_hu16898069880985445187.png 480w, /p/mit6s08117virtual-memory-for-applications/p33_hu3940753797790679317.png 1024w"
	loading="lazy"
	
		alt="p33"
	
	
		class="gallery-image" 
		data-flex-grow="124"
		data-flex-basis="299px"
	
></p>
<p>flip首先会切换from和to指针，之后将这个应用程序的两个根节点从from空间forward到to空间。接下来我们看一下forward函数。</p>
<p><img src="/p/mit6s08117virtual-memory-for-applications/p34.png"
	width="716"
	height="394"
	srcset="/p/mit6s08117virtual-memory-for-applications/p34_hu6363137880725121647.png 480w, /p/mit6s08117virtual-memory-for-applications/p34_hu11552956348787182468.png 1024w"
	loading="lazy"
	
		alt="p34"
	
	
		class="gallery-image" 
		data-flex-grow="181"
		data-flex-basis="436px"
	
></p>
<p>这个函数会forward指针o指向的对象，首先检查指针o是不是在from空间，如果是的话，并且之前没有被拷贝过，那么就将它拷贝到to空间。</p>
<p>如果之前拷贝过，那么就可以用to空间的指针代替对象指针，并将其返回。</p>
<p><img src="/p/mit6s08117virtual-memory-for-applications/p35.png"
	width="644"
	height="254"
	srcset="/p/mit6s08117virtual-memory-for-applications/p35_hu3053779400168255817.png 480w, /p/mit6s08117virtual-memory-for-applications/p35_hu137529026090888139.png 1024w"
	loading="lazy"
	
		alt="p35"
	
	
		class="gallery-image" 
		data-flex-grow="253"
		data-flex-basis="608px"
	
></p>
<p>对于readptr，如果我们没有使用虚拟内存。</p>
<p>会对指针p做forward操作，forward操作的意思是如果对象在from空间，那么就将其拷贝到to空间，所以这里会有耗时的检查。</p>
<p>接下来我们看一下这里如何使用虚拟内存。</p>
<p><img src="/p/mit6s08117virtual-memory-for-applications/p36.png"
	width="1145"
	height="1227"
	srcset="/p/mit6s08117virtual-memory-for-applications/p36_hu4063919198517707276.png 480w, /p/mit6s08117virtual-memory-for-applications/p36_hu10121875604825681120.png 1024w"
	loading="lazy"
	
		alt="p36"
	
	
		class="gallery-image" 
		data-flex-grow="93"
		data-flex-basis="223px"
	
></p>
<p>首先是设置内存，通过<a class="link" href="https://man7.org/linux/man-pages/man3/shm_open.3.html"  target="_blank" rel="noopener"
    >shm_open</a>

创建一个Share-memory object，shm_open是一个Linux/Uinx系统调用。Share-memory object表现的像是一个文件，但是它并不是一个文件，它位于内存，并没有磁盘文件与之对应，如果你愿意的话，可以认为它是一个位于内存的文件系统。</p>
<p>之后我们裁剪这个Shared-memory object到from和to空间的大小。</p>
<p>之后我们通过mmap先将其映射一次，以供mutator也就是实际的应用程序使用。然后再映射一次，以供GC使用。这里shm_open，ftruncate，和两次mmap，等效于map2。</p>
<p>回过去看之前的代码，</p>
<p><img src="/p/mit6s08117virtual-memory-for-applications/p35.png"
	width="644"
	height="254"
	srcset="/p/mit6s08117virtual-memory-for-applications/p35_hu3053779400168255817.png 480w, /p/mit6s08117virtual-memory-for-applications/p35_hu137529026090888139.png 1024w"
	loading="lazy"
	
		alt="p35"
	
	
		class="gallery-image" 
		data-flex-grow="253"
		data-flex-basis="608px"
	
></p>
<p>使用了虚拟内存之后，readptr将不做任何事情，直接将参数返回。</p>
<p>当然，如果我们使用这里的指针，并且指针对应的对象位于unscanned区域，我们会得到Page Fault。</p>
<p><img src="/p/mit6s08117virtual-memory-for-applications/p37.png"
	width="768"
	height="354"
	srcset="/p/mit6s08117virtual-memory-for-applications/p37_hu10110572656905954947.png 480w, /p/mit6s08117virtual-memory-for-applications/p37_hu3546012909068055607.png 1024w"
	loading="lazy"
	
		alt="p37"
	
	
		class="gallery-image" 
		data-flex-grow="216"
		data-flex-basis="520px"
	
></p>
<p>在Page Fault hanlder中，GC会运行scan函数。</p>
<p>但是scan函数是以GC对应的PTE来运行的，所以它能工作。</p>
<p>而同时，应用程序或者mutator不能访问这些Page，如果访问了的话，这会产生Page Fault。</p>
<p>一旦scan执行完成，handler中会将Page设置成对应用程序可访问的（注，也就是调用mprotect）。</p>
<p>在flip函数中，</p>
<p><img src="/p/mit6s08117virtual-memory-for-applications/p38.png"
	width="692"
	height="554"
	srcset="/p/mit6s08117virtual-memory-for-applications/p38_hu16898069880985445187.png 480w, /p/mit6s08117virtual-memory-for-applications/p38_hu3940753797790679317.png 1024w"
	loading="lazy"
	
		alt="p38"
	
	
		class="gallery-image" 
		data-flex-grow="124"
		data-flex-basis="299px"
	
></p>
<p>完成from和to空间的切换时，如果使用了虚拟内存，我们会通过mprotect将整个to空间对应用程序标记成不可访问的。</p>
<p>之后GC将root_head和root_last移到to空间中，这样应用程序就不能访问这两个对象，任何时候应用程序需要访问这两个对象，都会导致一个Page Fault。</p>
<p>在Page Fault handler中，GC可以将其他对象从from空间拷贝到to空间，然后再Unprot对应的Page。</p>
<p>在Page Fault handler中，先scan内存Page，再将内存Page标记成对应用程序可访问的这个顺序是至关重要的。</p>
<p>因为如果你先将内存Page标记成应用程序可访问的，然后再扫描它，如果有多个应用程序线程，那么应用程序可能会查看到unscanned区域的对象。</p>
<p>当然我们要禁止这一点（注，因为为了避免抢占，unscanned区域只能GC访问），所以这里的代码是先扫描，再增加内存的访问权限，这样应用程序就可以安全的访问这些内存Page。</p>
<p>接下来，我总结一下这节课的内容。有一个问题，你应该在这里使用虚拟内存吗？或者说这里的这些技巧值得吗？</p>
<p>许多的GC并没有使用虚拟内存，而是通过编译器生成的代码来完成GC，并且还有各种其他的技巧来减少性能损耗。所以GC的大部分场景都可以通过一些额外的指令来完成。</p>
<p>这对于一个编译器，程序运行时，或者编程语言来说，并不是一个太糟糕的选择，因为编译器就可以完成这些操作。</p>
<p>但是如果没有程序运行时或者编译器，那么这个过程就会很痛苦。所以对于一些完全没有编译器参与的应用程序，例如checkpointing，shared-virtual memory，它们的确需要这里提到的虚拟内存特性。</p>
<p>实际中，足够多的应用程序开发人员发现了这些特性的价值，所以今天的操作系统都支持了这些虚拟内存特性。</p>
<p>很多人问了这个问题，从91年（论文发表的年份）至今，虚拟内存系统发生了什么改变？其中一个改变是，大部分的Unix系统都支持了这些虚拟内存特性了，并且从91年至今有许多变化。</p>
<p>或许很难想象，但是在虚拟内存系统中有持续的开发，所以如果你查看Linux的git log，你可以发现在内核的各个方面都有持续的开发，其中包括了对虚拟内存系统的持续开发。在过去有一些重大的改变，比如说：</p>
<ul>
<li>现在的Page Table是5级的，这样可以处理非常大的地址</li>
<li>可以通过地址空间标识符来处理TLB flush</li>
<li>大概一年前，一种叫做KPTI（kernel page table isolation）的功能被引入，它是针对Meltdown attack的功能</li>
</ul>
<p>虚拟内存系统绝对不是一个静态的系统，几乎Linux内核的所有方向都不是静态的。</p>
<p>几乎每两个月在内核的不同方向都会有大量的更新。所以每个子系统时不时的就会被重写。</p>
<blockquote>
<p>学生提问：VMA中的连续地址是什么意思？</p>
<p>Frans教授：这里是指连续的虚拟内存地址，比如说一个VMA表示1000-2000这段地址。如果你有另一段地址，2100-2200，那么它会有属于自己的VMA。所以每个VMA覆盖了一段连续的地址，中间不会有中断。你们将会在mmap lab中看到这样的设计是更加的合理的。你们可以认为对于每个mmap系统调用，如果地址没有重叠的话，都会有一个VMA。</p>
<p>学生提问：GC什么时候会停止，什么时候又会再开始？我认为GC可以一直运行，如果它是并发的。</p>
<p>Frans教授：是的，基于虚拟内存的解决方案一个酷的地方在于，GC可以一直运行。它可以在没有unscanned对象时停止。</p>
<p>学生提问：但是你需要遍历所有在from空间的对象，你怎么知道已经遍历了所有的对象呢？</p>
<p>Frans教授：你会从根节点开始扫描整个对象的图，然后拷贝到to空间。在某个时间点，你不再添加新的对象了，因为所有的对象已经被拷贝过了。当你不再添加新的对象，你的unscanned区域就不再增长，如果它不再增长，那么你就遍历了所有的对象（注，可以想象一个普通的DFS或者BFS过程）。</p>
</blockquote>

</section>


    <footer class="article-footer">
    

    <section class="article-lastmod">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <span>
            最后更新于 Nov 13, 2024 17:04 &#43;0800
        </span>
    </section></footer>




    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI&#43;WdtXRGWt2kTvGFasHpSy3SV"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG&#43;vnGctmUb0ZY0l8"crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05"crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.body, {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>
    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="has-image">
    <a href="/p/mit6s08123rcu/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08123rcu/bg.91a08bf3fe0a8ca435e8fbc902291fd5_hu4589796922609635382.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：23RCU"
                        
                        data-hash="md5-kaCL8/4KjKQ16PvJAikf1Q==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：23RCU</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/mit6s08122meltdown/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08122meltdown/19.8d880549dccba2f0c1613b3e41a721e5_hu3753156070077914420.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：22Meltdown"
                        
                        data-hash="md5-jYgFSdzLovDBYTs&#43;Qach5Q==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：22Meltdown</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/mit6s08121networking/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08121networking/bg.68c4376fd87b0b35da07319dd155c90d_hu10351534106733688476.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：21Networking"
                        
                        data-hash="md5-aMQ3b9h7CzXaBzGd0VXJDQ==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：21Networking</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/mit6s08120kernels-and-hll/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08120kernels-and-hll/bg.4175e6a2793e0fc340e5aced2529e40b_hu6405785273338381617.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：20Kernels and HLL"
                        
                        data-hash="md5-QXXmonk&#43;D8NA5aztJSnkCw==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：20Kernels and HLL</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/mit6s08119virtual-machines/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08119virtual-machines/bg.b02a7ba1d946705c0cf2809bcf960db8_hu14546491865979434532.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：19Virtual Machines  "
                        
                        data-hash="md5-sCp7odlGcFwM8oCbz5YNuA==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：19Virtual Machines  </h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    

    <footer class="site-footer">

    <section class="copyright">
        &copy; 
        
        2024 echudet
    </section>
    
    <section class="powerby">
        


        <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>

        <script language="javascript"> 
            var now = new Date();
            function createtime(){
                now.setTime(now.getTime()+250);
                var grt= new Date("2024/11/10 00:00:00"); 
                days = (now - grt ) / 1000 / 60 / 60 / 24;
                dnum = Math.floor(days);
                hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
                hnum = Math.floor(hours);
                if(String(hnum).length ==1 ){hnum = "0" + hnum;}
                minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
                mnum = Math.floor(minutes);
                if(String(mnum).length ==1 ){mnum = "0" + mnum;}
                seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
                snum = Math.round(seconds);
                if(String(snum).length ==1 ){snum = "0" + snum;}

                document.getElementById("timeDate").innerHTML = "本站已稳定运行"+dnum+" 天 ";
                document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒<br>"
            }
            setInterval("createtime()",250); 
        </script> 

        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        
    
        
         
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
        

        共 747479 字 , 35 篇文章<br>使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.29.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>

</footer>



    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>


    </body>
</html>
