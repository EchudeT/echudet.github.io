<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="在网络协议栈中，接收活锁（Receive Livelock）是一个重要的问题，这是在高流量条件下系统因频繁处理中断而陷入的性能瓶颈现象。为了解决这一问题，采用轮询机制代替传统中断驱动，以减少高负载下的中断频率，能够提高系统性能的稳定性。此外，网卡的Ring Buffer 结构和 DMA 传输机制有助于数据包在网卡与系统内存之间高效传输。">
<title>MIT6S081：21Networking</title>

<link rel='canonical' href='https://echudet.github.io/p/mit6s08121networking/'>

<link rel="stylesheet" href="/scss/style.min.86fc5e5efb829fb1bdd7a2d2275017fb3ae01ba7fcf491e347d76495ae5e3ae2.css"><meta property='og:title' content="MIT6S081：21Networking">
<meta property='og:description' content="在网络协议栈中，接收活锁（Receive Livelock）是一个重要的问题，这是在高流量条件下系统因频繁处理中断而陷入的性能瓶颈现象。为了解决这一问题，采用轮询机制代替传统中断驱动，以减少高负载下的中断频率，能够提高系统性能的稳定性。此外，网卡的Ring Buffer 结构和 DMA 传输机制有助于数据包在网卡与系统内存之间高效传输。">
<meta property='og:url' content='https://echudet.github.io/p/mit6s08121networking/'>
<meta property='og:site_name' content='echudet'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2024-10-06T22:02:50&#43;08:00'/><meta property='article:modified_time' content='2024-11-13T17:04:51&#43;08:00'/><meta property='og:image' content='https://echudet.github.io/p/mit6s08121networking/bg.jpg' />
<meta name="twitter:title" content="MIT6S081：21Networking">
<meta name="twitter:description" content="在网络协议栈中，接收活锁（Receive Livelock）是一个重要的问题，这是在高流量条件下系统因频繁处理中断而陷入的性能瓶颈现象。为了解决这一问题，采用轮询机制代替传统中断驱动，以减少高负载下的中断频率，能够提高系统性能的稳定性。此外，网卡的Ring Buffer 结构和 DMA 传输机制有助于数据包在网卡与系统内存之间高效传输。"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://echudet.github.io/p/mit6s08121networking/bg.jpg' />
    <link rel="shortcut icon" href="/timer.ico" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu11199958555974308744.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">⌨️</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">echudet</a></h1>
            <h2 class="site-description">探索编程的学生一枚</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/EchudeT'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://twitter.com'
                        target="_blank"
                        title="Twitter"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>档案</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>Links</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#课前预习">课前预习</a></li>
    <li><a href="#论文速览">论文速览</a></li>
    <li><a href="#feedback">feedback</a></li>
    <li><a href="#操作系统的网络功能">操作系统的网络功能</a></li>
    <li><a href="#livelock">Livelock</a></li>
    <li><a href="#receive-livelock">Receive Livelock</a></li>
    <li><a href="#正课部分">正课部分</a></li>
    <li><a href="#计算机网络概述">计算机网络概述</a></li>
    <li><a href="#二层网络-----ethernet">二层网络 &mdash; Ethernet</a></li>
    <li><a href="#二三层地址转换-----arp">二/三层地址转换 &mdash; ARP</a></li>
    <li><a href="#三层网络-----internet">三层网络 &mdash; Internet</a></li>
    <li><a href="#四层网络-----udp">四层网络 &mdash; UDP</a></li>
    <li><a href="#网络协议栈network-stack">网络协议栈（Network Stack）</a></li>
    <li><a href="#ring-buffer">Ring Buffer</a></li>
    <li><a href="#receive-livelock-1">Receive Livelock</a></li>
    <li><a href="#如何解决livelock">如何解决Livelock</a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/mit6s08121networking/">
                <img src="/p/mit6s08121networking/bg_hu2737504911594360117.jpg"
                        srcset="/p/mit6s08121networking/bg_hu2737504911594360117.jpg 800w, /p/mit6s08121networking/bg_hu15193076252142331852.jpg 1600w"
                        width="800" 
                        height="567" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：21Networking" />
                
            </a>
        </div>
    

    <div class="article-details">


    
    <header class="article-category">
        
            <a href="/categories/mit6s081/" >
                Mit6s081
            </a>
        
            <a href="/categories/os/" >
                Os
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/mit6s08121networking/">MIT6S081：21Networking</a>
        </h2>
    
        
        <h3 class="article-subtitle">
            在网络协议栈中，接收活锁（Receive Livelock）是一个重要的问题，这是在高流量条件下系统因频繁处理中断而陷入的性能瓶颈现象。为了解决这一问题，采用轮询机制代替传统中断驱动，以减少高负载下的中断频率，能够提高系统性能的稳定性。此外，网卡的Ring Buffer 结构和 DMA 传输机制有助于数据包在网卡与系统内存之间高效传输。
        </h3>
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2024-10-06</time>
            </div>
        

        
            <div>
                <?xml version="1.0" encoding="iso-8859-1"?>
<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="792px" height="792px" viewBox="0 0 792 792" style="enable-background:new 0 0 792 792;" xml:space="preserve">
<g>
	<g id="_x31_0_19_">
		<g>
			<path d="M643.5,742.5H594V569.25C594,473.566,516.434,396,420.75,396C516.434,396,594,318.434,594,222.75V49.5h49.5
				c13.662,0,24.75-11.088,24.75-24.75S657.162,0,643.5,0h-495c-13.662,0-24.75,11.088-24.75,24.75S134.838,49.5,148.5,49.5H198
				v173.25C198,318.434,275.566,396,371.25,396C275.566,396,198,473.566,198,569.25V742.5h-49.5c-13.662,0-24.75,11.088-24.75,24.75
				S134.838,792,148.5,792h495c13.662,0,24.75-11.088,24.75-24.75S657.162,742.5,643.5,742.5z M247.5,222.75
				c0-43.387,0-173.25,0-173.25h297c0,0,0,133.427,0,173.25c0,68.335-58.188,123.75-129.938,123.75h-37.125
				C305.687,346.5,247.5,291.085,247.5,222.75z M544.5,742.5h-297c0,0,0-129.888,0-173.25c0-68.335,58.187-123.75,129.938-123.75
				h37.125c71.75,0,129.938,55.415,129.938,123.75C544.5,609.072,544.5,742.5,544.5,742.5z"/>
		</g>
	</g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
</svg>

                <time class="article-time--reading">
                    阅读时长: 53 分钟
                </time>
            </div>
        

         
        <div>
            <?xml version="1.0" encoding="iso-8859-1"?>
<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="79.536px" height="79.536px" viewBox="0 0 79.536 79.536" style="enable-background:new 0 0 79.536 79.536;"
	 xml:space="preserve">
<g>
	<path style="fill:#010002;" d="M40.162,17.906C37.415,15.275,21.614,6.141,0,15.451c0,0.138,0,2.722,0,6.654v44.418h32.747
		c1.126,0.968,3.798,1.651,6.926,1.651c3.119,0,5.802-0.684,6.931-1.651h32.933V22.105c0-3.933,0-6.517,0-6.654
		C58.813,6.314,42.257,15.982,40.162,17.906z M37.229,63.349c0-1.75-15.372-11.981-33.125-0.818V19.216
		c3.516-2.014,8.246-3.249,13.463-3.249c10.864,0,19.662,3.562,19.662,10.175V63.349z M75.684,62.53
		c-17.751-11.163-33.108-0.932-33.108,0.818V26.146c0-6.612,8.792-10.175,19.646-10.175c5.22,0,9.952,1.235,13.463,3.249V62.53z"/>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
</svg>

            <time class="article-words">
                文章字数：26291字
            </time>
        </div>
        <div class="article-lastmod">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time>
                    Nov 13, 2024 17:04 &#43;0800
                </time>
            </div></footer>
    

    




    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="lecture-21-networking">Lecture 21 Networking
</h1><h2 id="课前预习">课前预习
</h2><h2 id="论文速览">论文速览
</h2><p>论文《Eliminating Receive Livelock in an Interrupt-driven Kernel》分为多个部分，每部分都有其核心内容，以下是各部分的详细总结：</p>
<p>在引言（Introduction）部分首先介绍了接收活锁（receive livelock）问题。传统的中断机制适用于早期的流量控制系统，但在面对现代非流量控制协议（如多媒体和RPC客户端-服务器系统）时，这种机制容易导致活锁问题。接收活锁是指系统在处理中断时耗尽所有资源，却无法执行其他关键任务，从而使系统进程停滞。</p>
<p>在激励应用（Motivating Applications）部分，作者提供了几种容易受到活锁影响的应用示例：</p>
<ul>
<li><strong>基于主机的路由（Host-based Routing）</strong>：许多现代路由器在面对非流量控制的高负载流量时，容易陷入活锁状态。</li>
<li><strong>被动网络监控（Passive Network Monitoring）</strong>：处于混杂模式的网络接口在监控流量时，易遭受大规模的数据包输入，从而面临活锁。</li>
<li><strong>网络文件服务（Network File Services）</strong>：如NFS服务器，在处理大量RPC流量时，也可能受到活锁的影响。</li>
</ul>
<p>在调度网络任务的需求（Requirements for Scheduling Network Tasks）部分谈到，为了避免活锁并确保系统性能，操作系统必须合理调度网络任务。该部分讨论了系统在面对不同负载时，如何保证吞吐量、延迟、抖动（延迟波动）的合理控制，同时确保公平分配CPU资源，以避免系统过载。</p>
<p>在中断驱动的调度及其后果（Interrupt-driven Scheduling and Its Consequences）部分中，中断驱动系统的缺陷被详细讨论，包括：</p>
<ul>
<li><strong>接收活锁</strong>：系统在处理中断时，忽略了其他任务，导致吞吐量降为零。</li>
<li><strong>延迟增加</strong>：在高负载下，系统推迟了数据包的交付，延迟大幅增加。</li>
<li><strong>传输饥饿</strong>：过多的输入处理会阻止数据包的传输，导致系统仅接收数据包，却无法发送。</li>
</ul>
<p>在改进调度避免活锁（Avoiding Livelock Through Better Scheduling）部分中作者提出了一些避免活锁的方法：</p>
<ul>
<li><strong>限制中断到达速率</strong>：当系统超载时，暂时禁用中断，以便系统处理更高层的任务。</li>
<li><strong>轮询（Polling）机制</strong>：通过轮询机制代替中断，确保公平分配CPU资源，避免活锁。</li>
<li><strong>避免抢占</strong>：防止系统在处理中断时被中断，这样可以降低活锁的风险。</li>
</ul>
<p>在 BSD路由器中的活锁问题（Livelock in BSD-based Routers）部分中，作者通过实验展示了BSD系统中的活锁问题。在负载超过一定限度后，系统因处理中断耗尽资源，导致性能急剧下降。作者详细讨论了为何接收活锁会出现在这些系统中，并指出这些系统在面对高负载时会陷入活锁状态。</p>
<p>在确保用户进程的进展（Guaranteeing Progress for User-level Processes）部分，作者讨论了如何在高网络负载下，仍然为用户级进程保留足够的CPU时间。提出了一些机制，如CPU周期限制，确保系统在处理中断时，不会完全忽略用户进程。</p>
<p>相关工作（Related Work），该部分回顾了先前与轮询机制、中断驱动设计等相关的工作，讨论了现有技术如何减少中断开销，但这些技术仍不足以完全消除活锁问题。</p>
<p>总结与结论（Summary and Conclusions），论文总结了避免活锁的关键点：</p>
<ul>
<li>活锁在中断驱动系统中是一个严重的问题，尤其是在高网络负载下。</li>
<li>通过引入新的调度策略（如中断限速、轮询机制和CPU时间管理），系统可以有效避免活锁，并维持良好的性能。</li>
</ul>
<p>这些改进方法使得系统能够在高负载情况下，依然保持合理的响应速度和稳定的性能。</p>
<hr>
<h2 id="feedback">feedback
</h2><p>在实验中，作者发现当系统处理接收的数据包时，如果筛选队列（例如供 <code>screend</code> 使用的筛选队列）已满，那么继续接收数据包会导致系统资源浪费。这些数据包最终会在被完全处理前被丢弃，浪费了宝贵的处理时间。为了应对这一问题，作者在内核中添加了反馈机制：<strong>当检测到筛选队列已满时，系统会停止进一步的输入处理，直到队列有了足够的空间。</strong></p>
<p>具体来说，反馈机制会在系统中检测到特定队列（例如筛选队列）满时，立即暂停接收新的数据包，暂时禁用输入中断。系统会定期检查队列状态，当队列中的数据包处理到一定程度（比如达到队列容量的25%）时，重新允许输入中断恢复工作。这一机制确保了系统不会因过多的接收任务导致资源浪费，并且能够腾出时间处理现有的队列中的数据包。</p>
<p>在实验中，作者选择的筛选队列大小为32个数据包，并在队列填满75%时停止输入处理，只有当队列数据量减少至25%时才重新启用输入。这种高、低水位线的策略能够帮助系统有效地管理资源并保持一定的吞吐量。队列反馈机制的主要作用包括：</p>
<ol>
<li><strong>避免活锁</strong>：系统在高负载下避免无谓的数据包处理，当筛选队列满时直接暂停输入，确保资源集中处理现有数据包。</li>
<li><strong>提高资源利用率</strong>：反馈机制确保了系统可以充分利用输入队列，在队列资源消耗完之前处理到位，从而减少数据包丢弃情况，提升整体处理效率。</li>
<li><strong>稳定系统性能</strong>：通过合理地分配资源，该机制确保系统在高负载下依然能够以一定的速度处理和转发数据包，从而避免系统在过载情况下崩溃或陷入死循环。</li>
</ol>
<p>在使用 <code>screend</code> 程序的实验中，通过引入反馈机制，系统在高负载时能够显著提升峰值吞吐量，避免了活锁问题。通过这些测试，作者还发现不同的配额设置（即每次轮询处理的包数量）对系统性能影响较大，小配额（如10-20个包）能有效避免活锁并保持系统稳定。</p>
<p>总体来说，第6.6节的反馈机制通过实时监控队列状态，并在队列容量达到一定程度时暂停输入，实现了更高效的资源管理，确保系统在高负载下稳定运行并防止活锁现象。</p>
<hr>
<h2 id="操作系统的网络功能">操作系统的网络功能
</h2><p>操作系统的网络功能在底层确实使用了类似上面提到的编程接口（API）来处理网络通信，但这些功能背后涉及操作系统中的网络协议栈、驱动程序和硬件接口等复杂的机制。<strong>操作系统通过提供一系列的系统调用或库函数接口，使应用程序可以方便地进行网络通信</strong>。</p>
<p>这些接口可以分为以下几类：</p>
<ol>
<li>
<p><strong>套接字接口（Socket API）</strong></p>
<p>这是操作系统最常见的网络编程接口，主要用于实现不同网络协议（如 TCP 和 UDP）的网络通信。大多数现代操作系统提供的网络功能都是基于套接字的。操作系统通过系统调用（如 <code>socket()</code>、<code>connect()</code> 等）为用户提供操作网络连接的接口。</p>
<p>以下是常用的<strong>套接字接口</strong>：</p>
<ul>
<li><strong><code>socket()</code></strong>：创建一个套接字，指定协议族（如 IPv4、IPv6）和传输协议（如 TCP、UDP）。</li>
<li><strong><code>bind()</code></strong>：将套接字与本地地址（IP 和端口）绑定，用于服务端监听特定的网络接口。</li>
<li><strong><code>listen()</code></strong>：将套接字设置为被动监听模式，等待客户端连接。</li>
<li><strong><code>accept()</code></strong>：服务端接受客户端连接，返回新的套接字用于通信。</li>
<li><strong><code>connect()</code></strong>：客户端用来连接服务器的套接字。</li>
<li><strong><code>send()</code></strong> 和 <strong><code>recv()</code></strong>：分别用于发送和接收数据。</li>
<li><strong><code>sendto()</code></strong> 和 <strong><code>recvfrom()</code></strong>：用于无连接的 UDP 协议，直接向指定地址发送数据或从指定地址接收数据。</li>
<li><strong><code>close()</code></strong>：关闭套接字，终止连接。</li>
</ul>
</li>
<li>
<p><strong>网络设备接口</strong></p>
<p>操作系统提供了对网络设备（如网卡、无线适配器）的抽象，允许应用程序通过接口访问这些设备。例如，通过<strong>系统调用</strong>和<strong>ioctl</strong>命令来控制设备状态，修改网络配置。</p>
<p>常见的操作有：</p>
<ul>
<li><strong><code>ioctl()</code></strong>：控制网络接口，配置地址、网络掩码、路由表等。</li>
<li><strong><code>ifconfig</code></strong>：在类 Unix 系统中，用于配置和管理网络接口的命令（或对应的 API）。</li>
<li><strong><code>ethtool</code></strong>：查看和控制以太网设备的属性。</li>
</ul>
</li>
<li>
<p><strong>数据链路层接口</strong></p>
<p>一些操作系统允许开发人员直接操作数据链路层，通过特定的接口发送和接收原始的以太网帧（Raw Sockets）。这通常用于开发低级别的网络工具或网络协议的实现。</p>
<p>接口如：</p>
<ul>
<li><strong><code>AF_PACKET</code></strong>：Linux 中允许直接在链路层上发送/接收数据包的套接字类型，用于实现自定义协议。</li>
</ul>
</li>
<li>
<p><strong>网络配置接口</strong></p>
<p>操作系统还提供了一些接口，用于用户或应用程序动态配置网络，如修改 IP 地址、设置路由、配置防火墙等。</p>
<p>常见的工具和接口：</p>
<ul>
<li><strong><code>netstat</code></strong>：查看网络连接和端口状态。</li>
<li><strong><code>route</code></strong>：查看和修改系统的路由表。</li>
<li><strong><code>ip</code></strong>：现代 Linux 系统中，用于配置 IP 地址、路由、防火墙等。</li>
<li><strong><code>iptables</code></strong>：设置和管理 Linux 系统的防火墙规则。</li>
</ul>
</li>
<li>
<p><strong>异步 I/O 接口</strong></p>
<p>现代操作系统提供的网络接口通常支持异步 I/O，允许应用程序<strong>在等待网络事件时不阻塞</strong>。这对于高并发应用和事件驱动的网络程序非常重要。</p>
<p>常用的异步接口：</p>
<ul>
<li><strong><code>select()</code> 和 <code>poll()</code></strong>：检查多个套接字的状态，确定哪些套接字可读、可写或发生错误。</li>
<li><strong><code>epoll()</code>（Linux）</strong> 和 <strong><code>kqueue()</code>（BSD 系统）</strong>：更高效的事件通知机制，用于大规模并发连接。</li>
<li><strong>异步 I/O 框架</strong>：如 Linux 的 <strong>AIO</strong> 或 Windows 的 <strong>IOCP</strong>，允许更高效的非阻塞 I/O 操作。</li>
</ul>
</li>
<li>
<p><strong>高级网络协议接口</strong></p>
<p>除了底层套接字接口，操作系统往往通过用户态库提供对更高级网络协议的支持，如：</p>
<ul>
<li><strong>HTTP</strong>：通过操作系统提供的 API 或高级网络库（如 <code>libcurl</code>）支持高层协议。</li>
<li><strong>TLS/SSL</strong>：如 OpenSSL，提供安全传输层的加密通信支持。</li>
</ul>
</li>
<li>
<p><strong>虚拟网络接口</strong></p>
<p>操作系统还可以提供虚拟网络设备，用于<strong>虚拟机网络通信、VPN 实现</strong>等，如：</p>
<ul>
<li><strong>TUN/TAP 设备</strong>：Linux 中用于创建用户态虚拟网络接口的设备。<code>TUN</code> 用于三层网络（如 IP），<code>TAP</code> 用于二层网络（如以太网帧）。</li>
</ul>
</li>
<li>
<p><strong>网络管理接口</strong></p>
<p>现代操作系统通过管理接口提供动态的网络资源管理，应用程序可以通过这些接口调整网络行为，如 QoS、流量管理等。</p>
<p>常见的网络管理接口包括：</p>
<ul>
<li><strong>NetworkManager</strong>：Linux 上的网络管理服务，允许动态切换网络配置（Wi-Fi、有线网络等）。</li>
<li><strong>Windows Sockets（Winsock）</strong>：Windows 操作系统上用于网络通信的接口。</li>
</ul>
</li>
<li>
<p><strong>防火墙和安全接口</strong></p>
<p>操作系统提供了用于设置网络防火墙和安全策略的接口。例如：</p>
<ul>
<li><strong><code>iptables</code></strong>（Linux）和 <strong><code>firewalld</code></strong>：用于定义网络防火墙规则。</li>
<li><strong>Windows Firewall API</strong>：Windows 操作系统提供的防火墙控制接口。</li>
</ul>
</li>
<li>
<p><strong>示例代码（基于 C 语言的 POSIX 套接字）</strong></p>
<p>操作系统底层通过 C 语言的 POSIX 标准为程序员提供系统调用来访问网络功能。以下是一个基于 C 的简单 TCP 服务器示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">server_fd</span><span class="p">,</span> <span class="n">new_socket</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">address</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">opt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">addrlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">1024</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建套接字
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">server_fd</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">server_fd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;socket failed&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 绑定地址和端口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">address</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">address</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">INADDR_ANY</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">address</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="nf">htons</span><span class="p">(</span><span class="mi">8080</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">bind</span><span class="p">(</span><span class="n">server_fd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">address</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">address</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 监听
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">listen</span><span class="p">(</span><span class="n">server_fd</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Server is listening on port 8080</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 接受客户端连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">new_socket</span> <span class="o">=</span> <span class="nf">accept</span><span class="p">(</span><span class="n">server_fd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">address</span><span class="p">,</span> <span class="p">(</span><span class="kt">socklen_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addrlen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 读取数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">read</span><span class="p">(</span><span class="n">new_socket</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Received: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 发送响应
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">char</span> <span class="o">*</span><span class="n">response</span> <span class="o">=</span> <span class="s">&#34;Hello from server&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">send</span><span class="p">(</span><span class="n">new_socket</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">response</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 关闭连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">close</span><span class="p">(</span><span class="n">new_socket</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">close</span><span class="p">(</span><span class="n">server_fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p>总的来说，操作系统通过各种网络接口向用户提供网络功能，从底层的套接字系统调用到更高级的网络管理工具和库。应用程序通过这些接口可以实现网络通信、数据传输、网络设备配置等功能。</p>
<hr>
<h2 id="livelock">Livelock
</h2><p><strong>Livelock</strong> 是一种计算机系统中常见的同步问题，类似于死锁（Deadlock），但有所区别。在 livelock 情况下，多个进程或线程<strong>虽然没有完全停止运行</strong>（也就是说它们仍然在“活动”中），但<strong>无法继续执行有意义的操作</strong>，因为它们彼此不断地改变状态或采取相互回避的行为，导致始终无法达到目标状态。二者区别如下：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th style="text-align: center">死锁（Deadlock）</th>
          <th style="text-align: center">活锁（Livelock）</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">进程或线程由于资源竞争或互相等待而<strong>完全停滞</strong>，不会再有任何进展。</td>
          <td style="text-align: center">进程或线程仍在运行，但因互相妥协或状态改变，<strong>始终无法完成预期的任务</strong>，表现为一种不断尝试和回退的循环。</td>
      </tr>
  </tbody>
</table></div>
<p>举一个例子来形容livelock，即两个人同时尝试从狭窄的走廊中通过，并相互避让。人 A 往左，人 B 也往左。然后人 A 发现两人撞上了，决定往右，而人 B 也往右。他们就这样不断相互避让，但<strong>永远无法成功通过</strong>。</p>
<p><strong>计算机系统中的例子</strong>：在多线程编程中，如果两个线程使用自旋锁（spinlock），并不断尝试解除锁，但总是因为其他线程在做相同的事情而陷入循环，则可能形成 livelock。</p>
<p>造成Livelock可能有多个原因：</p>
<ul>
<li><strong>不恰当的资源释放策略</strong>：线程或进程在资源竞争中频繁地释放和请求资源。</li>
<li><strong>优先级反转和调度问题</strong>：当线程的优先级动态变化，导致调度策略始终无法满足任务需求时。</li>
<li><strong>不良的避免冲突策略</strong>：如多个线程在检测冲突后不断地相互回避，却无法找到合适的行动策略。</li>
</ul>
<p>相应的，可以预防 Livelock的方法有如下：</p>
<ul>
<li><strong>引入随机化</strong>：通过在冲突时引入随机等待或随机操作策略，可以避免相互的“镜像”行为。</li>
<li><strong>限制重试次数</strong>：设定尝试的最大次数或时间限制，超过后采取其他方式或放弃操作。</li>
<li><strong>引入优先级机制</strong>：在多线程竞争时，设置适当的优先级，以确保重要操作能够顺利完成。</li>
</ul>
<p>要识别 Livelock，通常需要对系统的状态进行监控和分析，查看是否存在某些进程或线程<strong>在做无效的、重复的动作而没有实际进展</strong>。可以通过以下方法进行调试：</p>
<ul>
<li><strong>日志分析</strong>：检查重复操作的模式。</li>
<li><strong>CPU 占用率监控</strong>：看是否存在线程持续占用 CPU 但没有实际产出。</li>
<li><strong>执行路径跟踪</strong>：追踪线程执行的具体路径，确认是否进入了一个无效循环。</li>
</ul>
<p>Livelock 是一种由于资源协调不当而导致的“忙碌等待”现象，其表现为系统中某些进程或线程虽然在活动，但因重复的避让行为而无法完成有效的任务。与死锁不同，活锁需要更复杂的策略来处理，如引入随机化、调整优先级等。</p>
<hr>
<h2 id="receive-livelock">Receive Livelock
</h2><p><strong>Receive Livelock</strong> 是网络系统中的一种活锁现象，通常发生在高流量环境下，当系统过度忙于处理接收的数据包，但<strong>无法有效传递数据到更高层的应用或协议栈</strong>时。它本质上是网络设备或操作系统在网络包接收过程中被不断打断，导致没有足够时间处理或传递这些数据包，使得传输效率极低。</p>
<p>在网络中，尤其是高流量下，网络接口会迅速收到大量数据包。由于每个接收的包都可能触发一个中断，CPU会频繁响应这些中断，导致以下问题：</p>
<ul>
<li><strong>频繁的中断</strong>：系统一旦收到网络包就产生中断，迫使 CPU 停止当前任务去处理网络包，这会使应用层或协议栈无法获取足够的时间来处理这些包。</li>
<li><strong>资源争用</strong>：由于系统忙于响应中断，几乎所有 CPU 资源都用于接收和调度数据包，使得系统其他任务无法执行，包括转发或处理这些接收的数据包。</li>
<li><strong>处理延迟</strong>：不断的中断和无效处理会让系统无法在每次中断间完成一个完整的数据包处理流程，进而形成 livelock。</li>
</ul>
<p>系统表现出接收很多包但没有真正处理的情况。例如：</p>
<ul>
<li><strong>高 CPU 占用率</strong>：系统在处理中断，但 CPU 时间主要耗在接收上，而非有效处理。</li>
<li><strong>低传输效率</strong>：虽然网络接口忙于接收，但传输的数据量不成比例，表现为低吞吐量。</li>
<li><strong>应用层数据包少</strong>：应用程序无法接收到足够的有效数据，影响服务性能。</li>
</ul>
<p>为了应对 receive livelock，可以采取以下措施：</p>
<ul>
<li><strong>减少中断频率</strong>：采用“中断聚合”（Interrupt Coalescing）技术，将多个中断合并为一个，从而减少 CPU 处理中断的频率，让系统有时间有效处理数据包。</li>
<li><strong>使用 NAPI（New API）技术</strong>：NAPI 是 Linux 内核中的一种中断处理机制，用于网络包的批量处理。它将接收从<strong>中断驱动</strong>切换到<strong>轮询驱动</strong>，当流量过高时，系统进入轮询模式，这样系统可以避免频繁中断，从而减轻 CPU 负担。</li>
<li><strong>分布式处理</strong>：使用多核 CPU 并合理分配网络任务，让多个核心共同处理接收和转发数据包。</li>
<li><strong>限流策略</strong>：控制接收的数据包速率，例如限制每秒接收的包数，避免超过系统处理能力。</li>
</ul>
<p>为确认是否发生 receive livelock，可以通过以下步骤检测：</p>
<ul>
<li><strong>监控 CPU 占用和中断频率</strong>：观察是否有单个 CPU 核心被高频中断占满。</li>
<li><strong>流量分析</strong>：检查网络流量与应用层收到的有效数据包量是否存在显著差距。</li>
<li><strong>应用层性能测试</strong>：通过对比不同网络负载下的应用性能，分析是否存在高负载下的明显性能下降。</li>
</ul>
<p>Receive Livelock 是网络系统因高频中断而导致的活锁现象，会严重影响系统的数据处理和传输效率。通过减少中断、优化处理机制和引入流量控制策略，可以有效减轻其影响。</p>
<hr>
<h2 id="正课部分">正课部分
</h2><h2 id="计算机网络概述">计算机网络概述
</h2><p>今天我想讨论一下Networking以及它与操作系统的关联。今天这节课的很多内容都与最后一个lab，也就是构建一个网卡驱动相关。</p>
<p>在这节课，我们首先会大概看一下操作系统中网络相关的软件会有什么样的结构，之后我们会讨论今天的论文<a class="link" href="https://pdos.csail.mit.edu/6.828/2020/readings/mogul96usenix.pdf"  target="_blank" rel="noopener"
    >Livelock</a>

。Livelock展示了在设计网络协议栈时可能会出现的有趣的陷阱。</p>
<p>首先，让我通过画图来描述一下基本的网络场景。网络连接了不同的主机，这里的连接有两种方式：</p>
<p>相近的主机连接在同一个网络中。例如有一个以太网设备，可能是交换机或者单纯的线缆，然后有一些主机连接到了这个以太网设备。这里的主机可能是笔记本电脑，服务器或者路由器。在设计网络相关软件的时候，通常会忽略直接连接了主机的网络设备。</p>
<p>这里的网络设备可能只是一根线缆（几十年前就是通过线缆连接主机）；也可能是一个以太网交换机；也可能是wifi无线局域网设备（主机通过射频链路与网络设备相连），但是不管是哪种设备，这种直接连接的设备会在网络协议栈的底层被屏蔽掉。</p>
<p>每个主机上会有不同的应用程序，或许其中一个主机有网络浏览器，另一个主机有HTTP server，它们需要通过这个局域网来相互通信。</p>
<p>一个局域网的大小是有极限的。局域网（Local Area Network）通常简称为LAN。</p>
<p>一个局域网需要能让其中的主机都能收到彼此发送的packet。有时，主机需要广播packet到局域网中的所有主机。当局域网中只有25甚至100个主机时，是没有问题的。但是你不能构建一个多于几百个主机的局域网。</p>
<p>所以为了解决这个问题，大型网络是这样构建的。首先有多个独立的局域网，假设其中一个局域网是MIT，另一个局域网是Harvard，还有一个很远的局域网是Stanford，在这些局域网之间会有一些设备将它们连接在一起，这些设备通常是路由器Router。</p>
<p>其中一个Router接入到了MIT的局域网，同时也接入到了Harvard的局域网。</p>
<p>路由器是组成互联网的核心，路由器之间的链路，最终将多个局域网连接在了一起。</p>
<p>现在MIT有一个主机需要与Stanford的一个主机通信，他们之间需要经过一系列的路由器，路由器之间的转发称为Routing。</p>
<p>所以我们需要有一种方法让MIT的主机能够寻址到Stanford的主机，并且我们需要让连接了MIT的路由器能够在收到来自MIT的主机的packet的时候，能够知道这个packet是发送给Harvard的呢，还是发送给Stanford的。</p>
<p>从网络协议的角度来说，局域网通信由以太网协议决定。而局域网之上的长距离网络通信由Internet Protocol协议决定。以上就是网络的概述。</p>
<p>接下来我想介绍一下，在局域网和互联网上传递的packet有什么样的结构，之后再讨论在主机和路由器中的软件是如何处理这些packet。</p>
<hr>
<h2 id="二层网络-----ethernet">二层网络 &mdash; Ethernet
</h2><p>让我从最底层开始，我们先来看一下一个以太网packet的结构是什么。当两个主机非常靠近时，或许是通过相同的线缆连接，或许连接在同一个wifi网络，或许连接到同一个以太网交换机。</p>
<p>当局域网中的两个主机彼此间要通信时，最底层的协议是以太网协议。你可以认为Host1通过以太网将Frame发送给Host2。</p>
<p>Frame是以太网中用来描述packet的单词，本质上这就是两个主机在以太网上传输的一个个的数据Byte。以太网协议会在Frame中放入足够的信息让主机能够识别彼此，并且识别这是不是发送给自己的Frame。</p>
<p>每个以太网packet在最开始都有一个Header，其中包含了3个数据。Header之后才是payload数据。Header中的3个数据是：目的以太网地址，源以太网地址，以及packet的类型。</p>
<p><img src="/p/mit6s08121networking/p53.png"
	width="1116"
	height="630"
	srcset="/p/mit6s08121networking/p53_hu5082461355547701875.png 480w, /p/mit6s08121networking/p53_hu12450737063758896380.png 1024w"
	loading="lazy"
	
		alt="p53"
	
	
		class="gallery-image" 
		data-flex-grow="177"
		data-flex-basis="425px"
	
></p>
<p>每一个以太网地址都是48bit的数字，这个数字唯一识别了一个网卡。</p>
<p>packet的类型会告诉接收端的主机该如何处理这个packet。接收端主机侧更高层级的网络协议会按照packet的类型检查并处理以太网packet中的payload。整个以太网packet，包括了48bit+48bit的以太网地址，16bit的类型，以及任意长度的payload这些都是通过线路传输。</p>
<p>除此之外，虽然对于软件来说是不可见的，但是在packet的开头还有被硬件识别的表明packet起始的数据（注，Preamble + SFD），在packet的结束位置还有几个bit表明packet的结束（注，FCS）。packet的开头和结束的标志不会被系统内核所看到，其他的部分会从网卡送到系统内核。</p>
<p>如果你们查看了这门课程的最后一个lab，你们可以发现我们提供的代码里面包括了一些新的文件，其中包括了kernel/net.h，这个文件中包含了大量不同网络协议的packet header的定义。</p>
<p>上图中的代码包含了以太网协议的定义。我们提供的代码使用了这里结构体的定义来解析收到的以太网packet，进而获得目的地址和类型值（注，实际中只需要对收到的raw data指针强制类型转换成结构体指针就可以完成解析）。</p>
<blockquote>
<p>学生提问：硬件用来识别以太网packet的开头和结束的标志是不是类似于lab中的End of Packets？</p>
<p>Robert教授：并不是的，EOP是帮助驱动和网卡之间通信的机制。</p>
<p>这里的开头和结束的标志是在线缆中传输的电信号或者光信号，这些标志位通常在一个packet中是不可能出现的。以结束的FCS为例，它的值通常是packet header和payload的校验和，可以用来判断packet是否合法。</p>
</blockquote>
<p>有关以太网48bit地址，是为了给每一个制造出来的网卡分配一个唯一的ID，所以这里有大量的可用数字。</p>
<p>这里48bit地址中，前24bit表示的是制造商，每个网卡制造商都有自己唯一的编号，并且会出现在前24bit中。后24bit是由网卡制造商提供的任意唯一数字，通常网卡制造商是递增的分配数字。</p>
<p>所以，如果你从一个网卡制造商买了一批网卡，每个网卡都会被写入属于自己的地址，并且如果你查看这些地址，你可以发现，这批网卡的高24bit是一样的，而低24bit极有可能是一些连续的数字。</p>
<p>虽然以太网地址是唯一的，但是出了局域网，它们对于定位目的主机的位置是没有帮助的。如果网络通信的目的主机在同一个局域网，那么目的主机会监听发给自己的地址的packet。</p>
<p>但是如果网络通信发生在两个国家的主机之间，你需要使用一个不同的寻址方法，这就是IP地址的作用。</p>
<p>在实际中，你可以使用tcpdump来查看以太网packet。这将会是lab的一部分。下图是tcpdump的一个输出：</p>
<p><img src="/p/mit6s08121networking/p54.png"
	width="916"
	height="190"
	srcset="/p/mit6s08121networking/p54_hu15204464692332807933.png 480w, /p/mit6s08121networking/p54_hu16450299451388196205.png 1024w"
	loading="lazy"
	
		alt="p54"
	
	
		class="gallery-image" 
		data-flex-grow="482"
		data-flex-basis="1157px"
	
></p>
<p>tcpdump输出了很多信息，其中包括：</p>
<ul>
<li>接收packet的时间</li>
<li>第一行的剩下部分是可读的packet的数据</li>
<li>接下来的3行是收到packet的16进制数</li>
</ul>
<p>如果按照前面以太网header的格式，可以发现packet中：</p>
<ul>
<li>前48bit是一个广播地址，0xffffffffffff。广播地址是指packet需要发送给局域网中的所有主机。</li>
<li>之后的48bit是发送主机的以太网地址，我们并不能从这个地址发现什么，实际上这个地址是运行在QEMU下的XV6生成的地址，所以地址中的前24bit并不是网卡制造商的编号，而是QEMU编造的地址。</li>
<li>接下来的16bit是以太网packet的类型，这里的类型是0x0806，对应的协议是ARP。</li>
<li>剩下的部分是ARP packet的payload。</li>
</ul>
<hr>
<h2 id="二三层地址转换-----arp">二/三层地址转换 &mdash; ARP
</h2><p>下一个与以太网通信相关的协议是ARP。</p>
<p>在以太网层面，每个主机都有一个以太网地址。但是为了能在互联网上通信，你需要有32bit的IP地址。</p>
<p>为什么需要IP地址呢？因为IP地址有额外的含义。</p>
<p>IP地址的高位bit包含了在整个互联网中，这个packet的目的地在哪。所以IP地址的高位bit对应的是网络号，虽然实际上要更复杂一些，但是你可以认为互联网上的每一个网络都有一个唯一的网络号。</p>
<p>路由器会检查IP地址的高bit位，并决定将这个packet转发给互联网上的哪个路由器。IP地址的低bit位代表了在局域网中特定的主机。</p>
<p>当一个经过互联网转发的packet到达了局域以太网，我们需要从32bit的IP地址，找到对应主机的48bit以太网地址。这里是通过一个动态解析协议完成的，也就是Address Resolution Protocol，ARP协议。</p>
<p>当一个packet到达路由器并且需要转发给同一个以太网中的另一个主机，或者一个主机将packet发送给同一个以太网中的另一个主机时，发送方首先会在局域网中广播一个ARP packet，来表示任何拥有了这个32bit的IP地址的主机，请将你的48bit以太网地址返回过来。</p>
<p>如果相应的主机存在并且开机了，它会向发送方发送一个ARP response packet。</p>
<p>下图是一个ARP packet的格式：</p>
<p><img src="/p/mit6s08121networking/p55.png"
	width="1094"
	height="771"
	srcset="/p/mit6s08121networking/p55_hu9525627550765042194.png 480w, /p/mit6s08121networking/p55_hu16089440296069243885.png 1024w"
	loading="lazy"
	
		alt="p55"
	
	
		class="gallery-image" 
		data-flex-grow="141"
		data-flex-basis="340px"
	
></p>
<p>它会出现在一个以太网packet的payload中。所以你们看到的将会是这样的结构：首先是以太网header，它包含了48bit的目的以太网地址，48bit的源以太网地址，16bit的类型；之后的以太网的payload会是ARP packet，包含了上图的内容。</p>
<p>接收到packet的主机通过查看以太网header中的16bit类型可以知道这是一个ARP packet。在ARP中类型值是0x0806。通过识别类型，接收到packet的主机就知道可以将这个packet发送给ARP协议处理代码。</p>
<p>有关ARP packet的内容，包含了不少信息，但是基本上就是在说，现在有一个IP地址，我想将它转换成以太网地址，如果你拥有这个IP地址，请响应我。</p>
<p>同样的，我们也可以通过tcpdump来查看这些packet。</p>
<p>在网络的lab中，XV6会在QEMU模拟的环境下发送IP packet。所以你们可以看到在XV6和其他主机之间有ARP的交互。</p>
<p>下图中第一个packet是我的主机想要知道XV6主机的以太网地址，第二个packet是XV6在收到了第一个packet之后，并意识到自己是IP地址的拥有者，然后返回response。</p>
<p><img src="/p/mit6s08121networking/p56.png"
	width="898"
	height="282"
	srcset="/p/mit6s08121networking/p56_hu9561999928152077835.png 480w, /p/mit6s08121networking/p56_hu15905466988636034815.png 1024w"
	loading="lazy"
	
		alt="p56"
	
	
		class="gallery-image" 
		data-flex-grow="318"
		data-flex-basis="764px"
	
></p>
<p>tcpdump能够解析出ARP packet，并将数据打印在第一行。对应ARP packet的格式，在第一个packet中，10.0.2.2是SIP，10.0.2.15是DIP。在第二个packet中，52:54:00:12:34:56对应SHA。</p>
<p>同时，我们也可以自己分析packet的原始数据。对于第一个packet：</p>
<ul>
<li>前14个字节是以太网header，包括了48bit目的以太网地址，48bit源以太网地址，16bit类型。</li>
<li>从后往前看，倒数4个字节是TIP，也就是发送方想要找出对应以太网地址的IP地址。每个字节对应了IP地址的一块，所以0a00 020f对应了IP地址10.0.2.15。</li>
<li>再向前数6个字节，是THA，也就是目的地的以太网地址，现在还不知道所以是全0。</li>
<li>再向前数4个字节是SIP，也就是发送方的IP地址，0a000202对应了IP地址10.0.2.2。</li>
<li>再向前数6个字节是SHA，也就是发送方的以太网地址。</li>
<li>剩下的8个字节表明了我们感兴趣的是以太网和IP地址格式。</li>
</ul>
<p>第二个packet是第一个packet的响应。</p>
<blockquote>
<p>学生提问：ethernet header中已经包括了发送方的以太网地址，为什么ARP packet里面还要包含发送方的以太网地址？</p>
<p>Robert教授：我并不清楚为什么ARP packet里面包含了这些数据，我认为如果你想的话是可以精简一下ARP packet。</p>
<p>或许可以这么理解，ARP协议被设计成也可以用在其他非以太网的网络中，所以它被设计成独立且不依赖其他信息，所以ARP packet中包含了以太网地址。</p>
<p>现在我们是在以太网中发送ARP packet，以太网packet也包含了以太网地址，所以，如果在以太网上运行ARP，这些信息是冗余的。</p>
<p>但是如果在其他的网络上运行ARP，你或许需要这些信息，因为其他网络的packet中并没有包含以太网地址。</p>
<p>学生提问：tcpdump中原始数据的右侧是什么内容？</p>
<p>Robert教授：这些是原始数据对应的ASCII码，“.”对应了一个字节并没有相应的ASCII码，0x52对应了R，0x55对应了U。当我们发送的packet包含了ASCII字符时，这里的信息会更加有趣。</p>
</blockquote>
<p>我希望你们在刚刚的讨论中注意到这一点，网络协议和网络协议header是嵌套的。我们刚刚看到的是一个packet拥有了ethernet header和ethernet payload。</p>
<p>在ethernet payload中，首先出现的是ARP header，对于ARP来说并没有的payload。</p>
<p>但是在ethernet packet中还可以包含其他更复杂的结构，比如说ethernet payload中包含一个IP packet，IP packet中又包含了一个UDP packet，所以IP header之后是UDP header。</p>
<p>如果在UDP中包含另一个协议，那么UDP payload中又可能包含其他的packet，例如DNS packet。</p>
<p>所以发送packet的主机会按照这样的方式构建packet：DNS相关软件想要在UDP协议之上构建一个packet；UDP相关软件会将UDP header挂在DNS packet之前，并在IP协议之上构建另一个packet；IP相关的软件会将IP heade挂在UDP packet之前；最后Ethernet相关的软件会将Ethernet header挂在IP header之前。所以整个packet是在发送过程中逐渐构建起来的。</p>
<p>类似的，当一个操作系统收到了一个packet，它会先解析第一个header并知道这是Ethernet，经过一些合法性检查之后，Ethernet header会被剥离，操作系统会解析下一个header。</p>
<p>在Ethernet  header中包含了一个类型字段，它表明了该如何解析下一个header。</p>
<p>同样的在IP header中包含了一个protocol字段，它也表明了该如何解析下一个header。</p>
<p>软件会解析每个header，做校验，剥离header，并得到下一个header。一直重复这个过程直到得到最后的数据。这就是嵌套的packet header。</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>DNS</th>
          <th>UDP</th>
          <th>IP</th>
          <th>ETH</th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table></div>
<hr>
<h2 id="三层网络-----internet">三层网络 &mdash; Internet
</h2><p>Ethernet header足够在一个局域网中将packet发送到一个host。</p>
<p>如果你想在局域网发送一个IP packet，那么你可以使用ARP获得以太网地址。但是IP协议更加的通用，IP协议能帮助你向互联网上任意位置发送packet。下图是一个IP packet的header，你们可以在lab配套的代码中的net.h文件找到。</p>
<p><img src="/p/mit6s08121networking/p57.png"
	width="1119"
	height="651"
	srcset="/p/mit6s08121networking/p57_hu17859731178445837582.png 480w, /p/mit6s08121networking/p57_hu1316911422419639037.png 1024w"
	loading="lazy"
	
		alt="p57"
	
	
		class="gallery-image" 
		data-flex-grow="171"
		data-flex-basis="412px"
	
></p>
<p>如果IP packet是通过以太网传输，那么你可以看到，在一个以太网packet中，最开始是目的以太网地址，源以太网地址，以太网类型是0x0800，之后是IP header，最后是IP payload。</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>PAYLOAD</th>
          <th>IP</th>
          <th>T=0x0800</th>
          <th>S</th>
          <th>D</th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table></div>
<p>在一个packet发送到世界另一端的网络的过程中，IP header会被一直保留，而Ethernet header在离开本地的以太网之后会被剥离。</p>
<p>或许packet在被路由的过程中，在每一跳（hop）会加上一个新的Ethernet header。但是IP header从源主机到目的主机的过程中会一直保留。</p>
<p>IP header具有全局的意义，而Ethernet header只在单个局域网有意义。</p>
<p>所以IP header必须包含足够的信息，这样才能将packet传输给互联网上遥远的另一端。对于我们来说，关键的信息是三个部分，目的IP地址（ip_dst），源IP地址（ip_src）和协议（ip_p）。</p>
<p>目的IP地址是我们想要将packet送到的目的主机的IP地址。地址中的高bit位是网络号，它会帮助路由器完成路由。IP header中的协议字段会告诉目的主机如何处理IP payload。</p>
<p>如果你们看到过MIT的IP地址，你们可以看到IP地址是18.x.x.x，虽然最近有些变化，但是在很长一段时间18是MIT的网络号。所以MIT的大部分主机的IP地址最高字节就是18。全世界的路由器在看到网络号18的时候，就知道应该将packet路由到离MIT更近的地方。</p>
<p>接下来我们看一下包含了IP packet的tcpdump输出。</p>
<p><img src="/p/mit6s08121networking/p58.png"
	width="888"
	height="210"
	srcset="/p/mit6s08121networking/p58_hu15771808828671337644.png 480w, /p/mit6s08121networking/p58_hu17173033069996894068.png 1024w"
	loading="lazy"
	
		alt="p58"
	
	
		class="gallery-image" 
		data-flex-grow="422"
		data-flex-basis="1014px"
	
></p>
<p>因为这个IP packet是在以太网上传输，所以它包含了以太网header。呃……，实际上这个packet里面有点问题，我不太确定具体的原因是什么，但是Ethernet header中目的以太网地址不应该是全f，因为全f是广播地址，它会导致packet被发送到所有的主机上。</p>
<p>一个真实网络中两个主机之间的packet，不可能出现这样的以太网地址。所以我提供的针对network lab的方案，在QEMU上运行有点问题。不管怎么样，我们可以看到以太网目的地址，以太网源地址，以及以太网类型0x0800。0x0800表明了Ethernet payload是一个IP packet。</p>
<p>IP header的长度是20个字节，所以中括号内的是IP header，</p>
<p><img src="/p/mit6s08121networking/p59.png"
	width="886"
	height="210"
	srcset="/p/mit6s08121networking/p59_hu12392152258668777607.png 480w, /p/mit6s08121networking/p59_hu17072750087407752085.png 1024w"
	loading="lazy"
	
		alt="p59"
	
	
		class="gallery-image" 
		data-flex-grow="421"
		data-flex-basis="1012px"
	
></p>
<p>从后向前看：</p>
<ul>
<li>目的IP地址是0x0a000202，也就是10.0.2.2。</li>
<li>源IP地址是0x0a00020f，也就是10.0.2.15。</li>
<li>再向前有16bit的checksum，也就是0x3eae。</li>
<li>再向前一个字节是protocol，0x11对应的是10进制17，表明了下一层协议是UDP</li>
<li>其他的就是我们不太关心的一些字段了，例如packet的长度。</li>
</ul>
<p>IP header中的protocol字段告诉了目的主机的网络协议栈，这个packet应该被UDP软件处理。</p>
<hr>
<h2 id="四层网络-----udp">四层网络 &mdash; UDP
</h2><p>IP header足够让一个packet传输到互联网上的任意一个主机，但是我们希望做的更好一些。每一个主机都运行了大量需要使用网络的应用程序，所以我们需要有一种方式能区分一个packet应该传递给目的主机的哪一个应用程序，而IP header明显不包含这种区分方式。</p>
<p>有一些其他的协议完成了这里的区分工作，其中一个是TCP，它比较复杂，而另一个是UDP。TCP不仅帮助你将packet发送到了正确的应用程序，同时也包含了序列号等用来检测丢包并重传的功能，这样即使网络出现问题，数据也能完整有序的传输。</p>
<p>相比之下，UDP就要简单的多，它以一种“尽力而为”的方式将packet发送到目的主机，除此之外不提供任何其他功能。</p>
<p>UDP header中最关键的两个字段是sport源端口和dport目的端口。</p>
<p><img src="/p/mit6s08121networking/p60.png"
	width="878"
	height="254"
	srcset="/p/mit6s08121networking/p60_hu8906819964981415306.png 480w, /p/mit6s08121networking/p60_hu13094916978274572726.png 1024w"
	loading="lazy"
	
		alt="p60"
	
	
		class="gallery-image" 
		data-flex-grow="345"
		data-flex-basis="829px"
	
></p>
<p>当你的应用程序需要发送或者接受packet，它会使用socket API，这包含了一系列的系统调用。一个进程可以使用socket API来表明应用程序对于特定目的端口的packet感兴趣。</p>
<p>当应用程序调用这里的系统调用，操作系统会返回一个文件描述符。每当主机收到了一个目的端口匹配的packet，这个packet会出现在文件描述符中，之后应用程序就可以通过文件描述符读取packet。</p>
<p>这里的端口分为两类，一类是常见的端口，例如53对应的是DNS服务的端口，如果你想向一个DNS server发请求，你可以发送一个UDP packet并且目的端口是53。</p>
<p>除此之外，很多常见的服务都占用了特定的端口。</p>
<p>除了常见端口，16bit数的剩下部分被用来作为匿名客户端的源端口。比如说，我想向一个DNS server的53端口发送一个packet，目的端口会是53，但是源端口会是一个本地随机选择的端口，这个随机端口会与本地的应用程序的socket关联。</p>
<p>所以当DNS server向本地服务器发送一个回复packet，它会将请求中的源端口拷贝到回复packet的目的端口，再将回复packet发送回本地的服务器。本地服务器会使用这个端口来确定应该将packet发送给哪个应用程序。</p>
<p>接下来我们看一下UDP packet的tcpdump输出。</p>
<p>首先，我们同样会有一个以太网Header，以及20字节的IP header。IP header中的0x11表明这个packet的IP协议号是17，这样packet的接收主机就知道应该使用UDP软件来处理这个packet。</p>
<p><img src="/p/mit6s08121networking/p61.png"
	width="898"
	height="186"
	srcset="/p/mit6s08121networking/p61_hu6283478261879311494.png 480w, /p/mit6s08121networking/p61_hu9410369400483495854.png 1024w"
	loading="lazy"
	
		alt="p61"
	
	
		class="gallery-image" 
		data-flex-grow="482"
		data-flex-basis="1158px"
	
></p>
<p>接下来的8个字节是UDP header。</p>
<p>这里的packet是由lab代码生成的packet，所以它并没有包含常见的端口，源端口是0x0700，目的端口是0x6403。</p>
<p>第4-5个字节是长度，第6-7个字节是校验和。XV6的UDP软件并没有生成UDP的校验和。</p>
<p>UDP header之后就是UDP的payload。在这个packet中，应用程序发送的是ASCII文本，所以我们可以从右边的ASCII码看到，内容是“a.message.from.xv6”。</p>
<p>所以ASCII文本放在了一个UDP packet中，然后又放到了一个IP packet中，然后又放到了一个Ethernet packet中。最后发布到以太网上。</p>
<blockquote>
<p>学生提问：当你发送一个packet给一个主机，但是你又不知道它的以太网地址，这个packet是不是会被送到路由器，之后再由路由器来找到以太网地址？</p>
<p>Robert教授：如果你发送packet到一个特定的IP地址，你的主机会先检查packet的目的IP地址来判断目的主机是否与你的主机在同一个局域网中。</p>
<p>如果是的话，你的主机会直接使用ARP来将IP地址翻译成以太网地址，再将packet通过以太网送到目的主机。更多的场景是，我们将一个packet发送到互联网上某个主机。</p>
<p>这时，你的主机会将packet发送到局域网上的路由器，路由器会检查packet的目的IP地址，并根据路由表选择下一个路由器，将packet转发给这个路由器。这样packet一跳一跳的在路由器之间转发，最终离目的主机越来越近。</p>
<p>学生提问：对于packet的长度有限制吗？</p>
<p>Robert教授：有的。这里有几个不同的限制，每一个底层的网络技术，例如以太网，都有能传输packet的上限。</p>
<p>今天我们要讨论的论文基于以太网最大可传输的packet是1500字节。最新的以太网可以支持到9000或者10000字节的最大传输packet。</p>
<p>为什么不支持传输无限长度的packet呢？这里有几个原因：</p>
<ul>
<li>
<p>发送无限长度的packet的时间可能要很长，期间线路上会有信号噪音和干扰，所以在发送packet的时候可能会收到损坏的bit位。</p>
<p>基本上每一种网络技术都会在packet中带上某种校验和或者纠错码，但是校验和也好，纠错码也好，只能在一定长度的bit位内稳定的检测错误。</p>
<p>如果packet长度增加，遗漏错误的可能性就越来越大。所以一个校验和的长度，例如16bit或者32bit，限制了传输packet的最大长度。</p>
</li>
<li>
<p>另一个限制是，如果发送巨大的packet，传输路径上的路由器和主机需要准备大量的buffer来接收packet。</p>
<p>这里的代价又比较高，因为较难管理一个可变长度的buffer，管理一个固定长度的buffer是最方便的。而固定长度的buffer要求packet的最大长度不会太大。</p>
</li>
</ul>
<p>所以，以太网有1500或者9000字节的最大packet限制。</p>
<p>除此之外，所有的协议都有长度字段，例如UDP的长度字段是16bit。所以即使以太网支持传输更大的packet，协议本身对于数据长度也有限制。</p>
</blockquote>
<p>以上就是UDP的介绍。在lab的最后你们会通过实验提供的代码来向谷歌的DNS server发送一个查询，收到回复之后代码会打印输出。你们需要在设备驱动侧完成以太网数据的处理。</p>
<hr>
<h2 id="网络协议栈network-stack">网络协议栈（Network Stack）
</h2><p>与packet的协议和格式对应的是运行在主机上的网络协议栈。人们有各种各样的方式来组织网络软件，接下来我会介绍最典型的，并且至少我认为是最标准的组织方式。</p>
<p>假设我们现在在运行Linux或者XV6，我们有一些应用程序比如浏览器，DNS服务器。这些应用程序使用socket API打开了socket layer的文件描述符。</p>
<p>Socket layer是内核中的一层软件，它会维护一个表单来记录文件描述符和UDP/TCP端口号之间的关系。同时它也会为每个socket维护一个队列用来存储接收到的packet。</p>
<p>我们在networking lab中提供的代码模板包含了一个非常原始的socket layer。</p>
<p>在socket layer之下是UDP和TCP协议层。UDP软件几乎不做任何事情，它只是检查收到的packet，获取目的端口号，并将UDP payload传输给socket layer中对应的队列。</p>
<p>TCP软件会复杂的多，它会维护每个TCP连接的状态，比如记录每个TCP连接的序列号，哪些packet没有被ACK，哪些packet需要重传。所以TCP的协议控制模块会记录大量的状态，但是UDP中不会记录任何状态。</p>
<p>UDP和TCP通常被称为传输层。networking lab提供的代码中有一个简单的UDP层，但是没有TCP的代码。</p>
<p>在TCP/UDP之下是IP层，IP层的软件通常很简单。虽然我不确定是在同一层还是下一层，与IP层在一起的还有ARP层。</p>
<p>再往下的话，我们可以认为还会有一层以太网。但是通常并没有一个独立的以太网层。通常来说这个位置是一个或者多个网卡驱动，这些驱动与实际的网卡硬件交互。网卡硬件与局域网会有实际的连接。</p>
<p>当一个packet从网络送达时，网卡会从网络中将packet接收住并传递给网卡驱动。网卡驱动会将packet向网络协议栈上层推送。</p>
<p>在IP层，软件会检查并校验IP header，将其剥离，再把剩下的数据向上推送给UDP。UDP也会检查并校验UDP header，将其剥离，再把剩下的数据加入到socket layer中相应文件描述符对应的队列中。</p>
<p>所以一个packet在被收到之后，会自底向上逐层解析并剥离header。当应用程序发送一个packet，会自顶向下逐层添加header，直到最底层packet再被传递给硬件网卡用来在网络中传输。所以内核中的网络软件通常都是被嵌套的协议所驱动。</p>
<p>这里实际上我忘了一件重要的事情，在整个处理流程中都会有packet buffer。所以当收到了一个packet之后，它会被拷贝到一个packet buffer中，这个packet buffer会在网络协议栈中传递。</p>
<p>通常在不同的协议层之间会有队列，比如在socket layer就有一个等待被应用程序处理的packet队列，这里的队列是一个linked-list。通常整个网络协议栈都会使用buffer分配器，buffer结构。</p>
<p>在我们提供的networking lab代码中，buffer接口名叫MBUF。</p>
<p><img src="/p/mit6s08121networking/p62.png"
	width="1143"
	height="832"
	srcset="/p/mit6s08121networking/p62_hu9115695183415614613.png 480w, /p/mit6s08121networking/p62_hu6654765213617764363.png 1024w"
	loading="lazy"
	
		alt="p62"
	
	
		class="gallery-image" 
		data-flex-grow="137"
		data-flex-basis="329px"
	
></p>
<p>以上就是一个典型的网络协议栈的分层图。</p>
<hr>
<h2 id="ring-buffer">Ring Buffer
</h2><p>对于今天的论文，了解packet的控制流程是如何工作的还是比较重要，这里的控制流程与前一节介绍的分层网络协议栈还不太一样。</p>
<p>有关网络协议栈，通常会有多个独立的actor会处理packet，解析packet并生成输出。</p>
<p>出于各种各样的原因，这些不同的actor之间是解耦的，这样它们可以并发的运行，并且连接不同的packet队列。这对于今天的论文来说，是非常重要的前提。</p>
<p>现在我们有了一张网卡，有了一个系统内核。当网卡收到了一个packet，它会生成一个中断。系统内核中处理中断的程序会被触发，并从网卡中获取packet。</p>
<p>因为我们不想现在就处理这个packet，中断处理程序通常会将packet挂在一个队列中并返回，packet稍后再由别的程序处理。所以中断处理程序这里只做了非常少的工作，也就是将packet从网卡中读出来，然后放置到队列中。</p>
<p>在一个传统的网络协议栈中，我们之所以想要快速的将packet从网卡中读出并存放于软件队列中，是因为通常来说网卡中用来存储packet的内存都非常小，而在计算机的RAM中，会有GB级别的内存，所以计算机的内存要大得多。</p>
<p>如果有大量的packet发送到网卡，网卡可能会没有足够的内存来存储packet，所以我们需要尽快将packet拷贝到计算机的内存中。</p>
<p>之后，在一个独立的线程中，会有一个叫做IP processing thread的程序。它会读取内存中的packet队列，并决定如何处理每一个packet。其中一个可能是将packet向上传递给UDP，再向上传递给socket layer的某个队列中，最后等待某个应用程序来读取。</p>
<p>通常来说，这里的向上传递实际上就是在同一个线程context下的函数调用。</p>
<p>另一种可能就是，这个主机实际上是个路由器，packet从一个网卡进来，经过路由需要从另一个网卡出去。</p>
<p>通过例如Linux操作系统构建路由器是非常常见的。如果你买一个wifi路由器，或者一个有线调制解调器，非常有可能里面运行的就是Linux系统，并且使用了Linux网络协议栈，因为Linux的协议栈实现了完整的路由协议。</p>
<p>所以，如果IP process thread查看了packet的目的IP地址，并决定将packet从另一个网卡转发出去，它会将packet加入到针对发送网卡的发送队列中。</p>
<p>通常来说网卡会有发送中断程序，当网卡发送了一个packet，并且准备好处理更多packet的时候，会触发一个中断。所以网卡的发送中断也很重要。</p>
<p>在这个结构中，有一点非常重要，这里存在一些并发的组件，它们以不同的方式调度。中断处理程序由网卡的发送或者接受中断触发。</p>
<p>IP processing thread就是一个内核线程。在一个处理器上，IP processing thread不能与中断处理程序同时运行，因为中断处理程序的优先级最高，不过在多核处理器上，并发度可能会更高。</p>
<p>最后，应用程序要能够读取socket layer中的packet，应用程序又是另一个独立调度的组件。所有这些组件都会参与到CPU的调度中。</p>
<p><img src="/p/mit6s08121networking/p63.png"
	width="1137"
	height="877"
	srcset="/p/mit6s08121networking/p63_hu12319267345925577640.png 480w, /p/mit6s08121networking/p63_hu17433909986223079428.png 1024w"
	loading="lazy"
	
		alt="p63"
	
	
		class="gallery-image" 
		data-flex-grow="129"
		data-flex-basis="311px"
	
></p>
<p>缓存队列经常会被提到，在上图中，总共有3个队列。这里的队列的作用是，一个独立的组件会向队列中添加packet，其他的组件会从队列中读取packet。</p>
<p>在网络系统中，这样的队列很常见，主要出于以下几个原因：</p>
<ul>
<li>
<p>其中一个原因是可以应对短暂的大流量。</p>
<p>比如，IP processing thread只能以特定的速度处理packet，但是网卡可能会以快得多的速度处理packet。对于短暂的大流量，我们想要在某个位置存储这些packet，同时等待IP processing来处理它们，这是网卡的接收方向。</p>
</li>
<li>
<p>在网卡的发送方向，我们可能需要在队列中存储大量的packet，这样网卡可以在空闲的时候一直发送packet。有的时候100%利用网卡的发送性能还是很重要的。</p>
</li>
<li>
<p>第三个原因是，队列缓存可以帮助组件之间解耦。</p>
<p>我们不会想要IP processing thread或者应用程序知道中断处理程序的具体实现。在一个传统的操作系统中，IP processing thread并不必须知道中断是什么时候发生，或者应用程序怎么运行的。</p>
</li>
</ul>
<blockquote>
<p>学生提问：同一个网卡可以即是接收方又是发送方吗？</p>
<p>Robert教授：可以的。比如说我的笔记本只有一个网卡连接到了wifi，packet会从一个网卡进入并发出。双网卡通常用在路由器中。</p>
<p>比如说我家里的wifi路由器，它就有两张网卡，其中一个网卡连接到线缆并进一步连接到整个互联网，另一个网卡是wifi网卡。</p>
<p>有很多服务器也有多个网卡，尤其是对于web服务器来说，会有一个网卡连接互联网，另一个网卡连接你的私有的敏感的数据库信息。两个网卡连接的是完全不同的网络。</p>
<p>学生提问：所以多网卡的场景在于想要连接不同的网络？</p>
<p>Robert教授：是的。如果你想要连接不同的网络，那么你需要有多块网卡。</p>
</blockquote>
<p>我想再讨论一下当packet送到网卡时，网卡会做什么操作？这与networking lab非常相关。</p>
<p>对于一个网卡的结构，会有一根线缆连接到外面的世界。网卡会检查线缆上的电信号，并将电信号转换成packet。网卡会接入到一个主机上，主机会带有网卡的驱动软件。我们需要将网卡解码出来的packet传递给主机的内存，这样软件才能解析packet。</p>
<p>网卡内有许多内置的内存，当packet到达时，网卡会将packet存在自己的缓存中，并向主机发送中断，所以网卡内部会有一个队列。而主机的驱动包含了一个循环，它会与网卡交互，并询问当前是否缓存了packet。</p>
<p>如果是的话，主机的循环会逐字节的拷贝packet到主机的内存中，再将内存中的packet加到一个队列中。</p>
<p>这是我们今天要看的论文中网卡的工作方式：网卡驱动会负责拷贝网卡内存中的数据到主机内存。这在30年前还是有意义的，但是今天通过驱动中的循环来从硬件拷贝数据是非常慢的行为。</p>
<p>即使是在同一个计算机上，外设到CPU之间的距离也非常的长，所以它们之间的交互需要的时间比较长。所以人们现在不会这么设计高速接口了。</p>
<p>接下来我将讨论一下E1000网卡的结构，这是你们在实验中要使用的网卡。</p>
<p>E1000网卡会监听网线上的电信号，但是当收到packet的时候，网卡内部并没有太多的缓存，所以网卡会直接将packet拷贝到主机的内存中，而内存中的packet会等待驱动来读取自己。所以，网卡需要事先知道它应该将packet拷贝到主机内存中的哪个位置。</p>
<p>E1000是这样工作的，主机上的软件会格式化好一个DMA ring，ring里面存储的是packet指针。所以，DMA ring就是一个数组，里面的每一个元素都是指向packet的指针。</p>
<p>当位于主机的驱动初始化网卡的时候，它会分配一定数量，例如16个1500字节长度的packet buffer，然后再创建一个16个指针的数组。</p>
<p>为什么叫ring呢？因为在这个数组中，如果用到了最后一个buffer，下一次又会使用第一个buffer。</p>
<p>主机上的驱动软件会告诉网卡DMA ring在内存中的地址，这样网卡就可以将packet拷贝到内存中的对应位置。</p>
<p>当网卡收到packet时，网卡还会记住当前应该在DMA ring的哪个位置并通过DMA将packet传输过去。</p>
<p>传输完成之后，网卡会将内部的记录的指针指向DMA ring的下一个位置，这样就可以拷贝下一个packet。</p>
<p>刚才说的都是接收packet，对应的是RX ring。类似的，驱动还会设置好发送buffer，也就是TX ring。驱动会将需要网卡传输的packet存储在 TX ring中，网卡也需要知道TX ring的地址。</p>
<p>你们在networking lab中的主要工作就是写驱动来处理这些ring。</p>
<p><img src="/p/mit6s08121networking/p64.png"
	width="1137"
	height="830"
	srcset="/p/mit6s08121networking/p64_hu7398524907513007903.png 480w, /p/mit6s08121networking/p64_hu8914899112137562952.png 1024w"
	loading="lazy"
	
		alt="p64"
	
	
		class="gallery-image" 
		data-flex-grow="136"
		data-flex-basis="328px"
	
></p>
<p>你们在networking lab中的主要工作就是写驱动来处理这些ring。</p>
<blockquote>
<p>学生提问：E1000与生产环境的高性能场景使用的网卡有什么区别吗？</p>
<p>Robert教授：E1000曾经是最优秀的网卡，没有之一，并且它也曾经使用在生产环境中，但这是很多年前的事了。现代的网卡更加的“智能”，但是我们这里介绍的DMA ring结构并没有太多的变化，现在你仍然可以发现网卡使用DMA来传输packet，内存中对应的位置是由ring buffer的位置决定。</p>
<p>现代的网卡更加“智能”在以下几个方面：</p>
<ul>
<li>
<p>E1000只能与一个RX ring传输数据，而现代网卡可以与多个RX ring同时传输数据。</p>
<p>比如说你可以告诉一张现代的网卡，将接受到的packet分别传输给21个RX ring，网卡会根据packet的内容，决定将packet送到哪个RX ring。</p>
<p>人们在很多地方都使用了这个特性，比如说在主机上运行了多个虚拟机，你可以使用这个特性将虚拟机对应的packet送到虚拟机对应的RX ring中，这样虚拟机可以直接读取相应的RX ring。（注，也就是网卡多队列）</p>
</li>
<li>
<p>现代网卡更加“智能”的体现是，它们会完成一些TCP的处理，最常见的就是校验和计算。（注，各种TCP offload）</p>
</li>
</ul>
<p>所以，现代的网卡有与E1000相似的地方，但是更加的“智能”。</p>
<p>学生提问：在接下来的networking lab中，IP层和驱动之间没有队列，是吗？</p>
<p>Robert教授：是的，lab中的网络栈已经被剥离到了最小，它比实际的网络协议栈简单的多</p>
<p>学生提问：那这样的话，性能会不会很差？</p>
<p>Robert教授：我不知道，我没有在实际环境中运行过这些代码。在写networking lab的代码时，我们没有关注过性能。大多数情况下，性能不是问题，lab中的代码可以完成一个网络协议栈95%的功能，例如处理多网卡，处理TCP。</p>
<p>学生提问：为了让网卡能支持DMA，需要对硬件做一些修改吗？在E1000之前的网卡中，所有的数据传输都是通过CPU进行传输。</p>
<p>Robert教授：我们在介绍E1000之前的网卡时，网卡并不能访问内存。我认为这里最重要的问题是，当网卡想要使用主机内存中的某个地址时，虚拟内存地址是如何翻译的。我不知道这里是如何工作的。</p>
<p>网卡通过总线，并经过一些可编程芯片连接到了DRAM，我认为在现代的计算机中，你可以设置好地址翻译表，这样网卡可以使用虚拟内存地址，虚拟内存地址会由网卡和DRAM之间的硬件翻译，这对于一些场景还是很有价值的。</p>
<p>另一方面，如果网卡需要读写一些内存地址，而内存数据现在正在CPU的cache中，那么意味着内存对应的最新数据位于CPU cache中，而不是在RAM。这种情况下，当网卡执行DMA时，我们希望网卡能读取CPU的cache而不是RAM。</p>
<p>在Intel的机器上，有一些精心设计的机制可以确保当网卡需要从内存读取数据而最新的内存数据在CPU cache中时，CPU cache而不是RAM会返回数据。一些软件基于这种机制来获得高性能。对于写数据同样的也适用，网卡可以直接将数据写到CPU cache中，这样CPU可以非常快的读到数据。</p>
<p>我们介绍的E1000的结构非常简单，但是实际中的网卡机制非常的复杂。</p>
</blockquote>
<hr>
<h2 id="receive-livelock-1">Receive Livelock
</h2><p>接下来我们看一下今天的<a class="link" href="https://pdos.csail.mit.edu/6.828/2020/readings/mogul96usenix.pdf"  target="_blank" rel="noopener"
    >论文</a>

。因为我们已经介绍了很多论文相关的背景知识，我们直接来看一下论文的图1。我们之后根据论文中的图来开展讨论。</p>
<p>这张图是一个路由器的性能图。这是一个有两张网卡的路由器，它的工作是从一个网卡接收packet，再从另一个网卡送出 。</p>
<p>X轴是接收速率，也就是接收端网卡的收到packet的速率。Y轴是发送速率，也就是观察到的发送端网卡发送packet的速率。</p>
<p>我们关心的是实心圆对应的曲线，它先上升，再下降。所以即使还不知道任何上下文，看到这个图之后我们会问自己，为什么这个曲线先上升，再下降？曲线的转折点有什么特殊之处？是什么决定了曲线的上升斜率和下降斜率？即使不知道任何背景知识，我们还是可以问出这么多问题。</p>
<p><img src="/p/mit6s08121networking/p65.png"
	width="1121"
	height="553"
	srcset="/p/mit6s08121networking/p65_hu13332214379261348172.png 480w, /p/mit6s08121networking/p65_hu2982014947979558389.png 1024w"
	loading="lazy"
	
		alt="p65"
	
	
		class="gallery-image" 
		data-flex-grow="202"
		data-flex-basis="486px"
	
></p>
<p>首先，为什么这条曲线开始会上升？</p>
<blockquote>
<p>学生回答：在到达处理的瓶颈之前，路由器可以处理更多的接收方向的packet，也可以处理更多的发送发向的packet。</p>
</blockquote>
<p>完全正确，在出现错误之前，对于每个接收到的packet，路由器都可以转发出去。比如说当packet以2000pps的速度接收时，路由器直接将packet从输入网卡拷贝到输出网卡，所以路由器的发送速率与接收速率一样，都是2000pps，所以这里X轴与Y轴的值相等。这种状态一直保持，直到曲线到达转折点。</p>
<p>那么为什么曲线不是一直上升的呢？</p>
<blockquote>
<p>学生回答：是不是因为中断不能被处理导致的？</p>
<p>Robert教授：这个其实是为什么曲线会下降的原因。我这里的问题是为什么曲线在某个点之后就不再上升了。假设这里的设计是合理的，对于一个合理的系统，对应的曲线会一直上升吗？</p>
<p>学生回答：我认为不会，就算系统能足够快的处理packet，对于足够多的packet，还是可能触发系统的瓶颈。</p>
</blockquote>
<p>是的，CPU的算力并不是无限的，CPU最多每秒执行一定数量的指令。</p>
<p>对于每个packet，IP软件会查看packet的header，检查校验和，根据目的地址查找转发表等等，这个过程会消耗数百甚至数千条CPU指令时间来处理一个packet。所以，我们不能期望曲线能一直向上走，它必然会在某个位置停止向上。</p>
<p>上面的图中，曲线在5000的位置就停止不再上升了，这告诉我们这台机器处理每个packet要消耗200微秒。所以，曲线的转折点隐含的包含了处理一个packet需要的时间信息。</p>
<p>虽然这只是一个猜想，但是通常与真实的结果非常相近。或许我们可以修改软件使其更加的高效，我们可以优化到处理每个packet只需要150微秒，我们或许可以将曲线的转折点向上移一些，但是在到达了这台机器每秒能处理的packet数量的极限时，我们还是会到达曲线的转折点。</p>
<p>除了CPU的性能，还有一些不是必然存在的瓶颈需要注意一下。最明显的一个就是网络的性能。如果你使用的网络只有10Mb/s，那么底层的网路硬件最多就能按照这个速率传输数据，这也有可能构成一个限制。</p>
<p>所以也有可能是因为网络传输的速率决定了曲线的顶点是在5000pps这个位置。论文中并没有说明究竟是CPU还是网速是这里的限制因素，但是对于一个10Mb/s的网络，如果你传输小包的话，是可以达到10-15 Kpps，这实际上是网线的能达到的极限，而上图中转折点对应的5Kpps远小于10-15Kpps，所以几乎可以确定限制是来自CPU或者内存，而不是网络本身。</p>
<p>在一个设计良好的路由器中，如果处理每个packet要200微秒，那么我们期望看到的是不论负载多高，路由器至少每秒能处理5000个packet。所以我们期望看到的曲线在5000pps之后是一条水平线，路由器每秒处理5000个packet，并丢弃掉其他的packet。</p>
<p>但是我们实际拥有的曲线会更加的糟糕，当收到的packets超过5000pps时，成功转发的packets随着收到的packet的增多反而趋向于0。为什么曲线会下降呢？前面有同学已经提到了。</p>
<p>论文作者给出的原因是，随着packet接收速率的增加，每个收到的packet都会生成一个中断，而这里的中断的代价非常高，因为中断涉及到CPU将一个packet从网卡拷贝到主机的内存中。如果我们知道packet将会以10K每秒的速率到达，并且我们知道我们不能处理这么多packet，那么我们可以期望的最好结果就是每秒转发5000个packet，并且丢弃5000个packet之外的其他packet。</p>
<p>但是实际上，5000个packet之外的其他packet，每个都生成了一个昂贵的中断，收到的packet越多，生成的中断就越多。而中断有更高的优先级，所以每一个额外的packet都会消耗CPU时间，导致更少的CPU时间可以用来完成packet的转发。最后，100%的CPU时间都被消耗用来处理网卡的输入中断，CPU没有任何时间用来转发packet。</p>
<p>这里曲线的下降被称为中断的Livelock，这是一个在很多系统中都会出现的现象。</p>
<p>这里背后的原因是有两个独立的任务，比如这里的两个任务是输入中断和转发packet程序。由于调度的策略，输入中断的优先级更高，使得转发packet的任务可能分配不到任何CPU时间。</p>
<p>几乎在任何需要处理输入的系统中，如果输入速率过高，都有可能出现Livelock。</p>
<p>Livelock不仅会因为CPU耗尽而发生，也可能是其他原因，比如说网卡的DMA耗尽了RAM的处理时间，那么网卡占据了RAM导致CPU不能使用RAM。所以，即使你拥有大量的CPU空闲时间，还是有可能触发Livelock。不管怎样，这曲线的下降被称为Livelock。</p>
<p>你或许会问，不能处理的packet最后怎么样了？我们回想一下网络协议软件的结构，网卡会通知网卡的接收中断，接收中断将packet拷贝到队列缓存中，之后会有一个线程处理队列缓存中的packet。</p>
<p>所以packet会在队列缓存中丢失。队列缓存有一个最大的长度，至少RAM的大小是有限制大，但是队列缓存的大小会远小于RAM的大小。如果网卡的接收中断从网卡获得了一个packet，并且发现队列缓存的长度已经是最长了，接收中断程序会丢弃packet。</p>
<hr>
<h2 id="如何解决livelock">如何解决Livelock
</h2><p><a class="link" href="https://pdos.csail.mit.edu/6.828/2020/readings/mogul96usenix.pdf"  target="_blank" rel="noopener"
    >论文</a>

作者对于Livelock提出了一种解决方法。这种解决方法的最直接结果就是，当packet的输入速率达到了5000pps，随着输入速率的增加，转发性能维持在5000pps。</p>
<p><img src="/p/mit6s08121networking/p66.png"
	width="1136"
	height="554"
	srcset="/p/mit6s08121networking/p66_hu12478504949961648075.png 480w, /p/mit6s08121networking/p66_hu14289068479660716522.png 1024w"
	loading="lazy"
	
		alt="p66"
	
	
		class="gallery-image" 
		data-flex-grow="205"
		data-flex-basis="492px"
	
></p>
<p>曲线后半部分的水平是一种完美的non-livelock性能曲线。之所以是水平的，是因为受CPU的限制，最多只能处理5000pps的转发。</p>
<p>在这个解决方案中，还是存在处理packet的线程和中断处理程序。当网卡第一次触发中断时，会导致中断处理函数的运行。但是中断处理函数并不会从网卡拷贝packet，相应的，它会唤醒处理packet的线程，并且关闭网卡的中断，这样接下来就收不到任何中断了。</p>
<p>处理packet的线程会有一个循环，在循环中它会检查并从网卡拉取几个packet，论文中我记得是最多拉取5个packet，之后再处理这些packet。</p>
<p>所以现在处理packet的线程是从网卡读取packet，而不是从中断处理程序读取。如果网卡中没有等待处理的packet，那么处理线程会重新打开网卡中断，并进入sleep状态。</p>
<p>因为最后打开了中断，当下一个packet到达时，中断处理程序会唤醒处理packet线程，线程会从sleep状态苏醒并继续处理packet。这就是论文介绍的解决Livelock的方法。</p>
<p>这里的处理方式实际上是将中断模式（Interrupt Scheme）转变成了轮询模式（Polling Scheme）。</p>
<p>在高负载的情况下，中断会被关闭，并且CPU会一直运行这里的循环中，不断读取packet并处理packet。因为中断被关闭了，CPU用来运行主线程的时间不会被中断占据。在低负载的情况下，中断会被打开，在收到packet之后，线程会被中断处理程序直接唤醒。</p>
<blockquote>
<p>学生提问：这里的循环会检查所有的设备吗？还是只会检查产生中断的设备？</p>
<p>Robert教授：这是个好问题，如果存在多个网卡，我并不知道这里的循环会怎么工作。</p>
<p>一个非常合理的设计是，packet处理线程需要记录每个网卡是在中断模式还是在轮询模式，然后只对轮询模式的网卡。。。等一下，因为中断处理程序现在不从网卡读取packet，所以线程中的循环可以直接检查所有网卡，如果网卡中有待处理的packet，就读取几个packet并处理。</p>
<p>如果所有的网卡都没有待处理的packet，主循环会打开所有网卡的中断，并进入sleep状态。之后，任何一个网卡的中断都会唤醒packet处理线程。</p>
<p>学生提问：当处理线程运行的时候，packet是如何进入到一个等待读取的队列中？我觉得网卡上只会有一个packet。</p>
<p>Robert教授：最开始的时候，packet会在网卡自己的内存中按照队列形式缓存。而处理线程的主循环会询问每个网卡是否在自己的内存中有待处理的packet。如果有的话，主循环会在主机的RAM中申请缓存，再将packet数据从网卡中拷贝到RAM中的缓存，再处理packet。</p>
<p>学生提问：所以一次可以拷贝多个packet？</p>
<p>Robert教授：是的，我认为论文中说的是一次拷贝5个packet。即使有100packet在网卡中等待处理，一次也只会读取5个，这样可以避免阻塞输出。</p>
<p>学生提问：但是这就要求提升网卡的内存容量了吧？</p>
<p>Robert教授：Well，我不知道要多少内存容量。</p>
<p>在Livelock曲线的转折点之前，都是靠中断来处理的。在转折点之前，如果网卡收到了一个packet，处理线程会立即被唤醒并读出packet。但是在转折点之后，处理线程就一直在轮询模式而不是中断模式。</p>
<p>在转折点之后，肯定会有丢包，因为现在输入速率和输出速率之间是有差异的，而这个差异间的packet都被丢弃了。因为这些packet不论如何都会被丢弃，增加网卡的内存并不太能减少这里的丢包，所以不太确定网卡是否需要增加内存容量。</p>
<p>在论文中，一次会读取最多5个packet，那么网卡必然需要存储5个packet的内存容量，但是更多的packet是否有好处就不太确定了。</p>
<p>网卡上的buffer大小，对于短暂的高pps有帮助，这样可以保存好packet等处理线程来读取它们。但是我们这里并没有讨论短暂的overload，我们讨论的是持续的overload。所以增加网卡的buffer，并不是很有用。</p>
<p>学生提问：当网卡中断被关闭了，网卡还能在自己的buffer上加入新的packet吗？</p>
<p>Robert教授：可以的。网卡是自治的，不论中断是打开还是关闭，只要有一个packet到达了网卡，网卡都会将packet加入到自己的缓存队列中。</p>
<p>当然不同的网卡设计可能非常不一样，但是在论文中网卡不会调用DMA，不会主动访问主机内存。如果网卡上内存都用光了，packet会被丢弃。</p>
<p>所以，在这里的设计中，丢包发生在网卡内部。在一个overload的场景下，网卡中的队列总是满的，当再收到一个packet时，网卡会直接丢包，这样就不会浪费CPU时间。网卡可以在不消耗CPU时间的前提下直接丢包，是避免Livelock的直接原因。</p>
<p>学生提问：有没有这种可能，CPU从网卡读取packet，但是处理线程内部的队列满了？</p>
<p>Robert教授：当然。在其他地方肯定也有瓶颈，例如对于收到的packet，需要交给监听了socket的应用程序去处理，如果应用程序并没有以足够快的速度读取packet，相应的socket buffer会满，那么packet会在处理线程中丢包，而这也可能导致Livelock。</p>
<p>Livelock发生的根本原因是我们浪费时间处理了一些最终会被丢弃的packet，这里的处理是徒劳。</p>
<p>另一种发生Livelock的可能是，当负载增加时，我们可能会消耗100%的CPU时间在packet处理线程上，而留给应用程序的CPU时间为0，这时还是会发生Livelock。</p>
<p>论文在第六节中有相应的介绍，如果一个packet将要被传输给本地的应用程序，网络线程会查看应用程序的socket buffer，如果socket buffer过满的话，网络线程会停止从网卡读取packet，直到socket buffer变小。</p>
<p>这意味着网络线程会停止运行，并给应用程序机会运行并处理packet，所以如果你不够小心的话，你可能会在任何阶段都经历类似Livelock的问题。</p>
</blockquote>

</section>


    <footer class="article-footer">
    

    <section class="article-lastmod">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <span>
            最后更新于 Nov 13, 2024 17:04 &#43;0800
        </span>
    </section></footer>




    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI&#43;WdtXRGWt2kTvGFasHpSy3SV"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG&#43;vnGctmUb0ZY0l8"crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05"crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.body, {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>
    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="has-image">
    <a href="/p/mit6s08123rcu/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08123rcu/bg.91a08bf3fe0a8ca435e8fbc902291fd5_hu4589796922609635382.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：23RCU"
                        
                        data-hash="md5-kaCL8/4KjKQ16PvJAikf1Q==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：23RCU</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/mit6s08122meltdown/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08122meltdown/19.8d880549dccba2f0c1613b3e41a721e5_hu3753156070077914420.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：22Meltdown"
                        
                        data-hash="md5-jYgFSdzLovDBYTs&#43;Qach5Q==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：22Meltdown</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/mit6s08120kernels-and-hll/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08120kernels-and-hll/bg.4175e6a2793e0fc340e5aced2529e40b_hu6405785273338381617.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：20Kernels and HLL"
                        
                        data-hash="md5-QXXmonk&#43;D8NA5aztJSnkCw==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：20Kernels and HLL</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/mit6s08119virtual-machines/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08119virtual-machines/bg.b02a7ba1d946705c0cf2809bcf960db8_hu14546491865979434532.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：19Virtual Machines  "
                        
                        data-hash="md5-sCp7odlGcFwM8oCbz5YNuA==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：19Virtual Machines  </h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/mit6s08118os-organization/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08118os-organization/bg.6254618fb3eb08f3bf5d7cd89d4cd672_hu15449325963333300792.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：18OS organization"
                        
                        data-hash="md5-YlRhj7PrCPO/XXzYnUzWcg==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：18OS organization</h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    

    <footer class="site-footer">

    <section class="copyright">
        &copy; 
        
        2024 echudet
    </section>
    
    <section class="powerby">
        


        <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>

        <script language="javascript"> 
            var now = new Date();
            function createtime(){
                now.setTime(now.getTime()+250);
                var grt= new Date("2024/11/10 00:00:00"); 
                days = (now - grt ) / 1000 / 60 / 60 / 24;
                dnum = Math.floor(days);
                hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
                hnum = Math.floor(hours);
                if(String(hnum).length ==1 ){hnum = "0" + hnum;}
                minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
                mnum = Math.floor(minutes);
                if(String(mnum).length ==1 ){mnum = "0" + mnum;}
                seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
                snum = Math.round(seconds);
                if(String(snum).length ==1 ){snum = "0" + snum;}

                document.getElementById("timeDate").innerHTML = "本站已稳定运行"+dnum+" 天 ";
                document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒<br>"
            }
            setInterval("createtime()",250); 
        </script> 

        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        
    
        
         
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
        

        共 653739 字 , 30 篇文章<br>使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.29.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>

</footer>



    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>


    </body>
</html>
