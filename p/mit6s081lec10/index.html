<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="Multiprocessors and locking">
<title>MIT6S081Lec10</title>

<link rel='canonical' href='https://echudet.github.io/p/mit6s081lec10/'>

<link rel="stylesheet" href="/scss/style.min.a7f637593c1d99350f36f270c9abc65cf39ec34b45847eb2fa40efef51b94c92.css"><meta property='og:title' content="MIT6S081Lec10">
<meta property='og:description' content="Multiprocessors and locking">
<meta property='og:url' content='https://echudet.github.io/p/mit6s081lec10/'>
<meta property='og:site_name' content='echudet'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2024-09-17T22:02:50&#43;08:00'/><meta property='article:modified_time' content='2024-11-12T23:05:03&#43;08:00'/><meta property='og:image' content='https://echudet.github.io/p/mit6s081lec10/bg.png' />
<meta name="twitter:title" content="MIT6S081Lec10">
<meta name="twitter:description" content="Multiprocessors and locking"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://echudet.github.io/p/mit6s081lec10/bg.png' />
    <link rel="shortcut icon" href="/timer.ico" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu11199958555974308744.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">⌨️</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">echudet</a></h1>
            <h2 class="site-description">探索编程的学生一枚</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/EchudeT'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://twitter.com'
                        target="_blank"
                        title="Twitter"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>档案</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>Links</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#预习">预习</a></li>
    <li><a href="#为什么要用锁"><strong>为什么要用锁</strong></a></li>
    <li><a href="#锁的作用"><strong>锁的作用</strong></a></li>
    <li><a href="#竞态条件"><strong>竞态条件</strong></a></li>
    <li><a href="#代码locks">代码：Locks</a></li>
    <li><a href="#代码使用锁">代码：使用锁</a></li>
    <li><a href="#死锁和锁排序">死锁和锁排序</a></li>
    <li><a href="#锁和中断处理函数">锁和中断处理函数</a></li>
    <li><a href="#指令和内存访问排序">指令和内存访问排序</a></li>
    <li><a href="#睡眠锁">睡眠锁</a></li>
    <li><a href="#真实世界">真实世界</a></li>
    <li><a href="#关于posix与pthread">关于POSIX与Pthread</a></li>
    <li><a href="#正课">正课</a></li>
    <li><a href="#为什么要用锁-1">为什么要用锁</a></li>
    <li><a href="#锁如何避免竞争条件race-condition">锁如何避免竞争条件（race condition）</a></li>
    <li><a href="#什么时候使用锁">什么时候使用锁</a></li>
    <li><a href="#锁的特性和死锁">锁的特性和死锁</a></li>
    <li><a href="#锁与性能">锁与性能</a></li>
    <li><a href="#xv6中uart模块对于锁的使用">XV6中UART模块对于锁的使用</a></li>
    <li><a href="#自旋锁的实现一">自旋锁的实现（一）</a></li>
    <li><a href="#自旋锁的实现二">自旋锁的实现（二）</a></li>
    <li><a href="#总结">总结</a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/mit6s081lec10/">
                <img src="/p/mit6s081lec10/bg_hu12601174270838160475.png"
                        srcset="/p/mit6s081lec10/bg_hu12601174270838160475.png 800w, /p/mit6s081lec10/bg_hu16748475921218369486.png 1600w"
                        width="800" 
                        height="1200" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081Lec10" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/mit6s081/" >
                Mit6s081
            </a>
        
            <a href="/categories/os/" >
                Os
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/mit6s081lec10/">MIT6S081Lec10</a>
        </h2>
    
        
        <h3 class="article-subtitle">
            Multiprocessors and locking
        </h3>
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2024-09-17</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 45 分钟
                </time>
            </div>
        <div class="article-lastmod">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time>
                    Nov 12, 2024 23:05 &#43;0800
                </time>
            </div></footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="lecture-10-multiprocessors-and-locking">Lecture 10 Multiprocessors and locking
</h1><h2 id="预习">预习
</h2><h2 id="为什么要用锁"><strong>为什么要用锁</strong>
</h2><p>大多数内核，包括xv6，交错执行多个活动。交错的一个来源是多处理器硬件：计算机的多个CPU之间独立执行，如xv6的RISC-V。多个处理器共享物理内存，xv6利用共享（sharing）来维护所有CPU进行读写的数据结构。</p>
<p>这种共享增加了一种可能性，即一个CPU读取数据结构，而另一个CPU正在更新它，甚至多个CPU同时更新相同的数据；如果不仔细设计，这种并行访问可能会产生不正确的结果或损坏数据结构。</p>
<p>即使在单处理器上，内核也可能在许多线程之间切换CPU，导致它们的执行交错。</p>
<p>最后，如果中断发生在错误的时间，设备中断处理程序修改与某些可中断代码相同的数据，可能导致数据损坏。</p>
<p>单词并发（concurrency）是指由于多处理器并行、线程切换或中断，多个指令流交错的情况。</p>
<p>内核中充满了并发访问数据（concurrently-accessed data）。例如，两个CPU可以同时调用<code>kalloc</code>，从而从空闲列表的头部弹出。</p>
<p>以并发下的正确性为目标的策略和支持它们的抽象称为并发控制技术（concurrency control techniques）。</p>
<h2 id="锁的作用"><strong>锁的作用</strong>
</h2><p>锁提供了互斥，确保一次只有一个CPU可以持有锁。如果程序员将每个共享数据项关联一个锁，并且代码在使用一个数据项时总是持有相关联的锁，那么该项一次将只被一个CPU使用。在这种情况下，我们说锁保护数据项。尽管锁是一种易于理解的并发控制机制，但锁的缺点是它们会扼杀性能，因为它们会串行化并发操作。</p>
<h2 id="竞态条件"><strong>竞态条件</strong>
</h2><p>考虑两个进程在两个不同的CPU上调用<code>wait</code>。<code>wait</code>释放了子进程的内存。因此，在每个CPU上，内核将调用<code>kfree</code>来释放子进程的页面。内核分配器维护一个链接列表：<code>kalloc()</code> 从空闲页面列表中取出（pop）一个内存页面；<code>kfree()</code>将一个内存页面添加（push）到空闲列表上。为了获得最佳性能，我们可能希望两个父进程的<code>kfree</code>可以并行执行，而不必等待另一个进程，但是考虑到xv6的<code>kfree</code>实现，这将导致错误。</p>
<p>链表位于两个CPU共享的内存中，这两个CPU使用<code>load</code>和<code>store</code>指令操作链表。（实际上，每个处理器都有cache，但从概念上讲，多处理器系统的行为就像所有CPU共享一块单独的内存一样）如果没有并发请求，您可能以如下方式实现列表push操作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">element</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">element</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">element</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> 
</span></span><span class="line"><span class="cl"><span class="nf">push</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">element</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">l</span> <span class="o">=</span> <span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">l</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">l</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">l</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">list</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果存在隔离性，那么这个实现是正确的。但是，如果多个副本并发执行，代码就会出错。如果两个CPU同时执行<code>push</code>，如图6.1所示，两个CPU都可能在执行第16行之前执行第15行，这会导致如图6.2所示的不正确的结果。然后会有两个类型为<code>element</code>的列表元素使用<code>next</code>指针设置为<code>list</code>的前一个值。当两次执行位于第16行的对<code>list</code>的赋值时，第二次赋值将覆盖第一次赋值；第一次赋值中涉及的元素将丢失。</p>
<p><u>竞态条件</u>是指多个进程读写某些共享数据（至少有一个访问是写入）的情况。竞争通常包含bug，要么丢失更新（如果访问是写入的），要么读取未完成更新的数据结构。竞争的结果取决于进程在处理器运行的确切时机以及内存系统如何排序它们的内存操作，这可能会使竞争引起的错误难以复现和调试。例如，在调试<code>push</code>时添加<code>printf</code>语句可能会改变执行的时间，从而使竞争消失。</p>
<p>避免竞争的通常方法是使用锁。锁确保互斥，这样一次只有一个CPU可以执行<code>push</code>中敏感的代码行；这使得上述情况不可能发生。</p>
<p>上面代码的正确上锁版本只添加了几行（用黄色突出显示）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">element</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">element</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">element</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">lock</span> <span class="n">listlock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> 
</span></span><span class="line"><span class="cl"><span class="nf">push</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">element</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">l</span> <span class="o">=</span> <span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">l</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">l</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listlock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">l</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">list</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listlock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>acquire</code>和<code>release</code>之间的指令序列通常被称为临界区域（critical section）。锁的作用通常被称为保护<code>list</code>。</p>
<p>当我们说锁保护数据时，我们实际上是指锁保护适用于数据的某些不变量集合。不变量是跨操作维护的数据结构的属性。</p>
<p>通常，操作的正确行为取决于操作开始时不变量是否为真。操作可能暂时违反不变量，但必须在完成之前重新建立它们。</p>
<p>例如，在链表的例子中，不变量是<code>list</code>指向列表中的第一个元素，以及每个元素的<code>next</code>字段指向下一个元素。<code>push</code>的实现暂时违反了这个<u>不变量</u>：在第17行，<code>l-&gt;next</code>指向<code>list</code>（注：则此时<code>list</code>不再指向列表中的第一个元素，即违反了不变量），但是<code>list</code>还没有指向<code>l</code>（在第18行重新建立）。我们上面检查的竞态条件发生了，因为第二个CPU执行了依赖于列表不变量的代码，而这些代码（暂时）被违反了。正确使用锁可以确保每次只有一个CPU可以对临界区域中的数据结构进行操作，因此当数据结构的不变量不成立时，将没有其他CPU对数据结构执行操作。</p>
<p>不变量（invariant） 是在程序或数据结构的某些时刻始终必须保持为真的条件或规则。它们是系统运行过程中所必须遵循的“永恒真理”，确保数据结构处于正确的状态。如果不变量被违反，程序的行为可能会出现错误。</p>
<p>不变量确保了数据结构的正确性，而在并发环境下（多CPU同时操作），如果没有锁的保护，某个CPU在不变量被暂时打破时访问数据结构，就可能导致不一致的情况。</p>
<p>因此，锁的作用是确保数据结构的修改过程能够独占，防止其他CPU在不变量暂时不成立时访问。</p>
<p>您可以将锁视为串行化（serializing）并发的临界区域，以便同时只有一个进程在运行这部分代码，从而维护不变量（假设临界区域设定了正确的隔离性）。您还可以将由同一锁保护的临界区域视为彼此之间的原子，即彼此之间只能看到之前临界区域的完整更改集，而永远看不到部分完成的更新。</p>
<p>尽管正确使用锁可以改正不正确的代码，但<u>锁限制了性能</u>。</p>
<p>如果两个进程并发调用<code>kfree</code>，锁将串行化这两个调用，我们在不同的CPU上运行它们没有任何好处。如果多个进程同时想要相同的锁或者锁经历了争用，则称之为发生冲突（conflict）。内核设计中的一个主要挑战是避免锁争用。</p>
<p><u>锁的位置</u>对性能也很重要。例如，在<code>push</code>中把<code>acquire</code>的位置提前也是正确的：将<code>acquire</code>移动到第13行之前完全没问题。但这样对<code>malloc</code>的调用也会被串行化，从而降低了性能。</p>
<h2 id="代码locks">代码：Locks
</h2><p>Xv6有两种类型的锁：自旋锁（spinlocks）和睡眠锁（sleep-locks）。</p>
<p>从自旋锁（注：自旋，即循环等待）开始。</p>
<p>Xv6将自旋锁表示为<code>struct spinlock</code>。结构体中的重要字段是<code>locked</code>，当锁可用时为零，当它被持有时为非零。</p>
<p>从逻辑上讲，xv6应该通过执行以下代码来获取锁</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">acquire</span><span class="p">(</span><span class="k">struct</span> <span class="n">spinlock</span><span class="o">*</span> <span class="n">lk</span><span class="p">)</span> <span class="c1">// does not work!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(;;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">locked</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">lk</span><span class="o">-&gt;</span><span class="n">locked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>不幸的是，这种实现不能保证多处理器上的互斥。</p>
<p>可能会发生两个CPU同时到达第5行，看到<code>lk-&gt;locked</code>为零，然后都通过执行第6行占有锁。此时就有两个不同的CPU持有锁，从而违反了互斥属性。我们需要的是一种方法，使第5行和第6行作为原子（即不可分割）步骤执行。</p>
<p>因为锁被广泛使用，多核处理器通常提供实现第5行和第6行的原子版本的指令。</p>
<p>在RISC-V上，这条指令是<code>amoswap r, a</code>。<code>amoswap</code>读取内存地址<code>a</code>处的值，将寄存器<code>r</code>的内容写入该地址，并将其读取的值放入<code>r</code>中。</p>
<p>也就是说，它交换寄存器和指定内存地址的内容。</p>
<p>它原子地执行这个指令序列，使用特殊的硬件来防止任何其他CPU在读取和写入之间使用内存地址。</p>
<p>Xv6的<code>acquire</code>使用可移植的C库调用归结为<code>amoswap</code>的指令<code>__sync_lock_test_and_set</code>；返回值是<code>lk-&gt;locked</code>的旧（交换了的）内容。</p>
<p><code>acquire</code>函数将swap包装在一个循环中，直到它获得了锁前一直重试（自旋）。</p>
<p>每次迭代将1与<code>lk-&gt;locked</code>进行swap操作，并检查<code>lk-&gt;locked</code>之前的值。</p>
<p>如果之前为0，swap已经把<code>lk-&gt;locked</code>设置为1，那么我们就获得了锁；如果前一个值是1，那么另一个CPU持有锁，我们原子地将1与<code>lk-&gt;locked</code>进行swap的事实并没有改变它的值。</p>
<p>获取锁后，用于调试，<code>acquire</code>将记录下来获取锁的CPU。<code>lk-&gt;cpu</code>字段受锁保护，只能在保持锁时更改。</p>
<p>函数<code>release</code>与<code>acquire</code>相反：它清除<code>lk-&gt;cpu</code>字段，然后释放锁。</p>
<p>从概念上讲，<code>release</code>只需要将0分配给<code>lk-&gt;locked</code>。C标准允许编译器用多个存储指令实现赋值，因此对于并发代码，C赋值可能是非原子的。</p>
<p>因此<code>release</code>使用执行原子赋值的C库函数<code>__sync_lock_release</code>。该函数也可以归结为RISC-V的<code>amoswap</code>指令。</p>
<h2 id="代码使用锁">代码：使用锁
</h2><p>Xv6在许多地方使用锁来避免竞争条件（race conditions）。</p>
<p>如上所述，<code>kalloc</code>(kernel/kalloc.c:69)和<code>kfree</code>(kernel/kalloc.c:47)就是一个很好的例子。</p>
<p>使用锁的一个<strong>困难</strong>部分是决定要使用多少锁，以及每个锁应该保护哪些数据和不变量。</p>
<p>有几个基本原则。</p>
<p>首先，任何时候可以被一个CPU写入，同时又可以被另一个CPU读写的变量，都应该使用锁来防止两个操作重叠。</p>
<p>其次，请记住锁保护不变量（invariants）：如果一个不变量涉及多个内存位置，通常所有这些位置都需要由一个锁来保护，以确保不变量不被改变。</p>
<p>为了提高效率，不要向太多地方上锁是很重要的，因为锁会降低并行性。</p>
<p>如果并行性不重要，那么可以安排只拥有一个线程，而不用担心锁。</p>
<p>一个简单的内核可以在多处理器上做到这一点，方法是拥有一个锁，这个锁必须在进入内核时获得，并在退出内核时释放（尽管如管道读取或<code>wait</code>的系统调用会带来问题）。</p>
<p>许多单处理器操作系统已经被转换为使用这种方法在多处理器上运行，有时被称为“大内核锁（big kernel lock）”。</p>
<p>但是这种方法牺牲了并行性：一次只能有一个CPU运行在内核中。如果内核做一些繁重的计算，使用一组更细粒度的锁的集合会更有效率，这样内核就可以同时在多个处理器上执行。</p>
<p>作为粗粒度锁的一个例子，xv6的<em><strong>kalloc.c</strong></em>分配器有一个由单个锁保护的空闲列表。</p>
<p>如果不同CPU上的多个进程试图同时分配页面，每个进程在获得锁之前将必须在<code>acquire</code>中自旋等待。自旋会降低性能，因为它只是无用的等待。</p>
<p>如果对锁的争夺浪费了很大一部分CPU时间，也许可以通过改变分配器的设计来提高性能，使其拥有多个空闲列表，每个列表都有自己的锁，以允许真正的并行分配。</p>
<p>作为细粒度锁定的一个例子，xv6对每个文件都有一个单独的锁，这样操作不同文件的进程通常可以不需等待彼此的锁而继续进行。</p>
<p>文件锁的粒度可以进一步细化，以允许进程同时写入同一个文件的不同区域。最终的锁粒度决策需要由性能测试和复杂性考量来驱动。</p>
<p>作为预览，表6.3列出了xv6中的所有锁。</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>锁</strong></th>
          <th><strong>描述</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>bcache.lock</code></td>
          <td>保护块缓冲区缓存项（block buffer cache entries）的分配</td>
      </tr>
      <tr>
          <td><code>cons.lock</code></td>
          <td>串行化对控制台硬件的访问，避免混合输出</td>
      </tr>
      <tr>
          <td><code>ftable.lock</code></td>
          <td>串行化文件表中文件结构体的分配</td>
      </tr>
      <tr>
          <td><code>icache.lock</code></td>
          <td>保护索引结点缓存项（inode cache entries）的分配</td>
      </tr>
      <tr>
          <td><code>vdisk_lock</code></td>
          <td>串行化对磁盘硬件和DMA描述符队列的访问</td>
      </tr>
      <tr>
          <td><code>kmem.lock</code></td>
          <td>串行化内存分配</td>
      </tr>
      <tr>
          <td><code>log.lock</code></td>
          <td>串行化事务日志操作</td>
      </tr>
      <tr>
          <td>管道的<code>pi-&gt;lock</code></td>
          <td>串行化每个管道的操作</td>
      </tr>
      <tr>
          <td><code>pid_lock</code></td>
          <td>串行化next_pid的增量</td>
      </tr>
      <tr>
          <td>进程的<code>p-&gt;lock</code></td>
          <td>串行化进程状态的改变</td>
      </tr>
      <tr>
          <td><code>tickslock</code></td>
          <td>串行化时钟计数操作</td>
      </tr>
      <tr>
          <td>索引结点的 <code>ip-&gt;lock</code></td>
          <td>串行化索引结点及其内容的操作</td>
      </tr>
      <tr>
          <td>缓冲区的<code>b-&gt;lock</code></td>
          <td>串行化每个块缓冲区的操作</td>
      </tr>
  </tbody>
</table></div>
<p>Figure 6.3: Locks in xv6</p>
<h2 id="死锁和锁排序">死锁和锁排序
</h2><p>如果在内核中执行的代码路径必须同时持有数个锁，那么所有代码路径以相同的顺序获取这些锁是很重要的。</p>
<p>如果它们不这样做，就有死锁的风险。</p>
<p>假设xv6中的两个代码路径需要锁A和B，但是代码路径1按照先A后B的顺序获取锁，另一个路径按照先B后A的顺序获取锁。假设线程T1执行代码路径1并获取锁A，线程T2执行代码路径2并获取锁B。接下来T1将尝试获取锁B，T2将尝试获取锁A。</p>
<p>两个获取都将无限期阻塞，因为在这两种情况下，另一个线程都持有所需的锁，并且不会释放它，直到它的获取返回。</p>
<p>为了避免这种死锁，所有代码路径必须以相同的顺序获取锁。全局锁获取顺序的需求意味着锁实际上是每个函数规范的一部分：调用者必须以一种使锁按照约定顺序被获取的方式调用函数。</p>
<p>由于<code>sleep</code>的工作方式（见第7章），Xv6有许多包含每个进程的锁（每个<code>struct proc</code>中的锁）在内的长度为2的锁顺序链。</p>
<p>例如，<code>consoleintr</code> (*<strong>kernel/console.c*</strong>:138)是处理键入字符的中断例程。当换行符到达时，任何等待控制台输入的进程都应该被唤醒。为此，<code>consoleintr</code>在调用<code>wakeup</code>时持有<code>cons.lock</code>，<code>wakeup</code>获取等待进程的锁以唤醒它。</p>
<p>因此，全局避免死锁的锁顺序包括必须在任何进程锁之前获取<code>cons.lock</code>的规则。</p>
<p>文件系统代码包含xv6最长的锁链。例如，创建一个文件需要同时持有目录上的锁、新文件inode上的锁、磁盘块缓冲区上的锁、磁盘驱动程序的<code>vdisk_lock</code>和调用进程的<code>p-&gt;lock</code>。为了避免死锁，文件系统代码总是按照前一句中提到的顺序获取锁。</p>
<p>遵守全局死锁避免的顺序可能会出人意料地困难。</p>
<p>有时锁顺序与逻辑程序结构相冲突，例如，也许代码模块M1调用模块M2，但是锁顺序要求在M1中的锁之前获取M2中的锁。</p>
<p>有时锁的身份是事先不知道的，也许是因为必须持有一个锁才能发现下一个要获取的锁的身份。</p>
<p>这种情况在文件系统中出现，因为它在路径名称中查找连续的组件，也在<code>wait</code>和<code>exit</code>代码中出现，因为它们在进程表中寻找子进程。</p>
<p>最后，死锁的危险通常是对细粒度锁定方案的限制，因为更多的锁通常意味着更多的死锁可能性。避免死锁的需求通常是内核实现中的一个主要因素。</p>
<h2 id="锁和中断处理函数">锁和中断处理函数
</h2><p>一些xv6自旋锁保护线程和中断处理程序共用的数据。</p>
<p>例如，<code>clockintr</code>定时器中断处理程序在增加<code>ticks</code>(<em><strong>kernel/trap.c</strong></em>:163)的同时内核线程可能在<code>sys_sleep</code>(<em><strong>kernel/sysproc.c</strong></em>:64)中读取<code>ticks</code>。锁<code>tickslock</code>串行化这两个访问。</p>
<p>自旋锁和中断的交互引发了潜在的危险。</p>
<p>假设<code>sys_sleep</code>持有<code>tickslock</code>，并且它的CPU被计时器中断中断。<code>clockintr</code>会尝试获取<code>tickslock</code>，意识到它被持有后等待释放。在这种情况下，<code>tickslock</code>永远不会被释放：只有<code>sys_sleep</code>可以释放它，但是<code>sys_sleep</code>直到<code>clockintr</code>返回前不能继续运行。所以CPU会死锁，任何需要锁的代码也会冻结。</p>
<p>为了避免这种情况，如果一个自旋锁被中断处理程序所使用，那么CPU必须保证在启用中断的情况下永远不能持有该锁。</p>
<p>Xv6更保守：当CPU获取任何锁时，xv6总是禁用该CPU上的中断。中断仍然可能发生在其他CPU上，此时中断的<code>acquire</code>可以等待线程释放自旋锁；由于不在同一CPU上，不会造成死锁。</p>
<p>当CPU未持有自旋锁时，xv6重新启用中断；它必须做一些记录来处理嵌套的临界区域。</p>
<p><code>acquire</code>调用<code>push_off</code> (<em><strong>kernel/spinlock.c</strong></em>:89) 并且<code>release</code>调用<code>pop_off</code> (<em><strong>kernel/spinlock.c</strong></em>:100)来跟踪当前CPU上锁的嵌套级别。当计数达到零时，<code>pop_off</code>恢复最外层临界区域开始时存在的中断使能状态。<code>intr_off</code>和<code>intr_on</code>函数执行RISC-V指令分别用来禁用和启用中断。</p>
<p>严格的在设置<code>lk-&gt;locked</code> (<em><strong>kernel/spinlock.c</strong></em>:28)之前让<code>acquire</code>调用<code>push_off</code>是很重要的。</p>
<p>如果两者颠倒，会存在一个既持有锁又启用了中断的短暂窗口期，不幸的话定时器中断会使系统死锁。同样，只有在释放锁之后，<code>release</code>才调用<code>pop_off</code>也是很重要的(<em><strong>kernel/spinlock.c</strong></em>:66)。</p>
<h2 id="指令和内存访问排序">指令和内存访问排序
</h2><p>人们很自然地会想到程序是按照源代码语句出现的顺序执行的。</p>
<p>然而，许多编译器和中央处理器为了获得更高的性能而不按顺序执行代码。</p>
<p>如果一条指令需要许多周期才能完成，中央处理器可能会提前发出指令，这样它就可以与其他指令重叠，避免中央处理器停顿。</p>
<p>例如，中央处理器可能会注意到在顺序指令序列A和B中彼此不存在依赖。CPU也许首先启动指令B，或者是因为它的输入先于A的输入准备就绪，或者是为了重叠执行A和B。编译器可以执行类似的重新排序，方法是在源代码中一条语句的指令发出之前，先发出另一条语句的指令。</p>
<p>编译器和CPU在重新排序时需要遵循一定规则，以确保它们不会改变正确编写的串行代码的结果。</p>
<p>然而，规则确实允许重新排序后改变并发代码的结果，并且很容易导致多处理器上的不正确行为。</p>
<p>CPU的排序规则称为内存模型（memory model）。</p>
<p>例如，在<code>push</code>的代码中，如果编译器或CPU将对应于第4行的存储指令移动到第6行<code>release</code>后的某个地方，那将是一场灾难：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">l</span> <span class="o">=</span> <span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">l</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">l</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listlock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">l</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">list</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listlock</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果发生这样的重新排序，将会有一个窗口期，另一个CPU可以获取锁并查看更新后的<code>list</code>，但却看到一个未初始化的<code>list-&gt;next</code>。</p>
<p>为了告诉硬件和编译器不要执行这样的重新排序，xv6在<code>acquire</code>(<em><strong>kernel/spinlock.c、</strong></em>:22) 和<code>release</code>(<em><strong>kernel/spinlock.c</strong></em>:47)中都使用了<code>__sync_synchronize()</code>。</p>
<p><code>__sync_synchronize()</code>是一个内存障碍：它告诉编译器和CPU不要跨障碍重新排序<code>load</code>或<code>store</code>指令。</p>
<p>因为xv6在访问共享数据时使用了锁，xv6的<code>acquire</code>和<code>release</code>中的障碍在几乎所有重要的情况下都会强制顺序执行。</p>
<h2 id="睡眠锁">睡眠锁
</h2><p>有时xv6需要长时间保持锁。</p>
<p>例如，文件系统（第8章）在磁盘上读写文件内容时保持文件锁定，这些磁盘操作可能需要几十毫秒。如果另一个进程想要获取自旋锁，那么长时间保持自旋锁会导致获取进程在自旋时浪费很长时间的CPU。</p>
<p>自旋锁的另一个缺点是，一个进程在持有自旋锁的同时不能让出（yield）CPU，然而我们希望持有锁的进程等待磁盘I/O的时候其他进程可以使用CPU。</p>
<p>持有自旋锁时让步是非法的，因为如果第二个线程试图获取自旋锁，就可能导致死锁：因为<code>acquire</code>不会让出CPU，第二个线程的自旋可能会阻止第一个线程运行并释放锁。在持有锁时让步也违反了在持有自旋锁时中断必须关闭的要求。</p>
<p>因此，我们想要一种锁，它在等待获取锁时让出CPU，并允许在持有锁时让步（以及中断）。</p>
<p>Xv6以睡眠锁（sleep-locks）的形式提供了这种锁。<code>acquiresleep</code> (<em><strong>kernel/sleeplock.c</strong></em>:22) 在等待时让步CPU。</p>
<p>在更高层次上，睡眠锁有一个被自旋锁保护的锁定字段，<code>acquiresleep</code>对<code>sleep</code>的调用原子地让出CPU并释放自旋锁。结果是其他线程可以在<code>acquiresleep</code>等待时执行。</p>
<p>因为睡眠锁保持中断使能，所以它们不能用在中断处理程序中。</p>
<p>因为<code>acquiresleep</code>可能会让出CPU，所以睡眠锁不能在自旋锁临界区域中使用（尽管自旋锁可以在睡眠锁临界区域中使用）。</p>
<p>因为等待会浪费CPU时间，所以自旋锁最适合短的临界区域；睡眠锁对于冗长的操作效果很好。</p>
<ul>
<li><strong>自旋锁</strong>：当进程想要获取自旋锁时，如果锁被占用，进程不会暂停或让出CPU，而是<strong>不断地尝试（自旋）</strong>，直到获取锁。这意味着自旋锁要求进程<strong>始终保持运行</strong>，不让出CPU，且在锁释放之前，系统无法调度其他进程来运行。</li>
<li><strong>睡眠锁</strong>：当进程想要获取睡眠锁时，如果锁被占用，进程会<strong>暂停（睡眠）</strong>，并<strong>让出CPU</strong>，使得其他进程可以被调度来运行。等到锁可用时，系统会重新唤醒这个进程。</li>
</ul>
<p>当一个进程持有自旋锁时，中断是关闭的，这是为了确保在自旋锁保护的临界区内，系统不会发生上下文切换（即不会暂停这个进程去调度其他进程）。</p>
<h2 id="真实世界">真实世界
</h2><p>尽管对并发原语和并行性进行了多年的研究，但使用锁进行编程仍然具有挑战性。</p>
<p>通常最好将锁隐藏在更高级别的结构中，如同步队列，尽管xv6没有这样做。</p>
<p>如果您使用锁进行编程，明智的做法是使用试图识别竞争条件（race conditions）的工具，因为很容易错过需要锁的不变量。</p>
<p>大多数操作系统都支持POSIX线程（Pthread），它允许一个用户进程在不同的CPU上同时运行几个线程。</p>
<p>Pthread支持用户级锁（user-level locks）、障碍（barriers）等。</p>
<p>支持Pthread需要操作系统的支持。</p>
<p>例如，应该是这样的情况，如果一个Pthread在系统调用中阻塞，同一进程的另一个Pthread应当能够在该CPU上运行。</p>
<p>另一个例子是，如果一个线程改变了其进程的地址空间（例如，映射或取消映射内存），内核必须安排运行同一进程下的线程的其他CPU更新其硬件页表，以反映地址空间的变化。</p>
<p>没有原子指令实现锁是可能的，但是代价昂贵，并且大多数操作系统使用原子指令。</p>
<p>如果许多CPU试图同时获取相同的锁，可能会付出昂贵的开销。</p>
<p>如果一个CPU在其本地cache中缓存了一个锁，而另一个CPU必须获取该锁，那么更新保存该锁的cache行的原子指令必须将该行从一个CPU的cache移动到另一个CPU的cache中，并且可能会使cache行的任何其他副本无效。从另一个CPU的cache中获取cache行可能比从本地cache中获取一行的代价要高几个数量级。</p>
<p>为了避免与锁相关的开销，许多操作系统使用无锁的数据结构和算法。</p>
<p>例如，可以实现一个像本章开头那样的链表，在列表搜索期间不需要锁，并且使用一个原子指令在一个列表中插入一个条目。</p>
<p>然而，无锁编程比有锁编程更复杂；例如，人们必须担心指令和内存重新排序。</p>
<p>有锁编程已经很难了，所以xv6避免了无锁编程的额外复杂性。</p>
<h2 id="关于posix与pthread">关于POSIX与Pthread
</h2><p>操作系统支持**POSIX线程（Pthread）**时的一些关键机制，尤其是在多核处理器环境下，如何管理多个线程和进程之间的资源共享和同步。</p>
<p><strong>Pthread</strong> 是一种标准化的多线程编程接口，支持在同一个用户进程中同时运行多个线程。</p>
<p>线程是<strong>轻量级进程</strong>，它们共享同一个进程的地址空间、文件描述符和其他资源，但可以并行执行。在多核处理器上，不同的线程可以分布在不同的CPU上并行执行。</p>
<p>用户级锁，这些锁是专门用来控制并发的机制，用于防止多个线程同时修改共享数据，导致数据不一致。</p>
<p>用户级锁的操作由应用程序控制，不涉及内核。</p>
<p>例如，多个线程共享一个变量时，通过锁来确保一次只有一个线程能够访问或修改这个变量。</p>
<p>在操作系统支持Pthread的情况下，用户进程可以同时运行多个线程。每个线程可以分布在不同的CPU上并行执行。</p>
<p>因此，即使一个线程在执行系统调用时<strong>阻塞</strong>了（无法继续执行），<strong>同一个进程中的另一个线程仍然可以继续在该CPU上运行</strong>。</p>
<p>这确保了即使有线程在系统调用中被阻塞，也不会影响同一进程中其他线程的运行。</p>
<p>所有线程共享同一个进程的<strong>地址空间</strong>。</p>
<p>如果一个线程改变了该进程的地址空间，比如映射（增加内存）或取消映射（释放内存），那么操作系统需要确保在其他CPU上运行的该进程的其他线程的<strong>硬件页表</strong>（CPU用于管理内存映射的机制）也要更新。</p>
<p>否则，不同CPU上运行的线程可能会看到不一致的内存视图。</p>
<h2 id="正课">正课
</h2><h2 id="为什么要用锁-1">为什么要用锁
</h2><p>这节课更关注在内核和操作系统中使用的锁。</p>
<p>为什么我们需要锁？</p>
<p>故事要从应用程序想要使用多个CPU核开始。使用多个CPU核可以带来性能的提升，如果一个应用程序运行在多个CPU核上，并且执行了系统调用，那么内核需要能够处理并行的系统调用。</p>
<p>如果系统调用并行的运行在多个CPU核上，那么它们可能会并行的访问内核中共享的数据结构。</p>
<p>XV6有很多共享的数据结构，例如proc、ticks和我们之后会看到的buffer cache等等。</p>
<p>当并行的访问数据结构时，例如一个核在读取数据，另一个核在写入数据，我们需要使用锁来协调对于共享数据的更新，以确保数据的一致性。</p>
<p>但是实际的情况有些令人失望，因为我们想要通过并行来获得高性能，我们想要并行的在不同的CPU核上执行系统调用，但是如果这些系统调用使用了共享的数据，我们又需要使用锁，而锁又会使得这些系统调用串行执行，所以最后锁反过来又限制了性能。</p>
<p>我们处于一个矛盾的处境，出于正确性，我们需要使用锁，但是考虑到性能，锁又是极不好的。</p>
<p>这就是现实，我们接下来会看看如何改善这个处境。</p>
<p>但是回到最开始，为什么应用程序一定要使用多个CPU核来提升性能呢？</p>
<p>这个实际上与过去几十年技术的发展有关。</p>
<p>大概从2000年开始：</p>
<ul>
<li>CPU的时钟频率就没有再增加过了（绿线）。</li>
<li>这样的结果是，CPU的单线程性能达到了一个极限并且也没有再增加过（蓝线）。</li>
<li>但是另一方面，CPU中的晶体管数量在持续的增加 （深红色线）。</li>
<li>所以现在不能通过使用单核来让代码运行的更快，要想运行的更快，唯一的选择就是使用多个CPU核。所以从2000年开始，处理器上核的数量开始在增加（黑线）。</li>
</ul>
<p>所以现在如果一个应用程序想要提升性能，它不能只依赖单核，必须要依赖于多核。</p>
<p>这也意味着，如果应用程序与内核交互的较为紧密，那么操作系统也需要高效的在多个CPU核上运行。</p>
<p>这就是我们对内核并行的运行在多个CPU核上感兴趣的直接原因。</p>
<p>那为什么要使用锁呢？前面我们已经提到了，是为了确保正确性。</p>
<p>当一份共享数据同时被读写时，如果没有锁的话，可能会出现race condition，进而导致程序出错。</p>
<p>race condition可以有不同的表现形式，并且它可能发生，也可能不发生。</p>
<h2 id="锁如何避免竞争条件race-condition">锁如何避免竞争条件（race condition）
</h2><p>首先你们在脑海里应该有多个CPU核在运行，比如说CPU0在运行指令，CPU1也在运行指令，这两个CPU核都连接到同一个内存上。</p>
<p>在前面的代码中，数据freelist位于内存中，它里面记录了2个内存page。</p>
<p>假设两个CPU核在相同的时间调用kfree。</p>
<p>kfree函数接收一个物理地址pa作为参数，freelist是个单链表，kfree中将pa作为单链表的新的head节点，并更新freelist指向pa（注，也就是将空闲的内存page加在单链表的头部）。</p>
<p>当两个CPU都调用kfree时，CPU0想要释放一个page，CPU1也想要释放一个page，现在这两个page都需要加到freelist中。</p>
<p>kfree中首先将对应内存page的变量r指向了当前的freelist（也就是单链表当前的head节点）。</p>
<p>我们假设CPU0先运行，那么CPU0会将它的变量r的next指向当前的freelist。如果CPU1在同一时间运行，它可能在CPU0运行第二条指令（kmem.freelist = r）之前运行代码。</p>
<p>所以它也会完成相同的事情，它会将自己的变量r的next指向当前的freelist。现在两个物理page对应的变量r都指向了同一个freelist（注，也就是原来单链表的head节点）。</p>
<p>剩下的代码也会并行的执行（kmem.freelist = r），这行代码会更新freelist为r。因为我们这里只有一个内存，所以总是有一个CPU会先执行，另一个后执行。我们假设CPU0先执行，那么freelist会等于CPU0的变量r。之后CPU1再执行，它又会将freelist更新为CPU1的变量r。</p>
<p>这样的结果是，我们丢失了CPU0对应的page。CPU0想要释放的内存page最终没有出现在freelist数据中。</p>
<p>在代码中，用来解决这里的问题的最常见方法就是使用锁。</p>
<p>锁就是一个对象，就像其他在内核中的对象一样。有一个结构体叫做lock，它包含了一些字段，这些字段中维护了锁的状态。</p>
<p>锁有非常直观的API：</p>
<ul>
<li>acquire，接收指向lock的指针作为参数。acquire确保了在任何时间，只会有一个进程能够成功的获取锁。</li>
<li>release，也接收指向lock的指针作为参数。在同一时间尝试获取锁的其他进程需要等待，直到持有锁的进程对锁调用release。</li>
</ul>
<p>锁的acquire和release之间的代码，通常被称为critical section。</p>
<p>之所以被称为critical section，是因为通常会在这里以原子的方式执行共享数据的更新。</p>
<p>所以基本上来说，如果在acquire和release之间有多条指令，它们要么会一起执行，要么一条也不会执行。</p>
<p>现在的程序通常会有许多锁。实际上，XV6中就有很多的锁。</p>
<p>因为锁序列化了代码的执行。</p>
<p>如果两个处理器想要进入到同一个critical section中，只会有一个能成功进入，另一个处理器会在第一个处理器从critical section中退出之后再进入。所以这里完全没有并行执行。</p>
<p>如果内核中只有一把大锁，我们暂时将之称为big kernel lock。</p>
<p>基本上所有的系统调用都会被这把大锁保护而被序列化。</p>
<p>系统调用会按照这样的流程处理：一个系统调用获取到了big kernel lock，完成自己的操作，之后释放这个big kernel lock，再返回到用户空间，之后下一个系统调用才能执行。</p>
<p>这样的话，如果我们有一个应用程序并行的调用多个系统调用，这些系统调用会串行的执行，因为我们只有一把锁。</p>
<p>所以通常来说，例如XV6的操作系统会有多把锁，这样就能获得某种程度的并发执行。如果两个系统调用使用了两把不同的锁，那么它们就能完全的并行运行。</p>
<p>首先，并没有强制说一定要使用锁，锁的使用完全是由程序员决定的。如果你想要一段代码具备原子性，那么其实是由程序员决定是否增加锁的acquire和release。</p>
<p>其次，代码不会自动加锁，程序员自己要确定好是否将锁与数据结构关联，并在适当的位置增加锁的acquire和release。</p>
<h2 id="什么时候使用锁">什么时候使用锁
</h2><p>锁限制了并发性，也限制了性能。那这带来了一个问题，什么时候才必须要加锁呢？</p>
<p>一个非常保守同时也是非常简单的规则：如果两个进程访问了一个共享的数据结构，并且其中一个进程会更新共享的数据结构，那么就需要对于这个共享的数据结构加锁。</p>
<p>这是个保守的规则，如果一个数据结构可以被多个进程访问，其中一个进程会更新这个数据，那么可能会产生race condition，应该使用锁来确保race condition不会发生。</p>
<p>但是同时，这条规则某种程度上来说又太过严格了。</p>
<p>如果有两个进程共享一个数据结构，并且其中一个进程会更新这个数据结构，在某些场合不加锁也可以正常工作。</p>
<p>不加锁的程序通常称为lock-free program，不加锁的目的是为了获得更好的性能和并发度，不过lock-free program比带锁的程序更加复杂一些。</p>
<p>矛盾的是，有时候这个规则太过严格，而有时候这个规则又太过宽松了。</p>
<p>除了共享的数据，在一些其他场合也需要锁，例如对于printf，如果我们将一个字符串传递给它，XV6会尝试原子性的将整个字符串输出，而不是与其他进程的printf交织输出。</p>
<p>尽管这里没有共享的数据结构，但在这里锁仍然很有用处，因为我们想要printf的输出也是序列化的。</p>
<p>这条规则并不完美，但是它已经是一个足够好的指导准则。</p>
<p>因为有了race condition，所以需要锁。</p>
<p>我们之前在kfree函数中构造的race condition是很容易被识别到的，实际上如果你使用race detection工具，就可以立即找到它。但是对于一些更复杂的场景，就不是那么容易探测到race condition。</p>
<p>那么我们能通过自动的创建锁来自动避免race condition吗？</p>
<p>如果按照刚刚的简单规则，一旦我们有了一个共享的数据结构，任何操作这个共享数据结构都需要获取锁，那么对于XV6来说，每个结构体都需要自带一个锁，当我们对于结构体做任何操作的时候，会自动获取锁。</p>
<p>可是如果我们这样做的话，结果就太过严格了，所以不能自动加锁。</p>
<p>假设我们有一个对于rename的调用，这个调用会将文件从一个目录移到另一个目录，我们现在将文件d1/x移到文件d2/y。</p>
<p>如果我们按照前面说的，对数据结构自动加锁。</p>
<p>现在我们有两个目录对象，一个是d1，另一个是d2，那么我们会先对d1加锁，删除x，之后再释放对于d1的锁；之后我们会对d2加锁，增加y，之后再释放d2的锁。这是我们在使用自动加锁之后的一个假设的场景。</p>
<p>在我们完成了第一步，也就是删除了d1下的x文件，但是还没有执行第二步，也就是创建d2下的y文件时，其他的进程会看到文件完全不存在。</p>
<p>这明显是个错误的结果，因为文件还存在只是被重命名了，文件在任何一个时间点都是应该存在的。</p>
<p>所以这里正确的解决方法是，我们在重命名的一开始就对d1和d2加锁，之后删除x再添加y，最后再释放对于d1和d2的锁。</p>
<p>在这个例子中，我们的操作需要涉及到多个锁，但是直接为每个对象自动分配一个锁会带来错误的结果。</p>
<p>在这个例子中，锁应该与操作而不是数据关联，所以自动加锁在某些场景下会出问题。</p>
<p>学生提问：可不可以在访问某个数据结构的时候，就获取所有相关联的数据结构的锁？</p>
<p>Frans教授：这是一种实现方式。但是这种方式最后会很快演进成big kernel lock，这样你就失去了并发执行的能力，但是你肯定想做得更好。这里就是使用锁的矛盾点了，如果你想要程序简单点，可以通过coarse-grain locking（注，也就是大锁），但是这时你就失去了性能。</p>
<h2 id="锁的特性和死锁">锁的特性和死锁
</h2><p>通常锁有三种作用。</p>
<ul>
<li>
<p>锁可以避免丢失更新。</p>
<p>如果你回想我们之前在kalloc.c中的例子，丢失更新是指我们丢失了对于某个内存page在kfree函数中的更新。如果没有锁，在出现race condition的时候，内存page不会被加到freelist中。但是加上锁之后，我们就不会丢失这里的更新。</p>
</li>
<li>
<p>锁可以打包多个操作，使它们具有原子性。</p>
<p>我们之前介绍了加锁解锁之间的区域是critical section，在critical section的所有操作会都会作为一个原子操作执行。</p>
</li>
<li>
<p>锁可以维护共享数据结构的不变性。</p>
<p>共享数据结构如果不被任何进程修改的话是会保持不变的。如果某个进程acquire了锁并且做了一些更新操作，共享数据的不变性暂时会被破坏，但是在release锁之后，数据的不变性又恢复了。你们可以回想一下之前在kfree函数中的freelist数据，所有的free page都在一个单链表上。但是在kfree函数中，这个单链表的head节点会更新。freelist并不太复杂，对于一些更复杂的数据结构可能会更好的帮助你理解锁的作用。</p>
</li>
</ul>
<p>接下来再来看一下锁可能带来的一些缺点。不恰当的使用锁，可能会带来一些锁特有的问题。最明显的一个例子就是死锁（Deadlock）。</p>
<p>一个死锁的最简单的场景就是：首先acquire一个锁，然后进入到critical section；在critical section中，再acquire同一个锁；第二个acquire必须要等到第一个acquire状态被release了才能继续执行，但是不继续执行的话又走不到第一个release，所以程序就一直卡在这了。这就是一个死锁。</p>
<p>这是死锁的一个最简单的例子，XV6会探测这样的死锁，如果XV6看到了同一个进程多次acquire同一个锁，就会触发一个panic。</p>
<p>当有多个锁的时候，场景会更加有趣。</p>
<p>假设现在我们有两个CPU，一个是CPU1，另一个是CPU2。CPU1执行rename将文件d1/x移到d2/y，CPU2执行rename将文件d2/a移到d1/b。这里CPU1将文件从d1移到d2，CPU2正好相反将文件从d2移到d1。</p>
<p>我们假设我们按照参数的顺序来acquire锁，那么CPU1会先获取d1的锁，如果程序是真正的并行运行，CPU2同时也会获取d2的锁。之后CPU1需要获取d2的锁，这里不能成功，因为CPU2现在持有锁，所以CPU1会停在这个位置等待d2的锁释放。而另一个CPU2，接下来会获取d1的锁，它也不能成功，因为CPU1现在持有锁。</p>
<p>这也是死锁的一个例子，有时候这种场景也被称为deadly embrace。这里的死锁就没那么容易探测了。</p>
<p>这里的解决方案是，如果你有多个锁，你需要对锁进行排序，所有的操作都必须以相同的顺序获取锁。</p>
<p>所以对于一个系统设计者，你需要确定对于所有的锁对象的全局的顺序。</p>
<p>如在这里的例子中我们让d1一直在d2之前，这样我们在rename的时候，总是先获取排序靠前的目录的锁，再获取排序靠后的目录的锁。如果对于所有的锁有了一个全局的排序，这里的死锁就不会出现了。</p>
<p>不过在设计一个操作系统的时候，定义一个全局的锁的顺序会有些问题。</p>
<p>如果一个模块m1中方法g调用了另一个模块m2中的方法f，那么m1中的方法g需要知道m2的方法f使用了哪些锁。</p>
<p>因为如果m2使用了一些锁，那么m1的方法g必须集合f和g中的锁，并形成一个全局的锁的排序，意味着在m2中的锁必须对m1可见，这样m1才能以恰当的方法调用m2。</p>
<p>但是这样又违背了代码抽象的原则。在完美的情况下，代码抽象要求m1完全不知道m2是如何实现的。</p>
<p>但是不幸的是，具体实现中，m2内部的锁需要泄露给m1，这样m1才能完成全局锁排序。所以当你设计一些更大的系统时，锁使得代码的模块化更加的复杂了。</p>
<p>学生提问：有必要对所有的锁进行排序吗？</p>
<p>Frans教授：在上面的例子中，这取决于f和g是否共用了一些锁。如果你看XV6的代码，你可以看到会有多种锁的排序，因为一些锁与其他的锁没有任何关系，它们永远也不会在同一个操作中被acquire。如果两组锁不可能在同一个操作中被acquire，那么这两组锁的排序是完全独立的。所以没有必要对所有的锁进行一个全局的排序，但是所有的函数需要对共同使用的一些锁进行一个排序。</p>
<h2 id="锁与性能">锁与性能
</h2><p>我们前面已经看过了两类锁带来的挑战，一个是死锁，另一个是破坏了程序的模块化。</p>
<p>这一部分来看看第三个挑战，也就是锁与性能之间的权衡。</p>
<p>基本上来说，如果你想获得更高的性能，你需要拆分数据结构和锁。</p>
<p>如果你只有一个big kernel lock，那么操作系统只能被一个CPU运行。</p>
<p>如果你想要性能随着CPU的数量增加而增加，你需要将数据结构和锁进行拆分。</p>
<p>那怎么拆分呢？通常不会很简单，有的时候还有些困难。比如说，你是否应该为每个目录关联不同的锁？你是否应该为每个inode关联不同的锁？你是否应该为每个进程关联不同的锁？或者是否有更好的方式来拆分数据结构呢？</p>
<p>如果你重新设计了加锁的规则，你需要确保不破坏内核一直尝试维护的数据不变性。</p>
<p>如果你拆分了锁，你可能需要重写代码。如果你为了获得更好的性能，重构了部分内核或者程序，将数据结构进行拆分并引入了更多的锁，这涉及到很多工作，你需要确保你能够继续维持数据的不变性，你需要重写代码。</p>
<p>所以这里就有矛盾点了。我们想要获得更好的性能，那么我们需要有更多的锁，但是这又引入了大量的工作。</p>
<p>通常来说，开发的流程是：</p>
<ul>
<li>先以coarse-grained lock（注，也就是大锁）开始。</li>
<li>再对程序进行测试，来看一下程序是否能使用多核。</li>
<li>如果可以的话，那么工作就结束了，你对于锁的设计足够好了；如果不可以的话，那意味着锁存在竞争，多个进程会尝试获取同一个锁，因此它们将会序列化的执行，性能也上不去，之后你就需要重构程序。</li>
</ul>
<p>在这个流程中，测试的过程比较重要。有可能模块使用了coarse-grained  lock，但是它并没有经常被并行的调用，那么其实就没有必要重构程序，因为重构程序设计到大量的工作，并且也会使得代码变得复杂。</p>
<p>所以如果不是必要的话，还是不要进行重构。</p>
<h2 id="xv6中uart模块对于锁的使用">XV6中UART模块对于锁的使用
</h2><p>接下来我们看一下XV6的代码，通过代码来理解锁是如何在XV6中工作的。首先查看一下uart.c。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">//the transmit output buffer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="n">spinlock</span> <span class="n">uart_tx_lock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define UART_TX_BUF_SIZE 32
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">char</span> <span class="n">uart_tx_buf</span> <span class="p">[</span><span class="n">UART_TX_BUF_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">uart_tx_w</span><span class="p">;</span><span class="c1">//write next to uart_tx_buf[uart_tx_w++]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">uart_tx_r</span><span class="p">;</span><span class="c1">//read next from uart_tx_buf[uar_tx_r++]
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>所以你可以认为对于UART模块来说，现在是一个coarse-grained lock的设计。</p>
<p>这个锁保护了UART的的传输缓存；写指针；读指针。当我们传输数据时，写指针会指向传输缓存的下一个空闲槽位，而读指针指向的是下一个需要被传输的槽位。</p>
<p>这是我们对于并行运算的一个标准设计，它叫做消费者-生产者模式。</p>
<p>所以现在有了一个缓存，一个写指针和一个读指针。</p>
<p>读指针的内容需要被显示，写指针接收来自例如printf的数据。</p>
<p>我们前面已经了解到了锁有多个角色。</p>
<p>第一个是保护数据结构的特性不变，数据结构有一些不变的特性，例如读指针需要追赶写指针；从读指针到写指针之间的数据是需要被发送到显示端；从写指针到读指针之间的是空闲槽位，锁帮助我们维护了这些特性不变。</p>
<p>接下来看一下uart.c中的uartputc函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// add a character to the output buffer and tell the
</span></span></span><span class="line"><span class="cl"><span class="c1">// UART to start sending if it isn&#39;t already.
</span></span></span><span class="line"><span class="cl"><span class="c1">// blocks if the output buffer is full.
</span></span></span><span class="line"><span class="cl"><span class="c1">// because it may block, it can&#39;t be called
</span></span></span><span class="line"><span class="cl"><span class="c1">// from interrupts; it&#39;s only suitable for use
</span></span></span><span class="line"><span class="cl"><span class="c1">// by write().
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">uartputc</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart_tx_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">panicked</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(;;)</span>
</span></span><span class="line"><span class="cl">      <span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(((</span><span class="n">uart_tx_w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">UART_TX_BUF_SIZE</span><span class="p">)</span> <span class="o">==</span> <span class="n">uart_tx_r</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// buffer is full.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// wait for uartstart() to open up space in the buffer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nf">sleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart_tx_r</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uart_tx_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">uart_tx_buf</span><span class="p">[</span><span class="n">uart_tx_w</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">uart_tx_w</span> <span class="o">=</span> <span class="p">(</span><span class="n">uart_tx_w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">UART_TX_BUF_SIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nf">uartstart</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart_tx_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>函数首先获得了锁，然后查看当前缓存是否还有空槽位，如果有的话将数据放置于空槽位中；写指针加1；调用uartstart；最后释放锁。</p>
<p>如果两个进程在同一个时间调用uartputc，那么这里的锁会确保来自于第一个进程的一个字符进入到缓存的第一个槽位，接下来第二个进程的一个字符进入到缓存的第二个槽位。</p>
<p>这就是锁帮助我们避免race condition的一个简单例子。如果没有锁的话，第二个进程可能会覆盖第一个进程的字符。</p>
<p>接下来我们看一下uartstart函数，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// if the UART is idle, and a character is waiting
</span></span></span><span class="line"><span class="cl"><span class="c1">// in the transmit buffer, send it.
</span></span></span><span class="line"><span class="cl"><span class="c1">// caller must hold uart_tx_lock.
</span></span></span><span class="line"><span class="cl"><span class="c1">// called from both the top- and bottom-half.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">uartstart</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">uart_tx_w</span> <span class="o">==</span> <span class="n">uart_tx_r</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// transmit buffer is empty.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">((</span><span class="nf">ReadReg</span><span class="p">(</span><span class="n">LSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">LSR_TX_IDLE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// the UART transmit holding register is full,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// so we cannot give it another byte.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// it will interrupt when it&#39;s ready for a new byte.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">uart_tx_buf</span><span class="p">[</span><span class="n">uart_tx_r</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">uart_tx_r</span> <span class="o">=</span> <span class="p">(</span><span class="n">uart_tx_r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">UART_TX_BUF_SIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// maybe uartputc() is waiting for space in the buffer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart_tx_r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nf">WriteReg</span><span class="p">(</span><span class="n">THR</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果uart_tx_w不等于uart_tx_r，那么缓存不为空，说明需要处理缓存中的一些字符。</p>
<p>锁确保了我们可以在下一个字符写入到缓存之前，处理完缓存中的字符，这样缓存中的数据就不会被覆盖。</p>
<p>最后，锁确保了一个时间只有一个CPU上的进程可以写入UART的寄存器，THR。</p>
<p>所以这里锁确保了硬件寄存器只有一个写入者。</p>
<p>当UART硬件完成传输，会产生一个中断。在前面的代码中我们知道了uartstart的调用者会获得锁以确保不会有多个进程同时向THR寄存器写数据。</p>
<p>但是UART中断本身也可能与调用printf的进程并行执行。</p>
<p>如果一个进程调用了printf，它运行在CPU0上；CPU1处理了UART中断，那么CPU1也会调用uartstart。</p>
<p>因为我们想要确保对于THR寄存器只有一个写入者，同时也确保传输缓存的特性不变（注，这里指的是在uartstart中对于uart_tx_r指针的更新），我们需要在中断处理函数中也获取锁。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// handle a uart interrupt, raised because input has
</span></span></span><span class="line"><span class="cl"><span class="c1">// arrived, or the uart is ready for more output, or
</span></span></span><span class="line"><span class="cl"><span class="c1">// both. called from trap.c.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">uartintr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// read and process incoming characters.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="nf">uartgetc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">consoleintr</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// send buffered characters.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart_tx_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">uartstart</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart_tx_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>所以，在XV6中，驱动的bottom部分（注，也就是中断处理程序）和驱动的up部分（注，uartputc函数）可以完全的并行运行，所以中断处理程序也需要获取锁。</p>
<p>学生提问：UART的缓存中，读指针是不是总是会落后于写指针？</p>
<p>Frans教授：从读指针到写指针之间的字符是要显示的字符，UART会逐次的将读指针指向的字符在显示器上显示，同时printf可能又会将新的字符写入到缓存。读指针总是会落后于写指针直到读指针追上了写指针，这时两个指针相同，并且此时缓存中没有字符需要显示。</p>
<h2 id="自旋锁的实现一">自旋锁的实现（一）
</h2><p>接下来我们看一下如何实现自旋锁。</p>
<p>锁的特性就是只有一个进程可以获取锁，在任何时间点都不能有超过一个锁的持有者。</p>
<p>实现锁的主要难点在于锁的acquire接口，在acquire里面有一个死循环，循环中判断锁对象的locked字段是否为0，如果为0那表明当前锁没有持有者，当前对于acquire的调用可以获取锁。</p>
<p>之后我们通过设置锁对象的locked字段为1来获取锁。最后返回。</p>
<p>如果锁的locked字段不为0，那么当前对于acquire的调用就不能获取锁，程序会一直spin。</p>
<p>也就是说，程序在循环中不停的重复执行，直到锁的持有者调用了release并将锁对象的locked设置为0。</p>
<p>两个进程可能同时读到锁的locked字段为0。</p>
<p>如果CPU0和CPU1同时到达A语句，它们会同时看到锁的locked字段为0，之后它们会同时走到B语句，这样它们都acquire了锁。这样我们就违背了锁的特性。</p>
<p>为了解决这里的问题并得到一个正确的锁的实现方式，其实有多种方法，但是最常见的方法是依赖于一个特殊的硬件指令。</p>
<p>这个特殊的硬件指令会保证一次test-and-set操作的原子性。</p>
<p>在RISC-V上，这个特殊的指令就是amoswap（atomic memory swap）。</p>
<p>这个指令接收3个参数，分别是address，寄存器r1，寄存器r2。</p>
<p>这条指令会先锁定住address，将address中的数据保存在一个临时变量中（tmp），之后将r1中的数据写入到地址中，之后再将保存在临时变量中的数据写入到r2中，最后再对于地址解锁。</p>
<p>通过这里的加锁，可以确保address中的数据存放于r2，而r1中的数据存放于address中，并且这一系列的指令打包具备原子性。</p>
<p>大多数的处理器都有这样的硬件指令，因为这是一个实现锁的方便的方式。</p>
<p>这里我们通过将一个软件锁转变为硬件锁最终实现了原子性。</p>
<p>不同处理器的具体实现可能会非常不一样，处理器的指令集通常像是一个说明文档，它不会有具体实现的细节，具体的实现依赖于内存系统是如何工作的，比如说：</p>
<ul>
<li>多个处理器共用一个内存控制器，内存控制器可以支持这里的操作，比如给一个特定的地址加锁，然后让一个处理器执行2-3个指令，然后再解锁。因为所有的处理器都需要通过这里的内存控制器完成读写，所以内存控制器可以对操作进行排序和加锁。</li>
<li>如果内存位于一个共享的总线上，那么需要总线控制器（bus arbiter）来支持。总线控制器需要以原子的方式执行多个内存操作。</li>
<li>如果处理器有缓存，那么缓存一致性协议会确保对于持有了我们想要更新的数据的cache line只有一个写入者，相应的处理器会对cache line加锁，完成两个操作。</li>
</ul>
<p>硬件原子操作的实现可以有很多种方法。</p>
<p>但是基本上都是对于地址加锁，读出数据，写入新数据，然后再返回旧数据（注，也就是实现了atomic swap）。</p>
<p>接下来我们看一下如何使用这条指令来实现自旋锁。让我们来看一下XV6中的acquire和release的实现。首先我们看一下spinlock.h。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// Mutual exclusion lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="n">spinlock</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">uint</span> <span class="n">locked</span><span class="p">;</span>       <span class="c1">// Is the lock held?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// For debugging:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>        <span class="c1">// Name of lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">cpu</span> <span class="o">*</span><span class="n">cpu</span><span class="p">;</span>   <span class="c1">// The cpu holding the lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>里面有spinlock结构体的定义。内容也比较简单，包含了locked字段表明当前是否上锁，其他两个字段主要是用来输出调试信息，一个是锁的名字，另一个是持有锁的CPU。</p>
<p>接下来我们看一下spinlock.c文件，先来看一下acquire函数，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// Acquire the lock.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Loops (spins) until the lock is acquired.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">acquire</span><span class="p">(</span><span class="k">struct</span> <span class="n">spinlock</span> <span class="o">*</span><span class="n">lk</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">push_off</span><span class="p">();</span> <span class="c1">// disable interrupts to avoid deadlock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span><span class="nf">holding</span><span class="p">(</span><span class="n">lk</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="nf">panic</span><span class="p">(</span><span class="s">&#34;acquire&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// On RISC-V, sync_lock_test_and_set turns into an atomic swap:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//   a5 = 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//   s1 = &amp;lk-&gt;locked
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//   amoswap.w.aq a5, a5, (s1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">while</span><span class="p">(</span><span class="nf">__sync_lock_test_and_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">locked</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Tell the C compiler and the processor to not move loads or stores
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// past this point, to ensure that the critical section&#39;s memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// references happen strictly after the lock is acquired.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// On RISC-V, this emits a fence instruction.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">__sync_synchronize</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Record info about lock acquisition for holding() and debugging.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">lk</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="nf">mycpu</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在函数中有一个while循环，这就是我刚刚提到的test-and-set循环。实际上C的标准库已经定义了这些原子操作，所以C标准库中已经有一个函数__sync_lock_test_and_set，它里面的具体行为与我刚刚描述的是一样的。</p>
<p>因为大部分处理器都有的test-and-set硬件指令，所以这个函数的实现比较直观。</p>
<p>我们可以通过查看kernel.asm来了解RISC-V具体是如何实现的。</p>
<p>这里比较复杂，总的来说，一种情况下我们跳出循环，另一种情况我们继续执行循环。C代码就要简单的多。</p>
<p>如果锁没有被持有，那么锁对象的locked字段会是0，如果locked字段等于0，我们调用test-and-set将1写入locked字段，并且返回locked字段之前的数值0。</p>
<p>如果返回0，那么意味着没有人持有锁，循环结束。如果locked字段之前是1，那么这里的流程是，先将之前的1读出，然后写入一个新的1，但是这不会改变任何数据，因为locked之前已经是1了。</p>
<p>之后__sync_lock_test_and_set会返回1，表明锁之前已经被人持有了，这样的话，判断语句不成立，程序会持续循环（spin），直到锁的locked字段被设置回0。</p>
<p>接下来我们看一下release的实现。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// Release the lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">release</span><span class="p">(</span><span class="k">struct</span> <span class="n">spinlock</span> <span class="o">*</span><span class="n">lk</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nf">holding</span><span class="p">(</span><span class="n">lk</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="nf">panic</span><span class="p">(</span><span class="s">&#34;release&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">lk</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Tell the C compiler and the CPU to not move loads or stores
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// past this point, to ensure that all the stores in the critical
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// section are visible to other CPUs before the lock is released,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// and that loads in the critical section occur strictly before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the lock is released.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// On RISC-V, this emits a fence instruction.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">__sync_synchronize</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Release the lock, equivalent to lk-&gt;locked = 0.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// This code doesn&#39;t use a C assignment, since the C standard
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// implies that an assignment might be implemented with
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// multiple store instructions.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// On RISC-V, sync_lock_release turns into an atomic swap:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//   s1 = &amp;lk-&gt;locked
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//   amoswap.w zero, zero, (s1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">__sync_lock_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">locked</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">pop_off</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看出release也使用了atomic swap操作，将0写入到了s1。下面是对应的C代码，它基本确保了将lk-&gt;locked中写入0是一个原子操作。</p>
<h2 id="自旋锁的实现二">自旋锁的实现（二）
</h2><p>有关spin lock的实现，有3个细节我想介绍一下。</p>
<p>首先，为什么release函数中不直接使用一个store指令将锁的locked字段写为0?因为其他的处理器可能会向locked字段写入1，或者写入0。</p>
<p>这里的问题是，对于很多人包括我自己来说，经常会认为一个store指令是一个原子操作，但实际并不总是这样，这取决于具体的实现。</p>
<p>例如，对于CPU内的缓存，每一个cache line的大小可能大于一个整数，那么store指令实际的过程将会是：首先会加载cache line，之后再更新cache line。</p>
<p>所以对于store指令来说，里面包含了两个微指令。</p>
<p>这样的话就有可能得到错误的结果。所以为了避免理解硬件实现的所有细节，例如整数操作不是原子的，或者向一个64bit的内存值写数据是不是原子的，我们直接使用一个RISC-V提供的确保原子性的指令来将locked字段写为0。</p>
<p>amoswap并不是唯一的原子指令，下图是RISC-V的手册，它列出了所有的原子指令。</p>
<p>(略)</p>
<p>第二个细节是，在acquire函数的最开始，会先关闭中断。</p>
<p>为什么会是这样呢？让我们回到uart.c中。我们先来假设acquire在一开始并没有关闭中断。在uartputc函数中，首先会acquire锁，如果不关闭中断会发生什么呢？</p>
<p>uartputc函数会acquire锁，UART本质上就是传输字符，当UART完成了字符传输它会做什么？是的，它会产生一个中断之后会运行uartintr函数，在uartintr函数中，会获取同一把锁，但是这把锁正在被uartputc持有。</p>
<p>如果这里只有一个CPU的话，那这里就是死锁。</p>
<p>中断处理程序uartintr函数会一直等待锁释放，但是CPU不出让给uartputc执行的话锁又不会释放。在XV6中，这样的场景会触发panic，因为同一个CPU会再次尝试acquire同一个锁。</p>
<p>所以spinlock需要处理两类并发，一类是不同CPU之间的并发，一类是相同CPU上中断和普通程序之间的并发。</p>
<p>针对后一种情况，我们需要在acquire中关闭中断。中断会在release的结束位置再次打开，因为在这个位置才能再次安全的接收中断。</p>
<p>第三个细节就是memory ordering。假设我们先通过将locked字段设置为1来获取锁，之后对x加1，最后再将locked字段设置0来释放锁。</p>
<p>但是编译器或者处理器可能会重排指令以获得更好的性能。</p>
<p>对于上面的串行指令流，如果将x&lt;-x+1移到locked&lt;-0之后可以吗？这会改变指令流的正确性吗？</p>
<p>并不会，因为x和锁完全相互独立，它们之间没有任何关联。</p>
<p>如果他们还是按照串行的方式执行，x&lt;-x+1移到锁之外也没有问题。所以在一个串行执行的场景下是没有问题的。</p>
<p>实际中，处理器在执行指令时，实际指令的执行顺序可能会改变。编译器也会做类似的事情，编译器可能会在不改变执行结果的前提下，优化掉一些代码路径并进而改变指令的顺序。</p>
<p>但是对于并发执行，很明显这将会是一个灾难。如果我们将critical section与加锁解锁放在不同的CPU执行，将会得到完全错误的结果。所以指令重新排序在并发场景是错误的。</p>
<p>为了禁止，或者说为了告诉编译器和硬件不要这样做，我们需要使用memory fence或者叫做synchronize指令，来确定指令的移动范围。</p>
<p>对于synchronize指令，任何在它之前的load/store指令，都不能移动到它之后。锁的acquire和release函数都包含了synchronize指令。</p>
<p>这样前面的例子中，x&lt;-x+1就不会被移到特定的memory synchronization点之外。</p>
<p>这就是为什么在acquire和release中都有__sync_synchronize函数的调用。</p>
<blockquote>
<p>学生提问：有没有可能在锁acquire之前的一条指令被移到锁release之后？或者说这里会有一个界限不允许这么做？</p>
<p>Frans教授：在这里的例子中，acquire和release都有自己的界限（注，也就是__sync_synchronize函数的调用点）。所以发生在锁acquire之前的指令不会被移到acquire的__sync_synchronize函数调用之后，这是一个界限。在锁的release函数中有另一个界限。所以在第一个界限之前的指令会一直在这个界限之前，在两个界限之间的指令会保持在两个界限之间，在第二个界限之后的指令会保持在第二个界限之后。</p>
</blockquote>
<h2 id="总结">总结
</h2><p>让我来总结一下这节课的内容。</p>
<p>首先，锁确保了正确性，但是同时又会降低性能，这是个令人失望的现实，我们是因为并发运行代码才需要使用锁，而锁另一方面又限制了代码的并发运行。</p>
<p>其次锁会增加编写程序的复杂性，在我们的一些实验中会看到锁，我们需要思考锁为什么在这，它需要保护什么。如果你在程序中使用了并发，那么一般都需要使用锁。如果你想避免锁带来的复杂性，可以遵循以下原则：不到万不得已不要共享数据。如果你不在多个进程之间共享数据，那么race condition就不可能发生，那么你也就不需要使用锁，程序也不会因此变得复杂。但是通常来说如果你有一些共享的数据结构，那么你就需要锁，你可以从coarse-grained lock开始，然后基于测试结果，向fine-grained lock演进。</p>
<p>最后，使用race detector来找到race condition，如果你将锁的acquire和release放置于错误的位置，那么就算使用了锁还是会有race。</p>
<blockquote>
<p>学生提问：在一个处理器上运行多个线程与在多个处理器上运行多个进程是否一样？</p>
<p>Frans教授：差不多吧，如果你有多个线程，但是只有一个CPU，那么你还是会想要特定内核代码能够原子执行。所以你还是需要有critical section的概念。你或许不需要锁，但是你还是需要能够对特定的代码打开或者关闭中断。如果你查看一些操作系统的内核代码，通常它们都没有锁的acquire，因为它们假定自己都运行在单个处理器上，但是它们都有开关中断的操作。</p>
</blockquote>

</section>


    <footer class="article-footer">
    

    <section class="article-lastmod">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <span>
            最后更新于 Nov 12, 2024 23:05 &#43;0800
        </span>
    </section></footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI&#43;WdtXRGWt2kTvGFasHpSy3SV"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG&#43;vnGctmUb0ZY0l8"crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05"crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.body, {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>
    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="has-image">
    <a href="/p/mit6s08123rcu/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08123rcu/29.44fd9b24e5932cf6ae1346291ec85e1b_hu13173094512423318615.png" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：23RCU"
                        
                        data-hash="md5-RP2bJOWTLPauE0YpHsheGw==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：23RCU</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/mit6s08122meltdown/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08122meltdown/19.8d880549dccba2f0c1613b3e41a721e5_hu3753156070077914420.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：22Meltdown"
                        
                        data-hash="md5-jYgFSdzLovDBYTs&#43;Qach5Q==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：22Meltdown</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/mit6s08121networking/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08121networking/bg.68c4376fd87b0b35da07319dd155c90d_hu10351534106733688476.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：21Networking"
                        
                        data-hash="md5-aMQ3b9h7CzXaBzGd0VXJDQ==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：21Networking</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/mit6s08120kernels-and-hll/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08120kernels-and-hll/bg.4175e6a2793e0fc340e5aced2529e40b_hu6405785273338381617.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：20Kernels and HLL"
                        
                        data-hash="md5-QXXmonk&#43;D8NA5aztJSnkCw==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：20Kernels and HLL</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/mit6s08119virtual-machines/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08119virtual-machines/bg.b02a7ba1d946705c0cf2809bcf960db8_hu14546491865979434532.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：19Virtual Machines  "
                        
                        data-hash="md5-sCp7odlGcFwM8oCbz5YNuA==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：19Virtual Machines  </h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2024 echudet
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.29.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
