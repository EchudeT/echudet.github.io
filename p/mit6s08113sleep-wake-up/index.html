<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="进程的“睡眠”和“唤醒”机制是进程调度和资源管理的重要部分。其原理是通过将不需要立即执行的进程置于睡眠状态，释放CPU资源，从而提高系统效率。当进程进入睡眠状态时，它会主动放弃CPU，进行等待某事件的完成。一旦该事件发生，操作系统会通过中断、信号或条件变量等方式唤醒进程，重新将其调度到可执行状态。睡眠和唤醒机制有助于优化资源分配，减少忙等，提高多任务处理的效率，并确保系统响应性和性能的优化。">
<title>MIT6S081：13Sleep &amp; Wake up</title>

<link rel='canonical' href='https://echudet.github.io/p/mit6s08113sleep-wake-up/'>

<link rel="stylesheet" href="/scss/style.min.86fc5e5efb829fb1bdd7a2d2275017fb3ae01ba7fcf491e347d76495ae5e3ae2.css"><meta property='og:title' content="MIT6S081：13Sleep & Wake up">
<meta property='og:description' content="进程的“睡眠”和“唤醒”机制是进程调度和资源管理的重要部分。其原理是通过将不需要立即执行的进程置于睡眠状态，释放CPU资源，从而提高系统效率。当进程进入睡眠状态时，它会主动放弃CPU，进行等待某事件的完成。一旦该事件发生，操作系统会通过中断、信号或条件变量等方式唤醒进程，重新将其调度到可执行状态。睡眠和唤醒机制有助于优化资源分配，减少忙等，提高多任务处理的效率，并确保系统响应性和性能的优化。">
<meta property='og:url' content='https://echudet.github.io/p/mit6s08113sleep-wake-up/'>
<meta property='og:site_name' content='echudet'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2024-09-22T22:02:50&#43;08:00'/><meta property='article:modified_time' content='2024-11-12T23:44:05&#43;08:00'/><meta property='og:image' content='https://echudet.github.io/p/mit6s08113sleep-wake-up/bg.jpg' />
<meta name="twitter:title" content="MIT6S081：13Sleep & Wake up">
<meta name="twitter:description" content="进程的“睡眠”和“唤醒”机制是进程调度和资源管理的重要部分。其原理是通过将不需要立即执行的进程置于睡眠状态，释放CPU资源，从而提高系统效率。当进程进入睡眠状态时，它会主动放弃CPU，进行等待某事件的完成。一旦该事件发生，操作系统会通过中断、信号或条件变量等方式唤醒进程，重新将其调度到可执行状态。睡眠和唤醒机制有助于优化资源分配，减少忙等，提高多任务处理的效率，并确保系统响应性和性能的优化。"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://echudet.github.io/p/mit6s08113sleep-wake-up/bg.jpg' />
    <link rel="shortcut icon" href="/timer.ico" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu11199958555974308744.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">⌨️</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">echudet</a></h1>
            <h2 class="site-description">探索编程的学生一枚</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/EchudeT'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://twitter.com'
                        target="_blank"
                        title="Twitter"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>档案</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>Links</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#预习">预习</a></li>
    <li><a href="#sleep与wakeup">sleep与wakeup</a></li>
    <li><a href="#代码sleep与wakeup">代码：sleep与wakeup</a></li>
    <li><a href="#代码pipes">代码：Pipes</a></li>
    <li><a href="#代码wait-exit和kill">代码：wait, exit和kill</a></li>
    <li><a href="#真实世界">真实世界</a></li>
    <li><a href="#正课">正课</a></li>
    <li><a href="#线程切换过程中锁的限制">线程切换过程中锁的限制</a></li>
    <li><a href="#sleepwakeup接口">Sleep&amp;Wakeup接口</a></li>
    <li><a href="#lost-wakeup">Lost wakeup</a></li>
    <li><a href="#如何避免lost-wakeup">如何避免Lost wakeup</a></li>
    <li><a href="#pipe中的sleep和wakeup">Pipe中的sleep和wakeup</a></li>
    <li><a href="#exit系统调用">exit系统调用</a></li>
    <li><a href="#wait系统调用">wait系统调用</a></li>
    <li><a href="#kill系统调用">kill系统调用</a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/mit6s08113sleep-wake-up/">
                <img src="/p/mit6s08113sleep-wake-up/bg_hu2695699755507973958.jpg"
                        srcset="/p/mit6s08113sleep-wake-up/bg_hu2695699755507973958.jpg 800w, /p/mit6s08113sleep-wake-up/bg_hu3457364587767499983.jpg 1600w"
                        width="800" 
                        height="450" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：13Sleep &amp; Wake up" />
                
            </a>
        </div>
    

    <div class="article-details">


    
    <header class="article-category">
        
            <a href="/categories/mit6s081/" >
                Mit6s081
            </a>
        
            <a href="/categories/os/" >
                Os
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/mit6s08113sleep-wake-up/">MIT6S081：13Sleep &amp; Wake up</a>
        </h2>
    
        
        <h3 class="article-subtitle">
            进程的“睡眠”和“唤醒”机制是进程调度和资源管理的重要部分。其原理是通过将不需要立即执行的进程置于睡眠状态，释放CPU资源，从而提高系统效率。当进程进入睡眠状态时，它会主动放弃CPU，进行等待某事件的完成。一旦该事件发生，操作系统会通过中断、信号或条件变量等方式唤醒进程，重新将其调度到可执行状态。睡眠和唤醒机制有助于优化资源分配，减少忙等，提高多任务处理的效率，并确保系统响应性和性能的优化。
        </h3>
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2024-09-22</time>
            </div>
        

        
            <div>
                <?xml version="1.0" encoding="iso-8859-1"?>
<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="792px" height="792px" viewBox="0 0 792 792" style="enable-background:new 0 0 792 792;" xml:space="preserve">
<g>
	<g id="_x31_0_19_">
		<g>
			<path d="M643.5,742.5H594V569.25C594,473.566,516.434,396,420.75,396C516.434,396,594,318.434,594,222.75V49.5h49.5
				c13.662,0,24.75-11.088,24.75-24.75S657.162,0,643.5,0h-495c-13.662,0-24.75,11.088-24.75,24.75S134.838,49.5,148.5,49.5H198
				v173.25C198,318.434,275.566,396,371.25,396C275.566,396,198,473.566,198,569.25V742.5h-49.5c-13.662,0-24.75,11.088-24.75,24.75
				S134.838,792,148.5,792h495c13.662,0,24.75-11.088,24.75-24.75S657.162,742.5,643.5,742.5z M247.5,222.75
				c0-43.387,0-173.25,0-173.25h297c0,0,0,133.427,0,173.25c0,68.335-58.188,123.75-129.938,123.75h-37.125
				C305.687,346.5,247.5,291.085,247.5,222.75z M544.5,742.5h-297c0,0,0-129.888,0-173.25c0-68.335,58.187-123.75,129.938-123.75
				h37.125c71.75,0,129.938,55.415,129.938,123.75C544.5,609.072,544.5,742.5,544.5,742.5z"/>
		</g>
	</g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
</svg>

                <time class="article-time--reading">
                    阅读时长: 62 分钟
                </time>
            </div>
        

         
        <div>
            <?xml version="1.0" encoding="iso-8859-1"?>
<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="79.536px" height="79.536px" viewBox="0 0 79.536 79.536" style="enable-background:new 0 0 79.536 79.536;"
	 xml:space="preserve">
<g>
	<path style="fill:#010002;" d="M40.162,17.906C37.415,15.275,21.614,6.141,0,15.451c0,0.138,0,2.722,0,6.654v44.418h32.747
		c1.126,0.968,3.798,1.651,6.926,1.651c3.119,0,5.802-0.684,6.931-1.651h32.933V22.105c0-3.933,0-6.517,0-6.654
		C58.813,6.314,42.257,15.982,40.162,17.906z M37.229,63.349c0-1.75-15.372-11.981-33.125-0.818V19.216
		c3.516-2.014,8.246-3.249,13.463-3.249c10.864,0,19.662,3.562,19.662,10.175V63.349z M75.684,62.53
		c-17.751-11.163-33.108-0.932-33.108,0.818V26.146c0-6.612,8.792-10.175,19.646-10.175c5.22,0,9.952,1.235,13.463,3.249V62.53z"/>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
</svg>

            <time class="article-words">
                文章字数：30683字
            </time>
        </div>
        <div class="article-lastmod">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time>
                    Nov 12, 2024 23:44 &#43;0800
                </time>
            </div></footer>
    

    




    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="lecture-13-sleep--wake-up">Lecture 13 Sleep &amp; Wake up
</h1><h2 id="预习">预习
</h2><h2 id="sleep与wakeup">sleep与wakeup
</h2><p>调度和锁有助于隐藏一个进程对另一个进程的存在，但到目前为止，我们还没有帮助进程进行有意交互的抽象。</p>
<p>为解决这个问题已经发明了许多机制。</p>
<p>Xv6使用了一种称为<code>sleep</code>和<code>wakeup</code>的方法，它允许一个进程在等待事件时休眠，而另一个进程在事件发生后将其唤醒。</p>
<p>睡眠和唤醒通常被称为序列协调（sequence coordination）或条件同步机制（conditional synchronization mechanisms）。</p>
<p>为了说明，让我们考虑一个称为信号量（semaphore）的同步机制，它可以协调生产者和消费者。</p>
<p>信号量维护一个计数并提供两个操作。</p>
<p>“V”操作（对于生产者）增加计数。“P”操作（对于使用者）等待计数为非零，然后递减并返回。</p>
<p>如果只有一个生产者线程和一个消费者线程，并且它们在不同的CPU上执行，并且编译器没有进行过积极的优化，那么此实现将是正确的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">semaphore</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">spinlock</span> <span class="n">lock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">V</span><span class="p">(</span><span class="k">struct</span> <span class="n">semaphore</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">P</span><span class="p">(</span><span class="k">struct</span> <span class="n">semaphore</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面的实现代价昂贵。</p>
<p>如果生产者很少采取行动，消费者将把大部分时间花在<code>while</code>循环中，希望得到非零计数。</p>
<p>消费者的CPU可以找到比通过反复轮询<code>s-&gt;count</code>繁忙等待更有成效的工作。</p>
<p>避免繁忙等待，消费者需要一种方法来释放CPU，并且只有在<code>V</code>增加计数后才能恢复。</p>
<p>这是朝着这个方向迈出的一步，尽管我们将看到这是不够的。</p>
<p>让我们想象一对调用，<code>sleep</code>和<code>wakeup</code>，工作流程如下。</p>
<p><code>Sleep(chan)</code>在任意值<code>chan</code>上睡眠，称为等待通道（wait channel）。</p>
<p><code>Sleep</code>将调用进程置于睡眠状态，释放CPU用于其他工作。</p>
<p><code>Wakeup(chan)</code>唤醒所有在<code>chan</code>上睡眠的进程（如果有），使其<code>sleep</code>调用返回。</p>
<p>如果没有进程在<code>chan</code>上等待，则<code>wakeup</code>不执行任何操作。</p>
<p>我们可以将信号量实现更改为使用<code>sleep</code>和<code>wakeup</code>（更改的行添加了注释）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">V</span><span class="p">(</span><span class="k">struct</span> <span class="n">semaphore</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">wakeup</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>  <span class="c1">// !pay attention
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">P</span><span class="p">(</span><span class="k">struct</span> <span class="n">semaphore</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sleep</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>  <span class="c1">// !pay attention
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>P</code>现在放弃CPU而不是自旋，这很好。</p>
<p>然而，事实证明，使用此接口设计<code>sleep</code>和<code>wakeup</code>而不遭受所谓的丢失唤醒（lost wake-up）问题并非易事。</p>
<p>假设<code>P</code>在第9行发现<code>s-&gt;count==0</code>。</p>
<p>当<code>P</code>在第9行和第10行之间时，<code>V</code>在另一个CPU上运行：它将<code>s-&gt;count</code>更改为非零，并调用<code>wakeup</code>，这样就不会发现进程处于休眠状态，因此不会执行任何操作。</p>
<p>现在P继续在第10行执行：它调用<code>sleep</code>并进入睡眠。这会导致一个问题：<code>P</code>正在休眠，等待调用<code>V</code>，而<code>V</code>已经被调用。</p>
<p>除非我们运气好，生产者再次呼叫<code>V</code>，否则消费者将永远等待，即使<code>count</code>为非零。</p>
<p>这个问题的根源是<code>V</code>在错误的时刻运行，违反了<code>P</code>仅在<code>s-&gt;count==0</code>时才休眠的不变量。</p>
<p>保护不变量的一种不正确的方法是将锁的获取（下面以黄色突出显示）移动到<code>P</code>中，以便其检查<code>count</code>和调用<code>sleep</code>是原子的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">V</span><span class="p">(</span><span class="k">struct</span> <span class="n">semaphore</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">wakeup</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">P</span><span class="p">(</span><span class="k">struct</span> <span class="n">semaphore</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>  <span class="c1">// !pay attention
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sleep</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>人们可能希望这个版本的<code>P</code>能够避免丢失唤醒，因为锁阻止<code>V</code>在第10行和第11行之间执行。</p>
<p>它确实这样做了，但它会导致死锁：<code>P</code>在睡眠时持有锁，因此<code>V</code>将永远阻塞等待锁。</p>
<p>我们将通过更改<code>sleep</code>的接口来修复前面的方案：调用方必须将条件锁（condition lock）传递给sleep，以便在调用进程被标记为asleep并在睡眠通道上等待后<code>sleep</code>可以释放锁。</p>
<p>如果有一个并发的<code>V</code>操作，锁将强制它在<code>P</code>将自己置于睡眠状态前一直等待，因此<code>wakeup</code>将找到睡眠的消费者并将其唤醒。</p>
<p>一旦消费者再次醒来，<code>sleep</code>会在返回前重新获得锁。我们新的正确的<code>sleep/wakeup</code>方案可用如下（更改以黄色突出显示）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">V</span><span class="p">(</span><span class="k">struct</span> <span class="n">semaphore</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">wakeup</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">P</span><span class="p">(</span><span class="k">struct</span> <span class="n">semaphore</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sleep</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>  <span class="c1">// !pay attention
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>P</code>持有<code>s-&gt;lock</code>的事实阻止<code>V</code>在<code>P</code>检查<code>s-&gt;count</code>和调用<code>sleep</code>之间试图唤醒它。然而请注意，我们需要<code>sleep</code>释放<code>s-&gt;lock</code>并使消费者进程进入睡眠状态的操作是原子的。</p>
<h2 id="代码sleep与wakeup">代码：sleep与wakeup
</h2><p>让我们看看<code>sleep</code>（<em><strong>kernel/proc.c</strong></em>:548）和<code>wakeup</code>（<em><strong>kernel/proc.c</strong></em>:582）的实现。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// Atomically release lock and sleep on chan.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Reacquires lock when awakened.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">sleep</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spinlock</span> <span class="o">*</span><span class="n">lk</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nf">myproc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">// Must acquire p-&gt;lock in order to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// change p-&gt;state and then call sched.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Once we hold p-&gt;lock, we can be
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// guaranteed that we won&#39;t miss any wakeup
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// (wakeup locks p-&gt;lock),
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// so it&#39;s okay to release lk.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span><span class="n">lk</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">){</span>  <span class="c1">//DOC: sleeplock0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>  <span class="c1">//DOC: sleeplock1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">release</span><span class="p">(</span><span class="n">lk</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Go to sleep.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">p</span><span class="o">-&gt;</span><span class="n">chan</span> <span class="o">=</span> <span class="n">chan</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SLEEPING</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">sched</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Tidy up.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">p</span><span class="o">-&gt;</span><span class="n">chan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Reacquire original lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span><span class="n">lk</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">acquire</span><span class="p">(</span><span class="n">lk</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Wake up all processes sleeping on chan.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Must be called without any p-&gt;lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">wakeup</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">proc</span><span class="p">[</span><span class="n">NPROC</span><span class="p">];</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SLEEPING</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">chan</span> <span class="o">==</span> <span class="n">chan</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">RUNNABLE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其基本思想是让<code>sleep</code>将当前进程标记为<code>SLEEPING</code>，然后调用<code>sched</code>释放CPU；</p>
<p><code>wakeup</code>查找在给定等待通道上休眠的进程，并将其标记为<code>RUNNABLE</code>。</p>
<p><code>sleep</code>和<code>wakeup</code>的调用者可以使用任何相互间方便的数字作为通道。</p>
<p>Xv6通常使用等待过程中涉及的内核数据结构的地址。</p>
<p><code>sleep</code>获得<code>p-&gt;lock</code>（<em><strong>kernel/proc.c</strong></em>:559）。</p>
<p>要进入睡眠的进程现在同时持有<code>p-&gt;lock</code>和<code>lk</code>。</p>
<p>在调用者（示例中为<code>P</code>）中持有<code>lk</code>是必要的：它确保没有其他进程（在示例中指一个运行的<code>V</code>）可以启动<code>wakeup(chan)</code>调用。</p>
<p>既然<code>sleep</code>持有<code>p-&gt;lock</code>，那么释放<code>lk</code>是安全的：其他进程可能会启动对<code>wakeup(chan)</code>的调用，但是<code>wakeup</code>将等待获取<code>p-&gt;lock</code>，因此将等待<code>sleep</code>把进程置于睡眠状态的完成，以防止<code>wakeup</code>错过<code>sleep</code>。</p>
<p>还有一个小问题：如果<code>lk</code>和<code>p-&gt;lock</code>是同一个锁，那么如果<code>sleep</code>试图获取<code>p-&gt;lock</code>就会自身死锁。</p>
<p>但是，如果调用<code>sleep</code>的进程已经持有<code>p-&gt;lock</code>，那么它不需要做更多的事情来避免错过并发的<code>wakeup</code>。</p>
<p>当<code>wait</code>（<em><strong>kernel/proc.c</strong></em>:582）持有<code>p-&gt;lock</code>调用<code>sleep</code>时，就会出现这种情况。</p>
<p>由于<code>sleep</code>只持有<code>p-&gt;lock</code>而无其他，它可以通过记录睡眠通道、将进程状态更改为<code>SLEEPING</code>并调用<code>sched</code>（<em><strong>kernel/proc.c</strong></em>:564-567）将进程置于睡眠状态。</p>
<p>过一会儿，我们就会明白为什么在进程被标记为<code>SLEEPING</code>之前不将<code>p-&gt;lock</code>释放（由<code>scheduler</code>）是至关重要的。</p>
<p>在某个时刻，一个进程将获取条件锁，设置睡眠者正在等待的条件，并调用<code>wakeup(chan)</code>。</p>
<p>在持有状态锁时调用<code>wakeup</code>非常重要。</p>
<blockquote>
<p>严格地说，<code>wakeup</code>只需跟在<code>acquire</code>之后就足够了（也就是说，可以在<code>release</code>之后调用<code>wakeup</code>）</p>
</blockquote>
<p><code>wakeup</code>遍历进程表（<em><strong>kernel/proc.c</strong></em>:582）。</p>
<p>它获取它所检查的每个进程的<code>p-&gt;lock</code>，这既是因为它可能会操纵该进程的状态，也是因为<code>p-&gt;lock</code>确保<code>sleep</code>和<code>wakeup</code>不会彼此错过。</p>
<p>当<code>wakeup</code>发现一个<code>SLEEPING</code>的进程且<code>chan</code>相匹配时，它会将该进程的状态更改为<code>RUNNABLE</code>。调度器下次运行时，将看到进程已准备好运行。</p>
<p>为什么<code>sleep</code>和<code>wakeup</code>的用锁规则能确保睡眠进程不会错过唤醒？</p>
<p>休眠进程从检查条件之前的某处到标记为休眠之后的某处，要么持有条件锁，要么持有其自身的<code>p-&gt;lock</code>或同时持有两者。</p>
<p>调用<code>wakeup</code>的进程在<code>wakeup</code>的循环中同时持有这两个锁。</p>
<p>因此，要么唤醒器（waker）在消费者线程检查条件之前使条件为真；要么唤醒器的<code>wakeup</code>在睡眠线程标记为<code>SLEEPING</code>后对其进行严格检查。</p>
<p>然后<code>wakeup</code>将看到睡眠进程并将其唤醒（除非有其他东西首先将其唤醒）。</p>
<p>有时，多个进程在同一个通道上睡眠；例如，多个进程读取同一个管道。</p>
<p>一个单独的<code>wakeup</code>调用就能把他们全部唤醒。</p>
<p>其中一个将首先运行并获取与<code>sleep</code>一同调用的锁，并且（在管道例子中）读取在管道中等待的任何数据。</p>
<p>尽管被唤醒，其他进程将发现没有要读取的数据。从他们的角度来看，醒来是“虚假的”，他们必须再次睡眠。</p>
<p>因此，在检查条件的循环中总是调用<code>sleep</code>。</p>
<p>如果两次使用<code>sleep/wakeup</code>时意外选择了相同的通道，则不会造成任何伤害：它们将看到虚假的唤醒，但如上所述的循环将容忍此问题。</p>
<p><code>sleep/wakeup</code>的魅力在于它既轻量级（不需要创建特殊的数据结构来充当睡眠通道），又提供了一层抽象（调用者不需要知道他们正在与哪个特定进程进行交互）。</p>
<h2 id="代码pipes">代码：Pipes
</h2><p>使用睡眠和唤醒来同步生产者和消费者的一个更复杂的例子是xv6的管道实现。</p>
<p>在第1章中看到了管道接口：写入管道一端的字节被复制到内核缓冲区，然后可以从管道的另一端读取。</p>
<p>以后的章节将研究围绕管道的文件描述符支持，但现在让我们看看<code>pipewrite</code>和<code>piperead</code>的实现。</p>
<p>每个管道都由一个<code>struct pipe</code>表示，其中包含一个锁<code>lock</code>和一个数据缓冲区<code>data</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">pipe</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">spinlock</span> <span class="n">lock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="n">PIPESIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="n">uint</span> <span class="n">nread</span><span class="p">;</span>     <span class="c1">// number of bytes read
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">uint</span> <span class="n">nwrite</span><span class="p">;</span>    <span class="c1">// number of bytes written
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">readopen</span><span class="p">;</span>   <span class="c1">// read fd is still open
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">writeopen</span><span class="p">;</span>  <span class="c1">// write fd is still open
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>字段<code>nread</code>和<code>nwrite</code>统计从缓冲区读取和写入缓冲区的总字节数。</p>
<p>缓冲区是环形的：在<code>buf[PIPESIZE-1]</code>之后写入的下一个字节是<code>buf[0]</code>。</p>
<p>而计数不是环形。此约定允许实现区分完整缓冲区（<code>nwrite==nread+PIPESIZE</code>）和空缓冲区（<code>nwrite==nread</code>），但这意味着对缓冲区的索引必须使用<code>buf[nread%PIPESIZE]</code>，而不仅仅是<code>buf[nread]</code>（对于<code>nwrite</code>也是如此）。</p>
<p>让我们假设对<code>piperead</code>和<code>pipewrite</code>的调用同时发生在两个不同的CPU上。</p>
<p><code>Pipewrite</code>（<em><strong>kernel/pipe.c</strong></em>:77）从获取管道锁开始，它保护计数、数据及其相关不变量。</p>
<p><code>Piperead</code>（<em><strong>kernel/pipe.c</strong></em>:103）然后也尝试获取锁，但无法实现。它在<code>acquire</code>（<em><strong>kernel/spinlock.c</strong></em>:22）中旋转等待锁。</p>
<p>当<code>piperead</code>等待时，<code>pipewrite</code>遍历被写入的字节（<code>addr[0..n-1]</code>），依次将每个字节添加到管道中（<em><strong>kernel/pipe.c</strong></em>:95）。</p>
<p>在这个循环中缓冲区可能会被填满（<em><strong>kernel/pipe.c</strong></em>:85）。</p>
<p>在这种情况下，<code>pipewrite</code>调用<code>wakeup</code>来提醒所有处于睡眠状态的读进程缓冲区中有数据等待，然后在<code>&amp;pi-&gt;nwrite</code>上睡眠，等待读进程从缓冲区中取出一些字节。</p>
<p>作为使<code>pipewrite</code>进程进入睡眠状态的一部分，<code>Sleep</code>释放<code>pi-&gt;lock</code>。</p>
<p>现在<code>pi-&gt;lock</code>可用，<code>piperead</code>设法获取它并进入其临界区域：它发现<code>pi-&gt;nread != pi-&gt;nwrite</code>（<em><strong>kernel/pipe.c</strong></em>:110）（<code>pipewrite</code>进入睡眠状态是因为<code>pi-&gt;nwrite == pi-&gt;nread+PIPESIZE</code>（<em><strong>kernel/pipe.c</strong></em>:85））。</p>
<p>因此它进入<code>for</code>循环，从管道中复制数据（<em><strong>kernel/pipe.c</strong></em>:117），并根据复制的字节数增加<code>nread</code>。</p>
<p>那些读出的字节就可供写入，因此<code>piperead</code>调用<code>wakeup</code>（<em><strong>kernel/pipe.c</strong></em>:124）返回之前唤醒所有休眠的写进程。</p>
<p><code>Wakeup</code>寻找一个在<code>&amp;pi-&gt;nwrite</code>上休眠的进程，该进程正在运行<code>pipewrite</code>，但在缓冲区填满时停止。它将该进程标记为<code>RUNNABLE</code>。</p>
<p>管道代码为读者和写者使用单独的睡眠通道（<code>pi-&gt;nread</code>和<code>pi-&gt;nwrite</code>）；这可能会使系统在有许多读者和写者等待同一管道这种不太可能的情况下更加高效。</p>
<p>管道代码在检查休眠条件的循环中休眠；如果有多个读者或写者，那么除了第一个醒来的进程之外，所有进程都会看到条件仍然错误，并再次睡眠。</p>
<h2 id="代码wait-exit和kill">代码：wait, exit和kill
</h2><p><code>Sleep</code>和<code>wakeup</code>可用于多种等待。</p>
<p>第一章介绍的一个有趣的例子是子进程<code>exit</code>和父进程<code>wait</code>之间的交互。</p>
<p>在子进程死亡时，父进程可能已经在<code>wait</code>中休眠，或者正在做其他事情；在后一种情况下，随后的<code>wait</code>调用必须观察到子进程的死亡，可能是在子进程调用<code>exit</code>后很久。</p>
<p>xv6记录子进程终止直到<code>wait</code>观察到它的方式是让<code>exit</code>将调用方置于<code>ZOMBIE</code>状态，在那里它一直保持到父进程的<code>wait</code>注意到它，将子进程的状态更改为<code>UNUSED</code>，复制子进程的<code>exit</code>状态码，并将子进程ID返回给父进程。</p>
<p>如果父进程在子进程之前退出，则父进程将子进程交给<code>init</code>进程，<code>init</code>进程将永久调用<code>wait</code>；因此，每个子进程退出后都有一个父进程进行清理。</p>
<p>主要的实现挑战是父级和子级<code>wait</code>和<code>exit</code>，以及<code>exit</code>和<code>exit</code>之间可能存在竞争和死锁。</p>
<p><code>Wait</code>使用调用进程的<code>p-&gt;lock</code>作为条件锁，以避免丢失唤醒，并在开始时获取该锁（<em><strong>kernel/proc.c</strong></em>:398）。</p>
<p>然后它扫描进程表。如果它发现一个子进程处于<code>ZOMBIE</code>状态，它将释放该子进程的资源及其<code>proc</code>结构体，将该子进程的退出状态码复制到提供给<code>wait</code>的地址（如果不是0），并返回该子进程的进程ID。</p>
<p>如果<code>wait</code>找到子进程但没有子进程退出，它将调用<code>sleep</code>以等待其中一个退出（<em><strong>kernel/proc.c</strong></em>:445），然后再次扫描。</p>
<p>这里，<code>sleep</code>中释放的条件锁是等待进程的<code>p-&gt;lock</code>，这是上面提到的特例。</p>
<p>注意，<code>wait</code>通常持有两个锁：它在试图获得任何子进程的锁之前先获得自己的锁；因此，整个xv6都必须遵守相同的锁定顺序（父级，然后是子级），以避免死锁。</p>
<p><code>Wait</code>查看每个进程的<code>np-&gt;parent</code>以查找其子进程。它使用<code>np-&gt;parent</code>而不持有<code>np-&gt;lock</code>，这违反了通常的规则，即共享变量必须受到锁的保护。</p>
<p><code>np</code>可能是当前进程的祖先，在这种情况下，获取<code>np-&gt;lock</code>可能会导致死锁，因为这将违反上述顺序。</p>
<p>这种情况下无锁检查<code>np-&gt;parent</code>似乎是安全的：进程的<code>parent</code>字段仅由其父进程更改，因此如果<code>np-&gt;parent==p</code>为<code>true</code>，除非当前流程更改它，否则该值无法被更改，</p>
<p><code>Exit</code>（*<strong>kernel/proc.c*</strong>:333）记录退出状态码，释放一些资源，将所有子进程提供给<code>init</code>进程，在父进程处于等待状态时唤醒父进程，将调用方标记为僵尸进程（zombie），并永久地让出CPU。</p>
<p>最后的顺序有点棘手。</p>
<p>退出进程必须在将其状态设置为<code>ZOMBIE</code>并唤醒父进程时持有其父进程的锁，因为父进程的锁是防止在<code>wait</code>中丢失唤醒的条件锁。</p>
<p>子级还必须持有自己的<code>p-&gt;lock</code>，否则父级可能会看到它处于<code>ZOMBIE</code>状态，并在它仍运行时释放它。</p>
<p>锁获取顺序对于避免死锁很重要：因为<code>wait</code>先获取父锁再获取子锁，所以<code>exit</code>必须使用相同的顺序。</p>
<p><code>Exit</code>调用一个专门的唤醒函数<code>wakeup1</code>，该函数仅唤醒父进程，且父进程必须正在<code>wait</code>中休眠（<em><strong>kernel/proc.c</strong></em>:598）。</p>
<p>在将自身状态设置为<code>ZOMBIE</code>之前，子进程唤醒父进程可能看起来不正确，但这是安全的：</p>
<p>虽然<code>wakeup1</code>可能会导致父进程运行，但<code>wait</code>中的循环在<code>scheduler</code>释放子进程的<code>p-&gt;lock</code>之前无法检查子进程，所以<code>wait</code>在<code>exit</code>将其状态设置为<code>ZOMBIE</code>（<em><strong>kernel/proc.c</strong></em>:386）之前不能查看退出进程。</p>
<p><code>exit</code>允许进程自行终止，而<code>kill</code>（<em><strong>kernel/proc.c</strong></em>:611）允许一个进程请求另一个进程终止。</p>
<p>对于<code>kill</code>来说，直接销毁受害者进程（即要杀死的进程）太复杂了，因为受害者可能在另一个CPU上执行，也许是在更新内核数据结构的敏感序列中间。</p>
<p>因此，<code>kill</code>的工作量很小：它只是设置受害者的<code>p-&gt;killed</code>，如果它正在睡眠，则唤醒它。</p>
<p>受害者进程终将进入或离开内核，此时，如果设置了<code>p-&gt;killed</code>，<code>usertrap</code>中的代码将调用<code>exit</code>。</p>
<p>如果受害者在用户空间中运行，它将很快通过进行系统调用或由于计时器（或其他设备）中断而进入内核。</p>
<p>如果受害者进程在<code>sleep</code>中，<code>kill</code>对<code>wakeup</code>的调用将导致受害者从<code>sleep</code>中返回。</p>
<p>这存在潜在的危险，因为等待的条件可能不为真。</p>
<p>但是，xv6对<code>sleep</code>的调用总是封装在<code>while</code>循环中，该循环在<code>sleep</code>返回后重新测试条件。</p>
<p>一些对<code>sleep</code>的调用还在循环中测试<code>p-&gt;killed</code>，如果它被设置，则放弃当前活动。</p>
<p>只有在这种放弃是正确的情况下才能这样做。</p>
<p>例如，如果设置了<code>killed</code>标志，则管道读写代码返回；最终代码将返回到陷阱，陷阱将再次检查标志并退出。</p>
<p>一些XV6的<code>sleep</code>循环不检查<code>p-&gt;killed</code>，因为代码在应该是原子操作的多步系统调用的中间。</p>
<p>virtio驱动程序（<em><strong>kernel/virtio_disk.c</strong></em>:242）就是一个例子：它不检查<code>p-&gt;killed</code>，因为一个磁盘操作可能是文件系统保持正确状态所需的一组写入操作之一。</p>
<p>等待磁盘I/O时被杀死的进程将不会退出，直到它完成当前系统调用并且<code>usertrap</code>看到<code>killed</code>标志</p>
<h2 id="真实世界">真实世界
</h2><p>xv6调度器实现了一个简单的调度策略：它依次运行每个进程。这一策略被称为轮询调度（round robin）。</p>
<p>真实的操作系统实施更复杂的策略，例如，允许进程具有优先级。其思想是调度器将优先选择可运行的高优先级进程，而不是可运行的低优先级进程。</p>
<p>这些策略可能变得很复杂，因为常常存在相互竞争的目标：例如，操作系统可能希望保证公平性和高吞吐量。</p>
<p>此外，复杂的策略可能会导致意外的交互，例如优先级反转（priority inversion）和航队（convoys）。</p>
<p>当低优先级进程和高优先级进程共享一个锁时，可能会发生优先级反转，当低优先级进程持有该锁时，可能会阻止高优先级进程前进。</p>
<p>当许多高优先级进程正在等待一个获得共享锁的低优先级进程时，可能会形成一个长的等待进程航队；一旦航队形成，它可以持续很长时间。</p>
<p>为了避免此类问题，在复杂的调度器中需要额外的机制。</p>
<p>睡眠和唤醒是一种简单有效的同步方法，但还有很多其他方法。</p>
<p>所有这些问题中的第一个挑战是避免我们在本章开头看到的“丢失唤醒”问题。</p>
<p>原始Unix内核的<code>sleep</code>只是禁用了中断，这就足够了，因为Unix运行在单CPU系统上。</p>
<p>因为xv6在多处理器上运行，所以它为<code>sleep</code>添加了一个显式锁。</p>
<p>FreeBSD的<code>msleep</code>采用了同样的方法。</p>
<p>Plan 9的<code>sleep</code>使用一个回调函数，该函数在马上睡眠时获取调度锁，并在运行中持有；该函数用于在最后时刻检查睡眠条件，以避免丢失唤醒。</p>
<p>Linux内核的<code>sleep</code>使用一个显式的进程队列，称为等待队列，而不是等待通道；队列有自己内部的锁。</p>
<p>在<code>wakeup</code>中扫描整个进程列表以查找具有匹配<code>chan</code>的进程效率低下。</p>
<p>一个更好的解决方案是用一个数据结构替换<code>sleep</code>和<code>wakeup</code>中的<code>chan</code>，该数据结构包含在该结构上休眠的进程列表，例如Linux的等待队列。</p>
<p>Plan 9的<code>sleep</code>和<code>wakeup</code>将该结构称为集结点（rendezvous point）或Rendez。</p>
<p>许多线程库引用与条件变量相同的结构；在这种情况下，<code>sleep</code>和<code>wakeup</code>操作称为<code>wait</code>和<code>signal</code>。</p>
<p>所有这些机制都有一个共同的特点：睡眠条件受到某种在睡眠过程中原子级释放的锁的保护。</p>
<p><code>wakeup</code>的实现会唤醒在特定通道上等待的所有进程，可能有许多进程在等待该特定通道。</p>
<p>操作系统将安排所有这些进程，它们将竞相检查睡眠条件。</p>
<p>进程的这种行为有时被称为惊群效应（thundering herd），最好避免。</p>
<p>大多数条件变量都有两个用于唤醒的原语：<code>signal</code>用于唤醒一个进程；<code>broadcast</code>用于唤醒所有等待进程。</p>
<p>信号量（Semaphores）通常用于同步。</p>
<p>计数count通常对应于管道缓冲区中可用的字节数或进程具有的僵尸子进程数。</p>
<p>使用显式计数作为抽象的一部分可以避免“丢失唤醒”问题：使用显式计数记录已经发生<code>wakeup</code>的次数。计数还避免了虚假唤醒和惊群效应问题。</p>
<p>终止进程并清理它们在xv6中引入了很多复杂性。</p>
<p>在大多数操作系统中甚至更复杂，因为，例如，受害者进程可能在内核深处休眠，而展开其栈空间需要非常仔细的编程。</p>
<p>许多操作系统使用显式异常处理机制（如<code>longjmp</code>）来展开栈。</p>
<p>此外，还有其他事件可能导致睡眠进程被唤醒，即使它等待的事件尚未发生。</p>
<p>例如，当一个Unix进程处于休眠状态时，另一个进程可能会向它发送一个<code>signal</code>。</p>
<p>在这种情况下，进程将从中断的系统调用返回，返回值为-1，错误代码设置为<code>EINTR</code>。</p>
<p>应用程序可以检查这些值并决定执行什么操作。</p>
<p>Xv6不支持信号，因此不会出现这种复杂性。</p>
<p>Xv6对<code>kill</code>的支持并不完全令人满意：有一些<code>sleep</code>循环可能应该检查<code>p-&gt;killed</code>。</p>
<p>一个相关的问题是，即使对于检查<code>p-&gt;killed</code>的<code>sleep</code>循环，<code>sleep</code>和<code>kill</code>之间也存在竞争；后者可能会设置<code>p-&gt;killed</code>，并试图在受害者的循环检查<code>p-&gt;killed</code>之后但在调用<code>sleep</code>之前尝试唤醒受害者。</p>
<p>如果出现此问题，受害者将不会注意到<code>p-&gt;killed</code>，直到其等待的条件发生。</p>
<p>这可能比正常情况要晚一点（例如，当virtio驱动程序返回受害者正在等待的磁盘块时）或永远不会发生（例如，如果受害者正在等待来自控制台的输入，但用户没有键入任何输入）。</p>
<blockquote>
<p>注：上节中说到kill的工作方式，<code>kill</code>设置<code>p-&gt;killed</code>，如果遇到进程正在休眠，则会唤醒它，此后在<code>usertrap</code>中检测<code>p-&gt;killed</code>，并使进程退出</p>
<p>而如果像上面说的，在检查<code>p-&gt;killed</code>之后调用<code>sleep</code>之前唤醒受害者进程，那么接下来执行<code>sleep</code>就会导致进程无法进入内核，无法在<code>usertrap</code>中退出，而必须等待所需事件的发生再次唤醒</p>
</blockquote>
<p>一个实际的操作系统将在固定时间内使用空闲列表找到自由的<code>proc</code>结构体，而不是<code>allocproc</code>中的线性时间搜索；xv6使用线性扫描是为了简单起见。</p>
<h2 id="正课">正课
</h2><h2 id="线程切换过程中锁的限制">线程切换过程中锁的限制
</h2><p>在XV6中，任何时候调用switch函数都会从一个线程切换到另一个线程，通常是在用户进程的内核线程和调度器线程之间切换。</p>
<p>在调用switch函数之前，总是会先获取线程对应的用户进程的锁。</p>
<p>所以过程是这样，一个进程先获取自己的锁，然后调用switch函数切换到调度器线程，调度器线程再释放进程锁。</p>
<p>实际上的代码顺序更像这样：</p>
<ol>
<li>一个进程出于某种原因想要进入休眠状态，比如说出让CPU或者等待数据，它会先获取自己的锁；</li>
<li>之后进程将自己的状态从RUNNING设置为RUNNABLE；</li>
<li>之后进程调用switch函数，其实是调用sched函数在sched函数中再调用的switch函数；</li>
<li>switch函数将当前的线程切换到调度器线程；</li>
<li>调度器线程之前也调用了switch函数，现在恢复执行会从自己的switch函数返回；</li>
<li>返回之后，调度器线程会释放刚刚出让了CPU的进程的锁</li>
</ol>
<p>在第1步中获取进程的锁的原因是，这样可以阻止其他CPU核的调度器线程在当前进程完成切换前，发现进程是RUNNABLE的状态并尝试运行它。</p>
<p>为什么要阻止呢？因为其他每一个CPU核都有一个调度器线程在遍历进程表单，如果没有在进程切换的最开始就获取进程的锁的话，其他CPU核就有可能在当前进程还在运行时，认为该进程是RUNNABLE并运行它。</p>
<p>而两个CPU核使用同一个栈运行同一个线程会使得系统立即崩溃。</p>
<p>所以，在进程切换的最开始，进程先获取自己的锁，并且直到调用switch函数时也不释放锁。</p>
<p>而另一个线程，也就是调度器线程会在进程的线程完全停止使用自己的栈之后，再释放进程的锁。</p>
<p>释放锁之后，就可以由其他的CPU核再来运行进程的线程，因为这些线程现在已经不在运行了。</p>
<p>以上是线程切换中非常重要的知识点。</p>
<p>我们之后会用到它，因为这是Sleep&amp;Wakeup设计中众多限制条件之一。</p>
<blockquote>
<p>学生提问：当我们有多个CPU核时，它们能看到同样的锁对象的唯一原因只可能是它们有一个共享的物理内存系统，对吧？</p>
<p>Robert教授：是的。如果你有两个电脑，那么它们不会共享内存，并且我们就不会有这些问题。现在的处理器上，总是有多个CPU核，它们共享了相同的内存系统。</p>
</blockquote>
<p>在线程切换的过程中，还有一点我之前没有提过。</p>
<p>XV6中，不允许进程在执行switch函数的过程中，持有任何其他的锁。</p>
<p>所以，进程在调用switch函数的过程中，必须要持有p-&gt;lock（注，也就是进程对应的proc结构体中的锁），但是同时又不能持有任何其他的锁。</p>
<p>这也是包含了Sleep在内的很多设计的限制条件之一。</p>
<p>接下来让我解释一下背后的原因，首先构建一个不满足这个限制条件的场景：</p>
<p>我们有进程P1，P1的内核线程持有了p-&gt;lock以外的其他锁，这些锁可能是在使用磁盘，UART，console过程中持有的。</p>
<p>之后内核线程在持有锁的时候，通过调用switch/yield/sched函数出让CPU，这会导致进程P1持有了锁，但是进程P1又不在运行。</p>
<p>假设我们在一个只有一个CPU核的机器上，进程P1调用了switch函数将CPU控制转给了调度器线程，调度器线程发现还有一个进程P2的内核线程正在等待被运行，所以调度器线程会切换到运行进程P2。</p>
<p>假设P2也想使用磁盘，UART或者console，它会对P1持有的锁调用acquire，这是对于同一个锁的第二个acquire调用。</p>
<p>当然这个锁现在已经被P1持有了，所以这里的acquire并不能获取锁。</p>
<p>假设这里是spinlock，那么进程P2会在一个循环里不停的“旋转”并等待锁被释放。</p>
<p>但是很明显进程P2的acquire不会返回，所以即使进程P2稍后愿意出让CPU，P2也没机会这么做。</p>
<p>之所以没机会是因为P2对于锁的acquire调用在直到锁释放之前都不会返回，而唯一锁能被释放的方式就是进程P1恢复执行并在稍后release锁，但是这一步又还没有发生，因为进程P1通过调用switch函数切换到了P2，而P2又在不停的“旋转”并等待锁被释放。这是一种死锁，它会导致系统停止运行。</p>
<p>虽然我刚刚的描述是基于机器上只有一个CPU核，但是你可以通过多个锁在多个CPU核的机器上构建类似的死锁场景。</p>
<p>所以，我们在XV6中禁止在调用switch时持有除进程自身锁（注，也就是p-&gt;lock）以外的其他锁。</p>
<blockquote>
<p>学生提问：难道定时器中断不会将CPU控制切换回进程P1从而解决死锁的问题吗？</p>
<p>Robert教授：首先，所有的进程切换过程都发生在内核中，所有的acquire，switch，release都发生在内核代码而不是用户代码。实际上XV6允许在执行内核代码时触发中断，如果你查看trap.c中的代码你可以发现，如果XV6正在执行内核代码时发生了定时器中断，中断处理程序会调用yield函数并出让CPU。</p>
<p>但是在之前的课程中我们讲过acquire函数在等待锁之前会关闭中断，否则的话可能会引起死锁（注，详见10.8），</p>
<p>所以我们不能在等待锁的时候处理中断。所以如果你查看XV6中的acquire函数，你可以发现函数中第一件事情就是关闭中断，之后再“自旋”等待锁释放。你或许会想，为什么不能先“自旋”等待锁释放，再关闭中断？因为这样会有一个短暂的时间段锁被持有了但是中断没有关闭，在这个时间段内的设备的中断处理程序可能会引起死锁。</p>
<p>所以不幸的是，当我们在自旋等待锁释放时会关闭中断，进而阻止了定时器中断并且阻止了进程P2将CPU出让回给进程P1。嗯，这是个好问题。</p>
<p>学生提问：能重复一下死锁是如何避免的吗？</p>
<p>Robert教授：哦，在XV6中，死锁是通过禁止在线程切换的时候加锁来避免的。</p>
<p>XV6禁止在调用switch函数时，获取除了p-&gt;lock以外的其他锁。如果你查看sched函数的代码（注，详见11.6），里面包含了一些检查代码来确保除了p-&gt;lock以外线程不持有其他锁。所以上面会产生死锁的代码在XV6中是不合法的并被禁止的。</p>
</blockquote>
<p>将这里描述的对于锁的两个限制条件记住，因为我们后面讨论Sleep&amp;Wakeup如何工作时会再次使用它们。</p>
<blockquote>
<p>在多核系统中，进程或者线程为了同步和共享资源，通常使用锁（如自旋锁）。但是在锁的操作中，如果处理不当，可能会引发<strong>死锁</strong>。死锁发生在多个进程/线程因为争抢资源（锁）而互相等待，导致系统无法前进。</p>
<p>当一个进程/线程试图获取某个锁时（<code>acquire</code>），它可能会进入“自旋等待”状态，直到锁被释放。如果此时中断没有被关闭，可能会发生以下情况：</p>
<p>假设某个进程（P1）已经持有锁，并正在执行一些关键代码，而另一个进程（P2）正在尝试获取同一个锁，但因为锁已经被 P1 持有，所以 P2 进入自旋等待状态。在这种情况下，如果不关闭中断，可能会发生以下情景：</p>
<ol>
<li><strong>中断触发上下文切换</strong>：如果在 P2 自旋等待的过程中发生了定时器中断，操作系统可能会在 P2 等待锁时尝试进行上下文切换。这意味着 CPU 控制可能会切换到另一个进程（例如 P1），但这个切换可能会导致问题。</li>
<li><strong>中断处理程序持有锁</strong>：假设中断处理程序需要持有同一个锁，但锁已经被 P1 持有，这可能会导致死锁。如果中断处理程序没有获取锁而被阻塞，并且 P1 继续等待另一个资源或中断处理结束，那么系统会陷入死锁状态。</li>
<li><strong>设备中断与并发操作的冲突</strong>：如果在 P1 正在持有锁时，设备中断处理程序试图获取该锁，并在中断上下文中运行某些代码，那么设备中断的处理将被阻塞。这样，既无法完成设备的中断响应，又可能导致进程无法正常释放锁，进一步加剧系统的死锁风险。</li>
</ol>
<p>为了避免这种情况，<code>acquire</code> 函数在等待锁之前会关闭中断。这样可以确保在进程/线程自旋等待锁的时候，不会被中断打断，从而防止中断处理程序引发的竞争条件或死锁。具体来说，关闭中断有以下好处：</p>
<ul>
<li><strong>避免中断处理程序的竞争</strong>：当一个进程关闭中断并开始等待锁时，确保了 CPU 不会因为中断处理而切换到另一个进程。这样，持有锁的进程（如 P1）可以继续执行，直到释放锁，而不会因为中断导致死锁。</li>
<li><strong>防止并发修改状态</strong>：锁保护的是共享数据的访问，关闭中断后，确保了其他硬件中断（比如定时器、设备中断）不会打断当前进程对锁和共享数据的操作。中断处理程序不能抢占当前进程，数据一致性得以保障。</li>
</ul>
<p>如果我们在自旋等待锁释放时才关闭中断（即：先“自旋”再关闭中断），会存在一个竞态条件。在这个短暂的时间段内，虽然锁还没有被成功获取，但是中断已经没有关闭。这种情况下，设备中断可能会触发，并执行某些需要持有锁的操作，导致中断处理程序和进程竞争同一个锁，从而引发死锁。</p>
</blockquote>
<h2 id="sleepwakeup接口">Sleep&amp;Wakeup接口
</h2><p>接下来看一下通过Sleep&amp;Wakeup实现Coordination。</p>
<p>锁可以使得线程本身不必关心其他线程的具体实现。</p>
<p>我们为共享的数据增加锁，这样就不用担心其他线程也使用了相同的数据，因为锁可以确保对于数据的操作是依次发生的。</p>
<p>当你在写一个线程的代码时，有些场景需要等待一些特定的事件，或者不同的线程之间需要交互。</p>
<ul>
<li>
<p>假设我们有一个Pipe，并且我正在从Pipe中读数据。但是Pipe当前又没有数据，所以我需要等待一个Pipe非空的事件。</p>
</li>
<li>
<p>类似的，假设我在读取磁盘，我会告诉磁盘控制器请读取磁盘上的特定块。这或许要花费较长的时间，尤其当磁碟需要旋转时</p>
<p>（通常是毫秒级别），磁盘才能完成读取。而执行读磁盘的进程需要等待读磁盘结束的事件。</p>
</li>
<li>
<p>类似的，一个Unix进程可以调用wait函数。这个会使得调用进程等待任何一个子进程退出。所以这里父进程有意的在等待另一个进程产生的事件。</p>
</li>
</ul>
<p>以上就是进程需要等待特定事件的一些例子。</p>
<p>特定事件可能来自于I/O，也可能来自于另一个进程，并且它描述了某件事情已经发生。</p>
<p>Coordination是帮助我们解决这些问题并帮助我们实现这些需求的工具。Coordination是非常基础的工具，就像锁一样，在实现线程代码时它会一直出现。</p>
<p>我们怎么能让进程或者线程等待一些特定的事件呢？一种非常直观的方法是通过循环实现busy-wait。</p>
<p>假设我们想从一个Pipe读取数据，我们就写一个循环一直等待Pipe的buffer不为空。</p>
<p>这个循环会一直运行直到其他的线程向Pipe的buffer写了数据。之后循环会结束，我们就可以从Pipe中读取数据并返回。</p>
<p>实际中会有这样的代码。</p>
<p>如果你知道你要等待的事件极有可能在0.1微秒内发生，通过循环等待或许是最好的实现方式。</p>
<p>通常来说在操作设备硬件的代码中会采用这样的等待方式，如果你要求一个硬件完成一个任务，并且你知道硬件总是能非常快的完成任务，这时通过一个类似的循环等待或许是最正确的方式。</p>
<p>另一方面，事件可能需要数个毫秒甚至你都不知道事件要多久才能发生，或许要10分钟其他的进程才能向Pipe写入数据，那么我们就不想在这一直循环并且浪费本可以用来完成其他任务的CPU时间。</p>
<p>这时我们想要通过类似switch函数调用的方式出让CPU，并在我们关心的事件发生时重新获取CPU。</p>
<p>Coordination就是有关出让CPU，直到等待的事件发生再恢复执行。</p>
<p>人们发明了很多不同的Coordination的实现方式，但是与许多Unix风格操作系统一样，XV6使用的是Sleep&amp;Wakeup这种方式。</p>
<p>介绍完背景了，接下来我们看一下XV6的代码。</p>
<p>为了准备这节课，我重写了UART的驱动代码，XV6通过这里的驱动代码从console中读写字符。</p>
<p><img src="/p/mit6s08113sleep-wake-up/p13.png"
	width="488"
	height="416"
	srcset="/p/mit6s08113sleep-wake-up/p13_hu9048506392882014657.png 480w, /p/mit6s08113sleep-wake-up/p13_hu4195329335850157704.png 1024w"
	loading="lazy"
	
		alt="p13"
	
	
		class="gallery-image" 
		data-flex-grow="117"
		data-flex-basis="281px"
	
></p>
<p>首先是uartwrite函数。</p>
<p>当shell需要输出时会调用write系统调用最终走到uartwrite函数中，这个函数会在循环中将buf中的字符一个一个的向UART硬件写入。</p>
<p>这是一种经典的设备驱动实现风格，你可以在很多设备驱动中看到类似的代码。</p>
<p>UART硬件一次只能接受一个字符的传输，而通常来说会有很多字符需要写到UART硬件。你可以向UART硬件写入一个字符，并等待UART硬件说：好的我完成了传输上一个字符并且准备好了传输下一个字符，之后驱动程序才可以写入下一个字符。</p>
<p>因为这里的硬件可能会非常慢，或许每秒只能传输1000个字符，所以我们在两个字符之间的等待时间可能会很长。</p>
<p>而1毫秒在现在计算机上是一个非常非常长的时间，它可能包含了数百万条指令时间，所以我们不想通过循环来等待UART完成字符传输，我们想通过一个更好的方式来等待。</p>
<p>如大多数操作系统一样，XV6也的确存在更好的等待方式。</p>
<p>UART硬件会在完成传输一个字符后，触发一个中断。</p>
<p>所以UART驱动中除了uartwrite函数外，还有名为uartintr的中断处理程序。这个中断处理程序会在UART硬件触发中断时由trap.c代码调用。</p>
<p><img src="/p/mit6s08113sleep-wake-up/p14.png"
	width="1032"
	height="622"
	srcset="/p/mit6s08113sleep-wake-up/p14_hu15900266075412204530.png 480w, /p/mit6s08113sleep-wake-up/p14_hu17020798669946552960.png 1024w"
	loading="lazy"
	
		alt="p14"
	
	
		class="gallery-image" 
		data-flex-grow="165"
		data-flex-basis="398px"
	
></p>
<p>中断处理程序会在最开始读取UART对应的memory mapped register，并检查其中表明传输完成的相应的标志位，也就是LSR_TX_IDLE标志位。</p>
<p>如果这个标志位为1，代码会将tx_done设置为1，并调用wakeup函数。</p>
<p>这个函数会使得uartwrite中的sleep函数恢复执行，并尝试发送一个新的字符。</p>
<p>所以这里的机制是，如果一个线程需要等待某些事件，比如说等待UART硬件愿意接收一个新的字符，线程调用sleep函数并等待一个特定的条件。</p>
<p>当特定的条件满足时，代码会调用wakeup函数。</p>
<p>这里的sleep函数和wakeup函数是成对出现的。</p>
<p>我们之后会看sleep函数的具体实现，它会做很多事情最后再调用switch函数来出让CPU。</p>
<p>这里有件事情需要注意，sleep和wakeup函数需要通过某种方式链接到一起。</p>
<p>也就是说，如果我们调用wakeup函数，我们只想唤醒正在等待刚刚发生的特定事件的线程。</p>
<p>所以，sleep函数和wakeup函数都带有一个叫做sleep channel的参数。</p>
<p>我们在调用wakeup的时候，需要传入与调用sleep函数相同的sleep channel。</p>
<p>不过sleep和wakeup函数只是接收表示了sleep channel的64bit数值，它们并不关心这个数值代表什么。</p>
<p>当我们调用sleep函数时，我们通过一个sleep channel表明我们等待的特定事件，当调用wakeup时我们希望能传入相同的数值来表明想唤醒哪个线程。</p>
<blockquote>
<p>学生提问：进程会在写入每个字符时候都被唤醒一次吗？</p>
<p>Robert教授：在这个我出于演示目的而特别改过的UART驱动中，传输每个字符都会有一个中断，所以你是对的，对于buffer中的每个字符，我们都会等待UART可以接收下一个字符，之后写入一个字符，将tx_done设置为0，回到循环的最开始并再次调用sleep函数进行睡眠状态，直到tx_done为1。当UART传输完了这个字符，uartintr函数会将tx_done设置为1，并唤醒uartwrite所在的线程。所以对于每个字符都有调用一次sleep和wakeup，并占用一次循环。</p>
<p>UART实际上支持一次传输4或者16个字符，所以一个更有效的驱动会在每一次循环都传输16个字符给UART，并且中断也是每16个字符触发一次。更高速的设备，例如以太网卡通常会更多个字节触发一次中断。</p>
</blockquote>
<p>以上就是接口的演示。</p>
<p>Sleep&amp;wakeup的一个优点是它们可以很灵活，它们不关心代码正在执行什么操作，你不用告诉sleep函数你在等待什么事件，你也不用告诉wakeup函数发生了什么事件，你只需要匹配好64bit的sleep channel就行。</p>
<p>不过，对于sleep函数，有一个有趣的参数，我们需要将一个锁作为第二个参数传入，这背后是一个大的故事，我后面会介绍背后的原因。</p>
<p>总的来说，不太可能设计一个sleep函数并完全忽略需要等待的事件。</p>
<p>所以很难写一个通用的sleep函数，只是睡眠并等待一些特定的事件，并且这也很危险，因为可能会导致lost wakeup，而几乎所有的Coordination机制都需要处理lost wakeup的问题。</p>
<p>在sleep接口中，我们需要传入一个锁是一种稍微丑陋的实现，我在稍后会再介绍。</p>
<h2 id="lost-wakeup">Lost wakeup
</h2><p>在解释sleep函数为什么需要一个锁使用作为参数传入之前，我们先来看看假设我们有了一个更简单的不带锁作为参数的sleep函数，会有什么样的结果。这里的结果就是lost wakeup。</p>
<p>假设sleep只是接收任意的sleep channel作为唯一的参数。</p>
<p>它其实不能正常工作，我们称这个sleep实现为broken_sleep。</p>
<p>你可以想象一个sleep函数内会将进程的状态设置为SLEEPING，表明当前进程不想再运行，而是正在等待一个特定的事件。</p>
<p>如果你们看过了XV6的实现，你们可以发现sleep函数中还会做很多其他操作。</p>
<p>我们需要记录特定的sleep channel值，这样之后的wakeup函数才能发现是当前进程正在等待wakeup对应的事件。</p>
<p>最后再调用switch函数出让CPU。</p>
<p>如果sleep函数只做了这些操作，那么很明显sleep函数会出问题，我们至少还应该在这里获取进程的锁。</p>
<p>之后是wakeup函数。</p>
<p>我们希望唤醒所有正在等待特定sleep channel的线程。</p>
<p>所以wakeup函数中会查询进程表单中的所有进程，如果进程的状态是SLEEPING并且进程对应的channel是当前wakeup的参数，那么将进程的状态设置为RUNNABLE。</p>
<p>在一些平行宇宙中，sleep&amp;wakeup或许就是这么简单。</p>
<p>在我回到XV6代码之前，让我演示一下如何在UART驱动中使用刚刚介绍的sleep和wakeup函数。</p>
<p>首先是定义done标志位。之后是定义uartwrite函数。</p>
<p>在函数中，对于buffer内的每一个字符，检查done标志位，如果标志位为0，就调用sleep函数并传入tx_channel。</p>
<p>之后将字符传递给UART并将done设置为0。</p>
<p>之后是中断处理函数uartintr。</p>
<p>函数中首先将done标志位设置为1，并调用wakeup。</p>
<p>以上就是使用broken_sleep的方式。这里缺失的是锁。</p>
<p>这里uartwrite和uartintr两个函数需要使用锁来协调工作。</p>
<ul>
<li>第一个原因是done标志位，任何时候我们有了共享的数据，我们需要为这个数据加上锁。</li>
<li>另一个原因是两个函数都需要访问UART硬件，通常来说让两个线程并发的访问memory mapped register是错误的行为。</li>
</ul>
<p>所以我们需要在两个函数中加锁来避免对于done标志位和硬件的竞争访问。</p>
<p>现在的问题是，我们该在哪个位置加锁？在中断处理程序中较为简单，我们在最开始加锁，在最后解锁。</p>
<p>难的是如何在uartwrite函数中加锁。一种可能是，每次发送一个字符的过程中持有锁，所以在每一次遍历buffer的起始和结束位置加锁和解锁。</p>
<p>为什么这样肯定不能工作？一个原因是，我们能从while not done的循环退出的唯一可能是中断处理程序将done设置为1。</p>
<p>但是如果我们为整个代码段都加锁的话，中断处理程序就不能获取锁了，中断程序会不停“自旋”并等待锁释放。</p>
<p>而锁被uartwrite持有，在done设置为1之前不会释放。</p>
<p>而done只有在中断处理程序获取锁之后才可能设置为1。</p>
<p>所以我们不能在发送每个字符的整个处理流程都加锁。</p>
<p>上面加锁方式的问题是，uartwrite在期望中断处理程序执行的同时又持有了锁。</p>
<p>而我们唯一期望中断处理程序执行的位置就是sleep函数执行期间，其他的时候uartwrite持有锁是没有问题的。</p>
<p>所以另一种实现可能是，在传输字符的最开始获取锁，因为我们需要保护共享变量done，但是在调用sleep函数之前释放锁。</p>
<p>这样中断处理程序就有可能运行并且设置done标志位为1。</p>
<p>之后在sleep函数返回时，再次获取锁。</p>
<p>让我来修改代码，并看看相应的运行结果是什么。现有的代码中，uartwrite在最开始获取了锁，并在最后释放了锁。</p>
<p><img src="/p/mit6s08113sleep-wake-up/p15.png"
	width="652"
	height="436"
	srcset="/p/mit6s08113sleep-wake-up/p15_hu4295009018915899424.png 480w, /p/mit6s08113sleep-wake-up/p15_hu16512682733592663328.png 1024w"
	loading="lazy"
	
		alt="p15"
	
	
		class="gallery-image" 
		data-flex-grow="149"
		data-flex-basis="358px"
	
></p>
<p>中断处理程序也在最开始获取锁，之后释放锁。</p>
<p><img src="/p/mit6s08113sleep-wake-up/p16.png"
	width="644"
	height="284"
	srcset="/p/mit6s08113sleep-wake-up/p16_hu14699424372301306542.png 480w, /p/mit6s08113sleep-wake-up/p16_hu6634492582513114666.png 1024w"
	loading="lazy"
	
		alt="p16"
	
	
		class="gallery-image" 
		data-flex-grow="226"
		data-flex-basis="544px"
	
></p>
<p>接下来，我们会探索为什么只接收一个参数的broken_sleep在这不能工作。</p>
<p>为了让锁能正常工作，我们需要在调用broken_sleep函数之前释放uart_tx_lock，并在broken_sleep返回时重新获取锁。</p>
<p>broken_sleep内的代码与之前在白板上演示的是一样的。也就是首先将进程状态设置为SLEEPING，并且保存tx_chan到进程结构体中，最后调用switch函数。</p>
<p><img src="/p/mit6s08113sleep-wake-up/p17.png"
	width="544"
	height="532"
	srcset="/p/mit6s08113sleep-wake-up/p17_hu10102088166559816494.png 480w, /p/mit6s08113sleep-wake-up/p17_hu8733463034169091858.png 1024w"
	loading="lazy"
	
		alt="p17"
	
	
		class="gallery-image" 
		data-flex-grow="102"
		data-flex-basis="245px"
	
></p>
<p>接下来编译代码并看一下会发生什么。</p>
<p>在XV6启动的时候会打印“init starting”，这里看来输出了一些字符之后就hang住了。如果我输入任意字符，剩下的字符就能输出。</p>
<p>这里的问题必然与之前修改的代码相关。在前面的代码中，sleep之前释放了锁，但是在释放锁和broken_sleep之间可能会发生中断。</p>
<p>一旦释放了锁，当前CPU的中断会被重新打开。</p>
<p>因为这是一个多核机器，所以中断可能发生在任意一个CPU核。</p>
<p>在上面代码标记的位置，其他CPU核上正在执行UART的中断处理程序，并且正在acquire函数中等待当前锁释放。</p>
<p>所以一旦锁被释放了，另一个CPU核就会获取锁，并发现UART硬件完成了发送上一个字符，之后会设置tx_done为1，最后再调用wakeup函数，并传入tx_chan。</p>
<p>目前为止一切都还好，除了一点：现在写线程还在执行并位于release和broken_sleep之间，也就是写线程还没有进入SLEEPING状态，所以中断处理程序中的wakeup并没有唤醒任何进程，因为还没有任何进程在tx_chan上睡眠。</p>
<p>之后写线程会继续运行，调用broken_sleep，将进程状态设置为SLEEPING，保存sleep channel。</p>
<p>但是中断已经发生了，wakeup也已经被调用了。所以这次的broken_sleep，没有人会唤醒它，因为wakeup已经发生过了。这就是lost wakeup问题。</p>
<blockquote>
<p>学生提问：是不是总是这样，一旦一个wakeup被丢失了，下一次wakeup时，之前缓存的数据会继续输出？</p>
<p>Robert教授：这完全取决于实现细节。</p>
<p>在我们的例子中，实际上出于偶然才会出现当我输入某些内容会导致之前的输出继续的现象。</p>
<p>这里背后的原因是，我们的代码中，UART只有一个中断处理程序。</p>
<p>不论是有输入，还是完成了一次输出，都会调用到同一个中断处理程序中。</p>
<p>所以当我输入某些内容时，会触发输入中断，之后会调用uartintr函数。</p>
<p>然后在中断处理程序中又会判断LSR_TX_IDLE标志位，并再次调用wakeup，所以刚刚的现象完全是偶然。</p>
<p>如果出现了lost wakeup问题，并且你足够幸运的话，某些时候它们能自动修复。</p>
<p>如果UART有不同的接收和发送中断处理程序的话，那么就没办法从lost wakeup恢复。</p>
<p>学生提问：tx_done标志位的作用是什么？</p>
<p>Robert教授：这是一种简单的在uartintr和uartwrite函数之间通信的方法。</p>
<p>tx_done标志位为1表示已经完成了对于前一个字符的传输，并且uartwrite可以传输下一个字符，所以这是用来在中断处理程序和uartwrite之间通信的标志位。</p>
<p>同一个学生提问：当从sleep函数中唤醒时，不是已经知道是来自UART的中断处理程序调用wakeup的结果吗？这样的话tx_done有些多余。</p>
<p>Robert教授：我想你的问题也可以描述为：为什么需要通过一个循环while(tx_done == 0)来调用sleep函数？</p>
<p>这个问题的答案适用于一个更通用的场景：实际中不太可能将sleep和wakeup精确匹配。</p>
<p>并不是说sleep函数返回了，你等待的事件就一定会发生。</p>
<p>举个例子，假设我们有两个进程同时想写UART，它们都在uartwrite函数中。</p>
<p>可能发生这种场景，当一个进程写完一个字符之后，会进入SLEEPING状态并释放锁，而另一个进程可以在这时进入到循环并等待UART空闲下来。</p>
<p>之后两个进程都进入到SLEEPING状态，当发生中断时UART可以再次接收一个字符，两个进程都会被唤醒，但是只有一个进程应该写入字符，所以我们才需要在sleep外面包一层while循环。</p>
<p>实际上，你可以在XV6中的每一个sleep函数调用都被一个while循环包着。</p>
<p>因为事实是，你或许被唤醒了，但是其他人将你等待的事件拿走了，所以你还得继续sleep。这种现象还挺普遍的。</p>
<p>学生提问：我们只看到了一个lost wakeup，当我们随便输入一个字符，整个剩下的字符都能输出，为什么没有在输出剩下字符的时候再次发生lost wakeup？</p>
<p>Robert教授：这会发生的。</p>
<p>我来敲一下cat README，这会输出数千个字符。</p>
<p>可以看到每过几个字符就会hang一次，需要我再次输入某个字符。</p>
<p>这个过程我们可以看到很多lost wakeup。</p>
<p>之前之所以没有出现，是因为lost wakeup需要中断已经在等待获取锁，并且uartwrite位于release和broken_sleep之间，这需要一定的巧合并不总是会发生。</p>
</blockquote>
<h2 id="如何避免lost-wakeup">如何避免Lost wakeup
</h2><p>现在我们的目标是消灭掉lost wakeup。这可以通过消除下面的窗口时间来实现。</p>
<p><img src="/p/mit6s08113sleep-wake-up/p18.png"
	width="316"
	height="104"
	srcset="/p/mit6s08113sleep-wake-up/p18_hu9843325075709440457.png 480w, /p/mit6s08113sleep-wake-up/p18_hu8888509490397141538.png 1024w"
	loading="lazy"
	
		alt="p18"
	
	
		class="gallery-image" 
		data-flex-grow="303"
		data-flex-basis="729px"
	
></p>
<p>首先我们必须要释放uart_tx_lock锁，因为中断需要获取这个锁，但是我们又不能在释放锁和进程将自己标记为SLEEPING之间留有窗口。</p>
<p>这样中断处理程序中的wakeup才能看到SLEEPING状态的进程，并将其唤醒，进而我们才可以避免lost wakeup的问题。</p>
<p>所以，我们应该消除这里的窗口。</p>
<p>为了实现这个目的，我们需要将sleep函数设计的稍微复杂点。</p>
<p>这里的解决方法是，即使sleep函数不需要知道你在等待什么事件，它还是需要你知道你在等待什么数据，并且传入一个用来保护你在等待数据的锁。</p>
<p>sleep函数需要特定的条件才能执行，而sleep自己又不需要知道这个条件是什么。</p>
<p>在我们的例子中，sleep函数执行的特定条件是tx_done等于1。</p>
<p>虽然sleep不需要知道tx_done，但是它需要知道保护这个条件的锁，也就是这里的uart_tx_lock。</p>
<p>在调用sleep的时候，锁还被当前线程持有，之后这个锁被传递给了sleep。</p>
<p>在接口层面，sleep承诺可以原子性的将进程设置成SLEEPING状态，同时释放锁。</p>
<p>这样wakeup就不可能看到这样的场景：锁被释放了但是进程还没有进入到SLEEPING状态。</p>
<p>所以sleep这里将释放锁和设置进程为SLEEPING状态这两个行为合并为一个原子操作。</p>
<p>所以我们需要有一个锁来保护sleep的条件，并且这个锁需要传递给sleep作为参数。</p>
<p>更进一步的是，当调用wakeup时，锁必须被持有。</p>
<p>如果程序员想要写出正确的代码，都必须遵守这些规则来使用sleep和wakeup。</p>
<p>接下来我们看一下sleep和wakeup如何使用这一小块额外的信息（注，也就是传入给sleep函数的锁）和刚刚提到的规则，来避免lost wakeup。</p>
<p>首先我们来看一下proc.c中的wakeup函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">//Wake up all processes sleeping on chan.
</span></span></span><span class="line"><span class="cl"><span class="c1">//Must be called without any p-&gt;lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">wakeup</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span><span class="n">p</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">proc</span><span class="p">[</span><span class="n">NPROC</span><span class="p">];</span><span class="n">p</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span><span class="n">SLEEPING</span> <span class="o">&amp;&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">chan</span> <span class="o">=</span><span class="n">chan</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="n">RUNNABLE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>wakeup函数并不十分出人意料。</p>
<p>它查看整个进程表单，对于每个进程首先加锁，这点很重要。</p>
<p>之后查看进程的状态，如果进程当前是SLEEPING并且进程的channel与wakeup传入的channel相同，将进程的状态设置为RUNNABLE。最后再释放进程的锁。</p>
<p>接下来我们忽略broken_sleep，直接查看带有锁作为参数的sleep函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// Atomically release lock and sleep on chan.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Reacquires lock when awakened.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">sleep</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spinlock</span> <span class="o">*</span><span class="n">lk</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nf">myproc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">// Must acquire p-&gt;lock in order to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// change p-&gt;state and then call sched.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Once we hold p-&gt;lock, we can be
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// guaranteed that we won&#39;t miss any wakeup
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// (wakeup locks p-&gt;lock),
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// so it&#39;s okay to release lk.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span><span class="n">lk</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">){</span>  <span class="c1">//DOC: sleeplock0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>  <span class="c1">//DOC: sleeplock1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">release</span><span class="p">(</span><span class="n">lk</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Go to sleep.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">p</span><span class="o">-&gt;</span><span class="n">chan</span> <span class="o">=</span> <span class="n">chan</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SLEEPING</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">sched</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Tidy up.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">p</span><span class="o">-&gt;</span><span class="n">chan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Reacquire original lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span><span class="n">lk</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">acquire</span><span class="p">(</span><span class="n">lk</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们已经知道了sleep函数需要释放作为第二个参数传入的锁，这样中断处理程序才能获取锁。</p>
<p>函数中第一件事情就是释放这个锁。</p>
<p>当然在释放锁之后，我们会担心在这个时间点相应的wakeup会被调用并尝试唤醒当前进程，而当前进程还没有进入到SLEEPING状态。</p>
<p>所以我们不能让wakeup在release锁之后执行。</p>
<p>为了让它不在release锁之后执行，在release锁之前，sleep会获取即将进入SLEEPING状态的进程的锁。</p>
<p>如果你还记得的话，wakeup在唤醒一个进程前，需要先获取进程的锁。</p>
<p>所以在整个时间uartwrite检查条件之前到sleep函数中调用sched函数之间，这个线程一直持有了保护sleep条件的锁或者p-&gt;lock。</p>
<p>让我回到UART的代码并强调一下这一点。</p>
<p><img src="/p/mit6s08113sleep-wake-up/p15.png"
	width="652"
	height="436"
	srcset="/p/mit6s08113sleep-wake-up/p15_hu4295009018915899424.png 480w, /p/mit6s08113sleep-wake-up/p15_hu16512682733592663328.png 1024w"
	loading="lazy"
	
		alt="p15"
	
	
		class="gallery-image" 
		data-flex-grow="149"
		data-flex-basis="358px"
	
></p>
<p>uartwrite在最开始获取了sleep的condition lock，并且一直持有condition lock直到调用sleep函数。</p>
<p>所以它首先获取了condition lock，之后检查condition（注，也就是tx_done等于0），之后在持有condition lock的前提下调用了sleep函数。</p>
<p>此时wakeup不能做任何事情，wakeup现在甚至都不能被调用直到调用者能持有condition lock。所以现在wakeup必然还没有执行。</p>
<p>sleep函数在释放condition lock之前，先获取了进程的锁。</p>
<p>在释放了condition lock之后，wakeup就可以被调用了，但是除非wakeup获取了进程的锁，否则wakeup不能查看进程的状态。</p>
<p>所以，在sleep函数中释放了condition lock之后，wakeup也还没有执行。</p>
<p>在持有进程锁的时候，将进程的状态设置为SLEEPING并记录sleep channel，之后再调用sched函数，这个函数中会再调用switch函数（注，详见11.6），此时sleep函数中仍然持有了进程的锁，wakeup仍然不能做任何事情。</p>
<p>当我们从当前线程切换走时，调度器线程中会释放前一个进程的锁（注，详见11.8）。</p>
<p>所以在调度器线程释放进程锁之后，wakeup才能终于获取进程的锁，发现它正在SLEEPING状态，并唤醒它。</p>
<p>这里的效果是由之前定义的一些规则确保的，这些规则包括了：</p>
<ul>
<li>调用sleep时需要持有condition lock，这样sleep函数才能知道相应的锁。</li>
<li>sleep函数只有在获取到进程的锁p-&gt;lock之后，才能释放condition lock。</li>
<li>wakeup需要同时持有两个锁才能查看进程。</li>
</ul>
<p>这样的话，我们就不会再丢失任何一个wakeup，也就是说我们修复了lost wakeup的问题。</p>
<h2 id="pipe中的sleep和wakeup">Pipe中的sleep和wakeup
</h2><p>前面我们介绍了在UART的驱动中，如何使用sleep和wakeup才能避免lost wakeup。</p>
<p>前面这个特定的场景中，sleep等待的condition是发生了中断并且硬件准备好了传输下一个字符。</p>
<p>在一些其他场景，内核代码会调用sleep函数并等待其他的线程完成某些事情。</p>
<p>这些场景从概念上来说与我们介绍之前的场景没有什么区别，但是感觉上还是有些差异。</p>
<p>例如，在读写pipe的代码中，如果你查看pipe.c中的piperead函数，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="nf">piperead</span><span class="p">(</span><span class="k">struct</span> <span class="n">pipe</span> <span class="o">*</span><span class="n">pi</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">pr</span> <span class="o">=</span> <span class="nf">myproc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nread</span> <span class="o">==</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">nwrite</span> <span class="o">&amp;&amp;</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">writeopen</span><span class="p">){</span>  <span class="c1">//DOC: pipe-empty
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">killed</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span> <span class="c1">//DOC: piperead-sleep
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>  <span class="c1">//DOC: piperead-copy
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nread</span> <span class="o">==</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">nwrite</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ch</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nread</span><span class="o">++</span> <span class="o">%</span> <span class="n">PIPESIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="nf">copyout</span><span class="p">(</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nwrite</span><span class="p">);</span>  <span class="c1">//DOC: piperead-wakeup
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里有很多无关的代码可以忽略。</p>
<p>当read系统调用最终调用到piperead函数时，pi-&gt;lock会用来保护pipe，这就是sleep函数对应的condition lock。</p>
<p>piperead需要等待的condition是pipe中有数据，而这个condition就是pi-&gt;nwrite大于pi-&gt;nread，也就是写入pipe的字节数大于被读取的字节数。</p>
<p>如果这个condition不满足，那么piperead会调用sleep函数，并等待condition发生。</p>
<p>同时piperead会将condition lock也就是pi-&gt;lock作为参数传递给sleep函数，以确保不会发生lost wakeup。</p>
<p>之所以会出现lost wakeup，是因为在一个不同的CPU核上可能有另一个线程刚刚调用了pipewrite。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="nf">pipewrite</span><span class="p">(</span><span class="k">struct</span> <span class="n">pipe</span> <span class="o">*</span><span class="n">pi</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">pr</span> <span class="o">=</span> <span class="nf">myproc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nwrite</span> <span class="o">==</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">nread</span> <span class="o">+</span> <span class="n">PIPESIZE</span><span class="p">){</span>  <span class="c1">//DOC: pipewrite-full
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">readopen</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pr</span><span class="o">-&gt;</span><span class="n">killed</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="nf">wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nread</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nf">sleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nwrite</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="nf">copyin</span><span class="p">(</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pi</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nwrite</span><span class="o">++</span> <span class="o">%</span> <span class="n">PIPESIZE</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nread</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>pipewrite会向pipe的缓存写数据，并最后在piperead所等待的sleep channel上调用wakeup。</p>
<p>而我们想要避免这样的风险：在piperead函数检查发现没有字节可以读取，到piperead函数调用sleep函数之间，另一个CPU调用了pipewrite函数。</p>
<p>因为这样的话，另一个CPU会向pipe写入数据并在piperead进程进入SLEEPING之前调用wakeup，进而产生一次lost wakeup。</p>
<p>在pipe的代码中，pipewrite和piperead都将sleep包装在一个while循环中。</p>
<p>piperead中的循环等待pipe的缓存为非空（pipewrite中的循环等待的是pipe的缓存不为full）。</p>
<p>之所以要将sleep包装在一个循环中，是因为可能有多个进程在读取同一个pipe。</p>
<p>但是因为pipe中只有一个字节并且总是有一个进程能够先被唤醒。</p>
<p>sleep函数中最后一件事情就是重新获取condition lock。所以调用sleep函数的时候，需要对condition lock上锁（注，在sleep函数内部会对condition lock解锁），在sleep函数返回时会重新对condition lock上锁。</p>
<p>这样第一个被唤醒的线程会持有condition lock，而其他的线程在重新对condition lock上锁的时候会在锁的acquire函数中等待。</p>
<p>那个幸运的进程（注，这里线程和进程描述的有些乱，但是基本意思是一样的，当说到线程时是指进程唯一的内核线程）会从sleep函数中返回，之后通过检查可以发现pi-&gt;nwrite比pi-&gt;nread大1，所以进程可以从piperead的循环中退出，并读取一个字节，之后pipe缓存中就没有数据了。</p>
<p>之后piperead函数释放锁并返回。接下来，第二个被唤醒的线程，它的sleep函数可以获取condition lock并返回，但是通过检查发现pi-&gt;nwrite等于pi-&gt;nread（注，因为唯一的字节已经被前一个进程读走了），所以这个线程以及其他所有的等待线程都会重新进入sleep函数。</p>
<p>所以这里也可以看出，几乎所有对于sleep的调用都需要包装在一个循环中，这样从sleep中返回的时候才能够重新检查condition是否还符合。</p>
<p>sleep和wakeup的规则稍微有点复杂。</p>
<p>因为你需要向sleep展示你正在等待什么数据，你需要传入锁并遵循一些规则，某些时候这些规则还挺烦人的。</p>
<p>另一方面sleep和wakeup又足够灵活，因为它们并不需要理解对应的condition，只是需要有个condition和保护这个condition的锁。</p>
<p>除了sleep&amp;wakeup之外，还有一些其他的更高级的Coordination实现方式。</p>
<p>例如今天课程的阅读材料中的semaphore，它的接口就没有那么复杂，你不用告诉semaphore有关锁的信息。而semaphore的调用者也不需要担心lost wakeup的问题，在semaphore的内部实现中考虑了lost wakeup问题。</p>
<p>因为定制了up-down计数器，所以semaphore可以在不向接口泄露数据的同时（注，也就是不需要向接口传递condition lock），处理lost wakeup问题。</p>
<p>semaphore某种程度来说更简单，尽管它也没那么通用，如果你不是在等待一个计数器，semaphore也就没有那么有用了。这也就是为什么我说sleep和wakeup更通用的原因。</p>
<h2 id="exit系统调用">exit系统调用
</h2><p>接下来，我想讨论一下XV6面临的一个与Sleep&amp;Wakeup相关的挑战，也就是如何关闭一个进程。</p>
<p>每个进程最终都需要退出，我们需要清除进程的状态，释放栈。</p>
<p>在XV6中，一个进程如果退出的话，我们需要释放用户内存，释放page table，释放trapframe对象，将进程在进程表单中标为REUSABLE，这些都是典型的清理步骤。</p>
<p>当进程退出或者被杀掉时，有许多东西都需要被释放。</p>
<p>这里会产生的两大问题：</p>
<ul>
<li>首先我们不能直接单方面的摧毁另一个线程，因为：另一个线程可能正在另一个CPU核上运行，并使用着自己的栈；也可能另一个线程正在内核中持有了锁；也可能另一个线程正在更新一个复杂的内核数据，如果我们直接就把线程杀掉了，我们可能在线程完成更新复杂的内核数据过程中就把线程杀掉了。我们不能让这里的任何一件事情发生。</li>
<li>另一个问题是，即使一个线程调用了exit系统调用，并且是自己决定要退出。它仍然持有了运行代码所需要的一些资源，例如它的栈，以及它在进程表单中的位置。当它还在执行代码，它就不能释放正在使用的资源。所以我们需要一种方法让线程能释放最后几个对于运行代码来说关键的资源。</li>
</ul>
<p>XV6有两个函数与关闭线程进程相关。</p>
<p>第一个是exit，第二个是kill。</p>
<p>让我们先来看位于proc.c中的exit函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// Exit the current process.  Does not return.
</span></span></span><span class="line"><span class="cl"><span class="c1">// An exited process remains in the zombie state
</span></span></span><span class="line"><span class="cl"><span class="c1">// until its parent calls wait().
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">exit</span><span class="p">(</span><span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nf">myproc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">initproc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">panic</span><span class="p">(</span><span class="s">&#34;init exiting&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Close all open files.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fd</span> <span class="o">&lt;</span> <span class="n">NOFILE</span><span class="p">;</span> <span class="n">fd</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ofile</span><span class="p">[</span><span class="n">fd</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">      <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ofile</span><span class="p">[</span><span class="n">fd</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="nf">fileclose</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">p</span><span class="o">-&gt;</span><span class="n">ofile</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">begin_op</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="nf">iput</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cwd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">end_op</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">cwd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// we might re-parent a child to init. we can&#39;t be precise about
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// waking up init, since we can&#39;t acquire its lock once we&#39;ve
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// acquired any other proc lock. so wake up init whether that&#39;s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// necessary or not. init may miss this wakeup, but that seems
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// harmless.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">initproc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">wakeup1</span><span class="p">(</span><span class="n">initproc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">initproc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// grab a copy of p-&gt;parent, to ensure that we unlock the same
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// parent we locked. in case our parent gives us away to init while
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// we&#39;re waiting for the parent lock. we may then race with an
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// exiting parent, but the result will be a harmless spurious wakeup
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// to a dead or wrong process; proc structs are never re-allocated
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// as anything else.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">original_parent</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">// we need the parent&#39;s lock in order to wake it up from wait().
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the parent-then-child rule says we have to lock it first.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">original_parent</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Give any children to init.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">reparent</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Parent might be sleeping in wait().
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">wakeup1</span><span class="p">(</span><span class="n">original_parent</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">xstate</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">ZOMBIE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">original_parent</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Jump into the scheduler, never to return.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">sched</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="nf">panic</span><span class="p">(</span><span class="s">&#34;zombie exit&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这就是exit系统调用的内容。</p>
<p>从exit接口的整体来看，在最后它会释放进程的<strong>内存</strong>和<strong>page table</strong>，关闭已经<strong>打开的文件</strong>，同时我们也知道<strong>父进程</strong>会从wait系统调用中唤醒，所以exit最终会导致父进程被唤醒。这些都是我们预期可以从exit代码中看到的内容。</p>
<p>从上面的代码中，首先exit函数关闭了所有已打开的文件。</p>
<p>这里可能会很复杂，因为关闭文件系统中的文件涉及到引用计数，虽然我们还没学到但是这里需要大量的工作。</p>
<p>不管怎样，一个进程调用exit系统调用时，会关闭所有自己拥有的文件。</p>
<p>接下来是类似的处理，进程有一个对于当前目录的记录，这个记录会随着你执行cd指令而改变。</p>
<p>在exit过程中也需要将对这个目录的引用释放给文件系统。</p>
<p>如果一个进程要退出，但是它又有自己的子进程，接下来需要设置这些子进程的父进程为init进程。</p>
<p>我们接下来会看到，每一个正在exit的进程，都有一个父进程中的对应的wait系统调用。</p>
<p>父进程中的<strong>wait系统调用</strong>会完成进程退出最后的几个步骤。</p>
<p>所以如果父进程退出了，那么子进程就不再有父进程，当它们要退出时就没有对应的父进程的wait。</p>
<p>所以在exit函数中，会为即将exit进程的子进程重新指定父进程为init进程，也就是PID为1的进程。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="c1">// we need the parent&#39;s lock in order to wake it up from wait().
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the parent-then-child rule says we have to lock it first.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">original_parent</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Give any children to init.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">reparent</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Parent might be sleeping in wait().
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">wakeup1</span><span class="p">(</span><span class="n">original_parent</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">xstate</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">ZOMBIE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">original_parent</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Jump into the scheduler, never to return.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">sched</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="nf">panic</span><span class="p">(</span><span class="s">&#34;zombie exit&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>之后，我们需要通过调用wakeup函数唤醒当前进程的父进程，当前进程的父进程或许正在等待当前进程退出。</p>
<p>接下来，进程的状态被设置为ZOMBIE。</p>
<p>现在进程还没有完全释放它的资源，所以它还不能被重用。</p>
<p>所谓的进程重用是指，我们期望在最后，进程的所有状态都可以被一些其他无关的fork系统调用复用，但是目前我们还没有到那一步。</p>
<p>现在我们还没有结束，因为我们还没有释放进程资源。我们在还没有完全释放所有资源的时候，通过调用sched函数进入到调度器线程。</p>
<p>到目前位置，进程的状态是ZOMBIE，并且进程不会再运行，因为调度器只会运行RUNNABLE进程。</p>
<p>同时进程资源也并没有完全释放，如果释放了进程的状态应该是UNUSED。</p>
<p>但是可以肯定的是进程不会再运行了，因为它的状态是ZOMBIE。所以调度器线程会决定运行其他的进程。</p>
<h2 id="wait系统调用">wait系统调用
</h2><p>通过Unix的exit和wait系统调用的说明，我们可以知道如果一个进程exit了，并且它的父进程调用了wait系统调用，父进程的wait会返回。</p>
<p>wait函数的返回表明当前进程的一个子进程退出了。</p>
<p>接下来看一下wait系统调用的实现。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// Wait for a child process to exit and return its pid.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Return -1 if this process has no children.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="nf">wait</span><span class="p">(</span><span class="n">uint64</span> <span class="n">addr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">havekids</span><span class="p">,</span> <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nf">myproc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// hold p-&gt;lock for the whole time to avoid lost
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// wakeups from a child&#39;s exit().
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(;;){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Scan through table looking for exited children.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">havekids</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">np</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span> <span class="n">np</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">proc</span><span class="p">[</span><span class="n">NPROC</span><span class="p">];</span> <span class="n">np</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// this code uses np-&gt;parent without holding np-&gt;lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// acquiring the lock first would cause a deadlock,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// since np might be an ancestor, and we already hold p-&gt;lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="n">p</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// np-&gt;parent can&#39;t change between the check and the acquire()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// because only the parent changes it, and we&#39;re the parent.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">havekids</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">ZOMBIE</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// Found one.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">pid</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span><span class="p">(</span><span class="n">addr</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nf">copyout</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">xstate</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                  <span class="k">sizeof</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">xstate</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="nf">freeproc</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// No point waiting if we don&#39;t have any children.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">havekids</span> <span class="o">||</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">killed</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Wait for a child to exit.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sleep</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>  <span class="c1">//DOC: wait-sleep
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>它里面包含了一个大的循环。</p>
<p>当一个进程调用了wait系统调用，它会扫描进程表单，找到父进程是自己且状态是ZOMBIE的进程。</p>
<p>从上一节可以知道，这些进程已经在exit函数中几乎要执行完了。</p>
<p>之后由父进程调用的freeproc函数，来完成释放进程资源的最后几个步骤。</p>
<p>看一下freeproc的实现，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// free a proc structure and the data hanging from it,
</span></span></span><span class="line"><span class="cl"><span class="c1">// including user pages.
</span></span></span><span class="line"><span class="cl"><span class="c1">// p-&gt;lock must be held.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">freeproc</span><span class="p">(</span><span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">kfree</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">proc_freepagetable</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sz</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">chan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">killed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">xstate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">UNUSED</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这是关闭一个进程的最后一些步骤。</p>
<p>如果由正在退出的进程自己在exit函数中执行这些步骤，将会非常奇怪。</p>
<p>这里释放了trapframe，释放了page table。如果我们需要释放进程内核栈，那么也应该在这里释放。</p>
<p>但是因为内核栈的guard page，我们没有必要再释放一次内核栈。</p>
<p>不管怎样，当进程还在exit函数中运行时，任何这些资源在exit函数中释放都会很难受，所以这些资源都是由父进程释放的。</p>
<p>wait不仅是为了父进程方便的知道子进程退出，wait实际上也是进程退出的一个重要组成部分。</p>
<p>在Unix中，对于每一个退出的进程，都需要有一个对应的wait系统调用，这就是为什么当一个进程退出时，它的子进程需要变成init进程的子进程。</p>
<p>init进程的工作就是在一个循环中不停调用wait，因为每个进程都需要对应一个wait，这样它的父进程才能调用freeproc函数，并清理进程的资源。</p>
<p>当父进程完成了清理进程的所有资源，子进程的状态会被设置成UNUSED。</p>
<p>之后，fork系统调用才能重用进程在进程表单的位置。</p>
<blockquote>
<p>学生提问：在exit系统调用中，为什么需要在重新设置父进程之前，先获取当前进程的父进程？</p>
<p>Robert教授：这里其实就是在防止一个进程和它的父进程同时退出。</p>
<p>通常情况下，一个进程exit，它的父进程正在wait，一切都正常。</p>
<p>但是也可能一个进程和它的父进程同时exit。</p>
<p>所以当子进程尝试唤醒父进程，并告诉它自己退出了时，父进程也在退出。</p>
<p>它应该是处理这种父进程和子进程同时退出的情况。</p>
<p>如果不是这种情况的话，一切都会非常直观，子进程会在后面通过wakeup函数唤醒父进程。</p>
<p>学生提问：为什么我们在唤醒父进程之后才将进程的状态设置为ZOMBIE？难道我们不应该在之前就设置吗？</p>
<p>Robert教授：正在退出的进程会先获取自己进程的锁，同时，因为父进程的wait系统调用中也需要获取子进程的锁，所以父进程并不能查看正在执行exit函数的进程的状态。</p>
<p>这意味着，正在退出的进程获取自己的锁到它调用sched进入到调度器线程之间（注，因为调度器线程会释放进程的锁），父进程并不能看到这之间代码引起的中间状态。</p>
<p>所以这之间的代码顺序并不重要。</p>
<p>大部分时候，如果没有持有锁，exit中任何代码顺序都不能工作。</p>
<p>因为有了锁，代码的顺序就不再重要，因为父进程也看不到进程状态。</p>
</blockquote>
<p>所以，直到子进程exit的最后，它都没有释放所有的资源，因为它还在运行的过程中，所以不能释放这些资源。</p>
<p>相应的其他的进程，也就是父进程，释放了运行子进程代码所需要的资源。这样的设计可以让我们极大的精简exit的实现。</p>
<h2 id="kill系统调用">kill系统调用
</h2><p>Unix中的一个进程可以将另一个进程的ID传递给kill系统调用，并让另一个进程停止运行。</p>
<p>如果我们不够小心的话，kill一个还在内核执行代码的进程，会有一些我几分钟前介绍过的风险，比如我们想要杀掉的进程的内核线程还在更新一些数据，比如说更新文件系统，创建一个文件。</p>
<p>如果这样的话，我们不能就这样杀掉进程，因为这样会使得一些需要多步完成的操作只执行了一部分。</p>
<p>所以kill系统调用不能就直接停止目标进程的运行。</p>
<p>实际上，在XV6和其他的Unix系统中，kill系统调用基本上不做任何事情。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// Kill the process with the given pid.
</span></span></span><span class="line"><span class="cl"><span class="c1">// The victim won&#39;t exit until it tries to return
</span></span></span><span class="line"><span class="cl"><span class="c1">// to user space (see usertrap() in trap.c).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="nf">kill</span><span class="p">(</span><span class="kt">int</span> <span class="n">pid</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">proc</span><span class="p">[</span><span class="n">NPROC</span><span class="p">];</span> <span class="n">p</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">==</span> <span class="n">pid</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">p</span><span class="o">-&gt;</span><span class="n">killed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SLEEPING</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Wake process from sleep().
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">RUNNABLE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>它先扫描进程表单，找到目标进程。</p>
<p>然后只是将进程的proc结构体中killed标志位设置为1。</p>
<p>如果进程正在SLEEPING状态，将其设置为RUNNABLE。</p>
<p>这里只是将killed标志位设置为1，并没有停止进程的运行。</p>
<p>所以kill系统调用本身还是很温和的。</p>
<p>而目标进程运行到内核代码中能安全停止运行的位置时，会检查自己的killed标志位，如果设置为1，目标进程会自愿的执行exit系统调用。</p>
<p>你可以在trap.c中看到所有可以安全停止运行的位置，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// handle an interrupt, exception, or system call from user space.
</span></span></span><span class="line"><span class="cl"><span class="c1">// called from trampoline.S
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">usertrap</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">which_dev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">((</span><span class="nf">r_sstatus</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">SSTATUS_SPP</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">panic</span><span class="p">(</span><span class="s">&#34;usertrap: not from user mode&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// send interrupts and exceptions to kerneltrap(),
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// since we&#39;re now in the kernel.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">w_stvec</span><span class="p">((</span><span class="n">uint64</span><span class="p">)</span><span class="n">kernelvec</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nf">myproc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">// save user program counter.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">epc</span> <span class="o">=</span> <span class="nf">r_sepc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="nf">r_scause</span><span class="p">()</span> <span class="o">==</span> <span class="mi">8</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// system call
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">killed</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nf">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// sepc points to the ecall instruction,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// but we want to return to the next instruction.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">epc</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// an interrupt will change sstatus &amp;c registers,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// so don&#39;t enable until done with those registers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">intr_on</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">syscall</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">((</span><span class="n">which_dev</span> <span class="o">=</span> <span class="nf">devintr</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ok
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;usertrap(): unexpected scause %p pid=%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">r_scause</span><span class="p">(),</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;            sepc=%p stval=%p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">r_sepc</span><span class="p">(),</span> <span class="nf">r_stval</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="o">-&gt;</span><span class="n">killed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">killed</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在usertrap函数中（注，详见6.6），在执行系统调用之前，如果进程已经被kill了，进程会自己调用exit。</p>
<p>在这个内核代码位置，代码并没有持有任何锁，也不在执行任何操作的过程中，所以进程通过exit退出是完全安全的。</p>
<p>类似的，在usertrap函数的最后，也有类似的代码。</p>
<p>在执行完系统调用之后，进程会再次检查自己是否已经被kill了。</p>
<p>即使进程是被中断打断，这里的检查也会被执行。</p>
<p>例如当一个定时器中断打断了进程的运行，我们可以通过检查发现进程是killed状态，之后进程会调用exit退出。</p>
<p>所以kill系统调用并不是真正的立即停止进程的运行，它更像是这样：如果进程在用户空间，那么下一次它执行系统调用它就会退出，又或者目标进程正在执行用户代码，当时下一次定时器中断或者其他中断触发了，进程才会退出。</p>
<p>所以从一个进程调用kill，到另一个进程真正退出，中间可能有很明显的延时。</p>
<p>这里有个很直观问题：如果进程不在用户空间执行，而是正在执行系统调用的过程中，然后它被kill了，我们需要做什么特别的操作吗？</p>
<p>之所以会提出这个问题，是因为进程可能正在从console读取即将输入的字符，而你可能要明天才会输入一个字符，所以当你kill一个进程时，最好进程不是等到明天才退出。</p>
<p>出于这个原因，在XV6的很多位置中，如果进程在SLEEPING状态时被kill了，进程会实际的退出。</p>
<p>首先要看的是kill函数，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="nf">kill</span><span class="p">(</span><span class="kt">int</span> <span class="n">pid</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">proc</span><span class="p">[</span><span class="n">NPROC</span><span class="p">];</span> <span class="n">p</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">==</span> <span class="n">pid</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">p</span><span class="o">-&gt;</span><span class="n">killed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SLEEPING</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Wake process from sleep().
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">RUNNABLE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到如果目标进程是SLEEPING状态，kill函数会将其状态设置为RUNNABLE，这意味着，即使进程之前调用了sleep并进入到SLEEPING状态，调度器现在会重新运行进程，并且进程会从sleep中返回。</p>
<p>让我们来查看一下这在哪生效的。</p>
<p>在pipe.c的piperead函数中，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="nf">piperead</span><span class="p">(</span><span class="k">struct</span> <span class="n">pipe</span> <span class="o">*</span><span class="n">pi</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">pr</span> <span class="o">=</span> <span class="nf">myproc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nread</span> <span class="o">==</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">nwrite</span> <span class="o">&amp;&amp;</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">writeopen</span><span class="p">){</span>  <span class="c1">//DOC: pipe-empty
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">killed</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span> <span class="c1">//DOC: piperead-sleep
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>  <span class="c1">//DOC: piperead-copy
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nread</span> <span class="o">==</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">nwrite</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ch</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nread</span><span class="o">++</span> <span class="o">%</span> <span class="n">PIPESIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="nf">copyout</span><span class="p">(</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nwrite</span><span class="p">);</span>  <span class="c1">//DOC: piperead-wakeup
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果一个进程正在sleep状态等待从pipe中读取数据，然后它被kill了。</p>
<p>kill函数会将其设置为RUNNABLE，之后进程会从sleep中返回，返回到循环的最开始。</p>
<p>pipe中大概率还是没有数据，之后在piperead中，会判断进程是否被kill了（注，if(pr-&gt;killed)）。</p>
<p>如果进程被kill了，那么接下来piperead会返回-1，并且返回到usertrap函数的syscall位置，因为piperead就是一种系统调用的实现。</p>
<p>之后在usertrap函数中会检查p-&gt;killed，并调用exit。</p>
<p>所以对于SLEEPING状态的进程，如果它被kill了，它会被直接唤醒，包装了sleep的循环会检查进程的killed标志位，最后再调用exit。</p>
<p>同时还有一些情况，如果进程在SLEEPING状态中被kill了并不能直接退出。</p>
<p>例如，一个进程正在更新一个文件系统并创建一个文件的过程中，进程不适宜在这个时间点退出，因为我们想要完成文件系统的操作，之后进程才能退出。</p>
<p>我会向你展示一个磁盘驱动中的sleep循环，这个循环中就没有检查进程的killed标志位。</p>
<p>下面就是virtio_disk.c文件中的一段代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">//Wait for virtio_disk_intr()to say request has finished.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">while</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">disk</span> <span class="o">==</span> <span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="nf">sleep</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk</span><span class="p">.</span><span class="n">vdisk_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里一个进程正在等待磁盘的读取结束，这里没有检查进程的killed标志位。</p>
<p>因为现在可能正在创建文件的过程中，而这个过程涉及到多次读写磁盘。</p>
<p>我们希望完成所有的文件系统操作，完成整个系统调用，之后再检查p-&gt;killed并退出。</p>
<blockquote>
<p>学生提问：为什么一个进程允许kill另一个进程？这样一个进程不是能杀掉所有其他进程吗？</p>
<p>Robert教授：如果你在MIT的分时复用计算机Athena上这么做的话，他们可能会开除你。</p>
<p>在XV6中允许这么做是因为，XV6这是个教学用的操作系统，任何与权限相关的内容在XV6中都不存在。</p>
<p>在Linux或者真正的操作系统中，每个进程都有一个user id或多或少的对应了执行进程的用户，一些系统调用使用进程的user id来检查进程允许做的操作。</p>
<p>所以在Linux中会有额外的检查，调用kill的进程必须与被kill的进程有相同的user id，否则的话，kill操作不被允许。</p>
<p>所以，在一个分时复用的计算机上，我们会有多个用户，我们不会想要用户kill其他人的进程，这样一套机制可以防止用户误删别人的进程。</p>
<p>学生提问：init进程会退出吗？</p>
<p>Robert教授：让我来看看。</p>
<p>是的，如果fork失败了，init进程也会退出。不过，这个问题的真正的答案是，不会退出。init进程的目标就是不退出，它就是在一个循环中不停的调用wait。如果init进程退出了，我认为这是一个Fatal级别的错误，然后系统会崩溃。在exit函数的最开始就会有如下检查</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">exit</span><span class="p">(</span><span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nf">myproc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">initproc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="nf">panic</span><span class="p">(</span><span class="s">&#34;init exiting&#34;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果调用exit的进程是init进程，那么会触发panic。</p>
<p>因为如果没有init进程的话，系统最终还是会停止运行。</p>
<p>如果没有init进程的话就没有人会为退出的进程调用wait系统调用，也就没有人完成进程资源的释放工作，我们最终会用光所有的进程，并引起一些其他的错误，所以我们必须要有init进程。所以这个问题的真正答案是init进程不允许退出。</p>
<p>学生提问：这节课可能没有怎么讲到，但是如果关闭一个操作系统会发生什么？</p>
<p>Robert教授：这个过程非常复杂，并且依赖于你运行的是什么系统。</p>
<p>因为文件系统是持久化的，它能在多次重启之间保持数据，我们需要保持文件系统的良好状态，如果我们正在更新文件系统的过程中，例如创建文件，然后我们想关闭操作系统，断电之类的。</p>
<p>我们需要一个策略来确保即使我们正在一个复杂的更新文件系统的过程中，我们并不会破坏磁盘上的文件系统数据。</p>
<p>文件系统其实就是一个位于磁盘的数据结构。</p>
<p>所以这里涉及到了很多的机制来确保如果你关闭操作系统或者因为断电之类，我们可以恢复磁盘上的文件系统。</p>
<p>其他的，你是否需要做一些特殊的操作来关闭系统，取决于你正在运行什么进程。</p>
<p>如果你正在运行一些重要的服务器，例如数据库服务器，并且许多其他计算机依赖这个数据库并通过网络使用它。</p>
<p>那谁知道呢？答案或许是你不能就这么直接关闭操作系统，因为你正在提供一个对于其他计算机来说非常关键的服务。</p>
<p>如果你的计算机并没有在做任何事情，那么你可以直接关闭它。</p>
<p>或许对于你的问题来说，如果你想关闭一个计算机，确保文件系统是正确的，之后停止执行指令，之后就可以关闭计算机了。</p>
</blockquote>

</section>


    <footer class="article-footer">
    

    <section class="article-lastmod">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <span>
            最后更新于 Nov 12, 2024 23:44 &#43;0800
        </span>
    </section></footer>




    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI&#43;WdtXRGWt2kTvGFasHpSy3SV"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG&#43;vnGctmUb0ZY0l8"crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05"crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.body, {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>
    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="has-image">
    <a href="/p/mit6s08123rcu/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08123rcu/bg.91a08bf3fe0a8ca435e8fbc902291fd5_hu4589796922609635382.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：23RCU"
                        
                        data-hash="md5-kaCL8/4KjKQ16PvJAikf1Q==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：23RCU</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/mit6s08122meltdown/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08122meltdown/19.8d880549dccba2f0c1613b3e41a721e5_hu3753156070077914420.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：22Meltdown"
                        
                        data-hash="md5-jYgFSdzLovDBYTs&#43;Qach5Q==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：22Meltdown</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/mit6s08121networking/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08121networking/bg.68c4376fd87b0b35da07319dd155c90d_hu10351534106733688476.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：21Networking"
                        
                        data-hash="md5-aMQ3b9h7CzXaBzGd0VXJDQ==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：21Networking</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/mit6s08120kernels-and-hll/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08120kernels-and-hll/bg.4175e6a2793e0fc340e5aced2529e40b_hu6405785273338381617.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：20Kernels and HLL"
                        
                        data-hash="md5-QXXmonk&#43;D8NA5aztJSnkCw==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：20Kernels and HLL</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/mit6s08119virtual-machines/">
        
        
            <div class="article-image">
                <img src="/p/mit6s08119virtual-machines/bg.b02a7ba1d946705c0cf2809bcf960db8_hu14546491865979434532.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post MIT6S081：19Virtual Machines  "
                        
                        data-hash="md5-sCp7odlGcFwM8oCbz5YNuA==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">MIT6S081：19Virtual Machines  </h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    

    <footer class="site-footer">

    <section class="copyright">
        &copy; 
        
        2024 echudet
    </section>
    
    <section class="powerby">
        


        <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>

        <script language="javascript"> 
            var now = new Date();
            function createtime(){
                now.setTime(now.getTime()+250);
                var grt= new Date("2024/11/10 00:00:00"); 
                days = (now - grt ) / 1000 / 60 / 60 / 24;
                dnum = Math.floor(days);
                hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
                hnum = Math.floor(hours);
                if(String(hnum).length ==1 ){hnum = "0" + hnum;}
                minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
                mnum = Math.floor(minutes);
                if(String(mnum).length ==1 ){mnum = "0" + mnum;}
                seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
                snum = Math.round(seconds);
                if(String(snum).length ==1 ){snum = "0" + snum;}

                document.getElementById("timeDate").innerHTML = "本站已稳定运行"+dnum+" 天 ";
                document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒<br>"
            }
            setInterval("createtime()",250); 
        </script> 

        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        
    
        
         
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
             
        
        

        共 747479 字 , 35 篇文章<br>使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.29.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>

</footer>



    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>


    </body>
</html>
